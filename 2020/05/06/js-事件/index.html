<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>js-事件 | Cheers's blog</title><meta name="description" content="EventTarget接口概述DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 该接口主要提供三个实例方法。  addEventListener：绑定事件的监听函数 removeEventListener：移除"><meta name="keywords" content="JavaScript"><meta name="author" content="Cheers"><meta name="copyright" content="Cheers"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="js-事件"><meta name="twitter:description" content="EventTarget接口概述DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 该接口主要提供三个实例方法。  addEventListener：绑定事件的监听函数 removeEventListener：移除"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="js-事件"><meta property="og:url" content="https://xiaoxin1993.gitee.io/2020/05/06/js-%E4%BA%8B%E4%BB%B6/"><meta property="og:site_name" content="Cheers's blog"><meta property="og:description" content="EventTarget接口概述DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 该接口主要提供三个实例方法。  addEventListener：绑定事件的监听函数 removeEventListener：移除"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-05T18:02:04.379Z"><meta property="article:modified_time" content="2020-05-05T18:02:04.379Z"><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta name="msapplication-TileColor" content="#fff"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://xiaoxin1993.gitee.io/2020/05/06/js-%E4%BA%8B%E4%BB%B6/"><link rel="prev" title="js-附录：网页元素接口" href="https://xiaoxin1993.gitee.io/2020/05/06/js-%E9%99%84%E5%BD%95%EF%BC%9A%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E6%8E%A5%E5%8F%A3/"><link rel="next" title="js-语法专题" href="https://xiaoxin1993.gitee.io/2020/04/24/js-%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"EMXSTUCH7A","apiKey":"5e62a2c8d04b2e5a21e6bb491c9bf2f9","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar_img.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">50</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventTarget接口"><span class="toc-number">1.</span> <span class="toc-text">EventTarget接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-addEventListener"><span class="toc-number">1.2.</span> <span class="toc-text">EventTarget.addEventListener()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-removeEventListener"><span class="toc-number">1.3.</span> <span class="toc-text">EventTarget.removeEventListener()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-dispatchEvent"><span class="toc-number">1.4.</span> <span class="toc-text">EventTarget.dispatchEvent()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件模型"><span class="toc-number">2.</span> <span class="toc-text">事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#监听函数"><span class="toc-number">2.1.</span> <span class="toc-text">监听函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML的on-属性"><span class="toc-number">2.1.1.</span> <span class="toc-text">HTML的on-属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元素节点的事件属性"><span class="toc-number">2.1.2.</span> <span class="toc-text">元素节点的事件属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventTarget-addEventListener-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">EventTarget.addEventListener()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">2.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this的指向"><span class="toc-number">2.2.</span> <span class="toc-text">this的指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件的传播"><span class="toc-number">2.3.</span> <span class="toc-text">事件的传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件的代理"><span class="toc-number">2.4.</span> <span class="toc-text">事件的代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event对象"><span class="toc-number">3.</span> <span class="toc-text">Event对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-1"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例属性"><span class="toc-number">3.2.</span> <span class="toc-text">实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-bubbles-Event-eventPhase"><span class="toc-number">3.2.1.</span> <span class="toc-text">Event.bubbles,Event.eventPhase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-cancelable-Event-cancelBubble-event-defaultPrevented"><span class="toc-number">3.2.2.</span> <span class="toc-text">Event.cancelable,Event.cancelBubble,event.defaultPrevented</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-currentTarget-Event-target"><span class="toc-number">3.2.3.</span> <span class="toc-text">Event.currentTarget,Event.target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-type"><span class="toc-number">3.2.4.</span> <span class="toc-text">Event.type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-timeStamp"><span class="toc-number">3.2.5.</span> <span class="toc-text">Event.timeStamp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-isTrusted"><span class="toc-number">3.2.6.</span> <span class="toc-text">Event.isTrusted</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-detail"><span class="toc-number">3.2.7.</span> <span class="toc-text">Event.detail</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例方法"><span class="toc-number">3.3.</span> <span class="toc-text">实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-preventDefault"><span class="toc-number">3.3.1.</span> <span class="toc-text">Event.preventDefault()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-stopPropagation"><span class="toc-number">3.3.2.</span> <span class="toc-text">Event.stopPropagation()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-stopImmediatePropagation"><span class="toc-number">3.3.3.</span> <span class="toc-text">Event.stopImmediatePropagation()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-composedPath"><span class="toc-number">3.3.4.</span> <span class="toc-text">Event.composedPath()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#鼠标事件"><span class="toc-number">4.</span> <span class="toc-text">鼠标事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#鼠标事件的种类"><span class="toc-number">4.1.</span> <span class="toc-text">鼠标事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseEvent接口概述"><span class="toc-number">4.2.</span> <span class="toc-text">MouseEvent接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseEvent接口的实例属性"><span class="toc-number">4.3.</span> <span class="toc-text">MouseEvent接口的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-altKey-MouseEvent-ctrlKey-MouseEvent-metaKey-MouseEvent-shiftKey"><span class="toc-number">4.3.1.</span> <span class="toc-text">MouseEvent.altKey,MouseEvent.ctrlKey,MouseEvent.metaKey,MouseEvent.shiftKey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-button-MouseEvent-buttons"><span class="toc-number">4.3.2.</span> <span class="toc-text">MouseEvent.button,MouseEvent.buttons</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-clientX-MouseEvent-clientY"><span class="toc-number">4.3.3.</span> <span class="toc-text">MouseEvent.clientX,MouseEvent.clientY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-movementX-MouseEvent-movementY"><span class="toc-number">4.3.4.</span> <span class="toc-text">MouseEvent.movementX,MouseEvent.movementY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-screenX-MouseEvent-screenY"><span class="toc-number">4.3.5.</span> <span class="toc-text">MouseEvent.screenX,MouseEvent.screenY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-offsetX-MouseEvent-offsetY"><span class="toc-number">4.3.6.</span> <span class="toc-text">MouseEvent.offsetX,MouseEvent.offsetY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-pageX-MouseEvent-pageY"><span class="toc-number">4.3.7.</span> <span class="toc-text">MouseEvent.pageX,MouseEvent.pageY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-relatedTarget"><span class="toc-number">4.3.8.</span> <span class="toc-text">MouseEvent.relatedTarget</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseEvent接口的实例方法"><span class="toc-number">4.4.</span> <span class="toc-text">MouseEvent接口的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MouseEvent-getModifierState"><span class="toc-number">4.4.1.</span> <span class="toc-text">MouseEvent.getModifierState()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WheelEvent接口"><span class="toc-number">4.5.</span> <span class="toc-text">WheelEvent接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-2"><span class="toc-number">4.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例属性-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">实例属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#键盘事件"><span class="toc-number">5.</span> <span class="toc-text">键盘事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#键盘事件的种类"><span class="toc-number">5.1.</span> <span class="toc-text">键盘事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyboardEvent接口概述"><span class="toc-number">5.2.</span> <span class="toc-text">KeyboardEvent接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyboardEvent的实例属性"><span class="toc-number">5.3.</span> <span class="toc-text">KeyboardEvent的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardEvent-altKey-KeyboardEvent-ctrlKey-KeyboardEvent-metaKey-KeyboardEvent-shiftKey"><span class="toc-number">5.3.1.</span> <span class="toc-text">KeyboardEvent.altKey,KeyboardEvent.ctrlKey,KeyboardEvent.metaKey,KeyboardEvent.shiftKey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardEvent-code"><span class="toc-number">5.3.2.</span> <span class="toc-text">KeyboardEvent.code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardEvent-key"><span class="toc-number">5.3.3.</span> <span class="toc-text">KeyboardEvent.key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardEvent-location"><span class="toc-number">5.3.4.</span> <span class="toc-text">KeyboardEvent.location</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardEvent-repeat"><span class="toc-number">5.3.5.</span> <span class="toc-text">KeyboardEvent.repeat</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyboardEvent的实例方法"><span class="toc-number">5.4.</span> <span class="toc-text">KeyboardEvent的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KeyboardEvent-getModifierState"><span class="toc-number">5.4.1.</span> <span class="toc-text">KeyboardEvent.getModifierState()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进度事件"><span class="toc-number">6.</span> <span class="toc-text">进度事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进度事件的种类"><span class="toc-number">6.1.</span> <span class="toc-text">进度事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProgressEvent接口"><span class="toc-number">6.2.</span> <span class="toc-text">ProgressEvent接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表单事件"><span class="toc-number">7.</span> <span class="toc-text">表单事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表单事件的种类"><span class="toc-number">7.1.</span> <span class="toc-text">表单事件的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#input事件"><span class="toc-number">7.1.1.</span> <span class="toc-text">input事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select事件"><span class="toc-number">7.1.2.</span> <span class="toc-text">select事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#change事件"><span class="toc-number">7.1.3.</span> <span class="toc-text">change事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invalid事件"><span class="toc-number">7.1.4.</span> <span class="toc-text">invalid事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reset事件，submit事件"><span class="toc-number">7.1.5.</span> <span class="toc-text">reset事件，submit事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputEvent接口"><span class="toc-number">7.2.</span> <span class="toc-text">InputEvent接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#触摸事件"><span class="toc-number">8.</span> <span class="toc-text">触摸事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#触摸操作概述"><span class="toc-number">8.1.</span> <span class="toc-text">触摸操作概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Touch接口"><span class="toc-number">8.2.</span> <span class="toc-text">Touch接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Touch接口概述"><span class="toc-number">8.2.1.</span> <span class="toc-text">Touch接口概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Touch接口的实例属性"><span class="toc-number">8.2.2.</span> <span class="toc-text">Touch接口的实例属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TouchList接口"><span class="toc-number">8.3.</span> <span class="toc-text">TouchList接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TouchEvent接口"><span class="toc-number">8.4.</span> <span class="toc-text">TouchEvent接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-3"><span class="toc-number">8.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例属性-2"><span class="toc-number">8.4.2.</span> <span class="toc-text">实例属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触摸事件的种类"><span class="toc-number">8.5.</span> <span class="toc-text">触摸事件的种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拖拉事件"><span class="toc-number">9.</span> <span class="toc-text">拖拉事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拖拉事件的种类"><span class="toc-number">9.1.</span> <span class="toc-text">拖拉事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DragEvent接口"><span class="toc-number">9.2.</span> <span class="toc-text">DragEvent接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataTransfer接口概述"><span class="toc-number">9.3.</span> <span class="toc-text">DataTransfer接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataTransfer的实例属性"><span class="toc-number">9.4.</span> <span class="toc-text">DataTransfer的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-dropEffect"><span class="toc-number">9.4.1.</span> <span class="toc-text">DataTransfer.dropEffect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-effectAllowed"><span class="toc-number">9.4.2.</span> <span class="toc-text">DataTransfer.effectAllowed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-files"><span class="toc-number">9.4.3.</span> <span class="toc-text">DataTransfer.files</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-types"><span class="toc-number">9.4.4.</span> <span class="toc-text">DataTransfer.types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-items"><span class="toc-number">9.4.5.</span> <span class="toc-text">DataTransfer.items</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataTransfer的实例方法"><span class="toc-number">9.5.</span> <span class="toc-text">DataTransfer的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-setData"><span class="toc-number">9.5.1.</span> <span class="toc-text">DataTransfer.setData()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-getData"><span class="toc-number">9.5.2.</span> <span class="toc-text">DataTransfer.getData()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-clearData"><span class="toc-number">9.5.3.</span> <span class="toc-text">DataTransfer.clearData()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataTransfer-setDragImage"><span class="toc-number">9.5.4.</span> <span class="toc-text">DataTransfer.setDragImage()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他常见事件"><span class="toc-number">10.</span> <span class="toc-text">其他常见事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#资源事件"><span class="toc-number">10.1.</span> <span class="toc-text">资源事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#beforeunload事件"><span class="toc-number">10.1.1.</span> <span class="toc-text">beforeunload事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unload事件"><span class="toc-number">10.1.2.</span> <span class="toc-text">unload事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load事件，error事件"><span class="toc-number">10.1.3.</span> <span class="toc-text">load事件，error事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session历史事件"><span class="toc-number">10.2.</span> <span class="toc-text">session历史事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pageshow事件，pagehide事件"><span class="toc-number">10.2.1.</span> <span class="toc-text">pageshow事件，pagehide事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#popstate事件"><span class="toc-number">10.2.2.</span> <span class="toc-text">popstate事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashchange事件"><span class="toc-number">10.2.3.</span> <span class="toc-text">hashchange事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网页状态事件"><span class="toc-number">10.3.</span> <span class="toc-text">网页状态事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOMContentLoaded事件"><span class="toc-number">10.3.1.</span> <span class="toc-text">DOMContentLoaded事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readystatechange事件"><span class="toc-number">10.3.2.</span> <span class="toc-text">readystatechange事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#窗口事件"><span class="toc-number">10.4.</span> <span class="toc-text">窗口事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scroll事件"><span class="toc-number">10.4.1.</span> <span class="toc-text">scroll事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize事件"><span class="toc-number">10.4.2.</span> <span class="toc-text">resize事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fullscreenchange事件，fullscreenerror事件"><span class="toc-number">10.4.3.</span> <span class="toc-text">fullscreenchange事件，fullscreenerror事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剪贴板事件"><span class="toc-number">10.5.</span> <span class="toc-text">剪贴板事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#焦点事件"><span class="toc-number">10.6.</span> <span class="toc-text">焦点事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CustomEvent接口"><span class="toc-number">10.7.</span> <span class="toc-text">CustomEvent接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GlobalEventHandlers接口"><span class="toc-number">11.</span> <span class="toc-text">GlobalEventHandlers接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalEventHandlers-onabort"><span class="toc-number">11.1.</span> <span class="toc-text">GlobalEventHandlers.onabort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalEventHandlers-onerror"><span class="toc-number">11.2.</span> <span class="toc-text">GlobalEventHandlers.onerror</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalEventHandlers-onload-GlobalEventHandlers-onloadstart"><span class="toc-number">11.3.</span> <span class="toc-text">GlobalEventHandlers.onload,GlobalEventHandlers.onloadstart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalEventHandlers-onfocus-GlobalEventHandlers-onblur"><span class="toc-number">11.4.</span> <span class="toc-text">GlobalEventHandlers.onfocus,GlobalEventHandlers.onblur</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalEventHandlers-onscroll"><span class="toc-number">11.5.</span> <span class="toc-text">GlobalEventHandlers.onscroll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalEventHandlers-oncontextmenu-GlobalEventHandlers-onshow"><span class="toc-number">11.6.</span> <span class="toc-text">GlobalEventHandlers.oncontextmenu,GlobalEventHandlers.onshow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他的事件属性"><span class="toc-number">11.7.</span> <span class="toc-text">其他的事件属性</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Cheers's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">js-事件</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-05-06 02:02:04"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-05-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-05-06 02:02:04"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-05-06</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/">JavaScript</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/notes/">notes</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/notes/%E4%BA%8B%E4%BB%B6/">事件</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="EventTarget接口"><a href="#EventTarget接口" class="headerlink" title="EventTarget接口"></a>EventTarget接口</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p>该接口主要提供三个实例方法。</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数</li>
<li><code>removeEventListener</code>：移除事件的监听函数</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<h3 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>type</code>：事件名称，大小写敏感。</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var button &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">button.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p>
<p>关于参数，有两个地方需要注意。</p>
<p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.addEventListener(&#39;click&#39;, &#123;</span><br><span class="line">  handleEvent: function (event) &#123;</span><br><span class="line">    console.log(&#39;click&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p>
<p>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</p>
<blockquote>
<ul>
<li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li>
<li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>
<li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>
</ul>
</blockquote>
<p>如果希望事件监听函数只执行一次，可以打开属性配置对象的<code>once</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 只执行一次的代码</span><br><span class="line">&#125;, &#123;once: true&#125;);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p>
<p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function print(x) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var el &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line">el.addEventListener(&#39;click&#39;, function () &#123; print(&#39;Hello&#39;); &#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p>
<p>监听函数内部的<code>this</code>，指向当前事件所在的那个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">var para &#x3D; document.getElementById(&#39;para&#39;);</span><br><span class="line">para.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(this.nodeName); &#x2F;&#x2F; &quot;P&quot;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p>
<h3 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h3><p><code>EventTarget.removeEventListener</code>方法用来移除<code>addEventListener</code>方法添加的事件监听函数。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, listener, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, listener, false);</span><br></pre></td></tr></table></figure>

<p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#39;mousedown&#39;, handleMouseDown, true);</span><br><span class="line">element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>
<h3 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h3><p><code>EventTarget.dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure>

<p><code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例（详见《Event 对象》章节）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">var event &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码在当前节点触发了<code>click</code>事件。</p>
<p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p>
<p>下面代码根据<code>dispatchEvent</code>方法的返回值，判断事件是否被取消了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var canceled &#x3D; !cb.dispatchEvent(event);</span><br><span class="line">if (canceled) &#123;</span><br><span class="line">  console.log(&#39;事件取消&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#39;事件未取消&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><h3 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h3><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h4 id="HTML的on-属性"><a href="#HTML的on-属性" class="headerlink" title="HTML的on-属性"></a>HTML的on-属性</h4><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line">&lt;div onclick&#x3D;&quot;console.log(&#39;触发事件&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 错误 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p>
<p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick&#x3D;&quot;console.log(2)&quot;&gt;</span><br><span class="line">  &lt;button onClick&#x3D;&quot;console.log(1)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>是</code>的子元素。<code>的`click`事件，也会触发</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p>
<p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(&#39;onclick&#39;, &#39;doSomething()&#39;);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">&#x2F;&#x2F; &lt;Element onclick&#x3D;&quot;doSomething()&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h4><p>元素节点对象的事件属性，同样可以指定监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>
<p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p>
<h4 id="EventTarget-addEventListener-1"><a href="#EventTarget-addEventListener-1" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h4><p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;load&#39;, doSomething, false);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p>
<p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p>
<p>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>监听函数内部的<code>this</code>指向触发事件的那个元素节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id&#x3D;&quot;btn&quot; onclick&#x3D;&quot;console.log(this.id)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击后会输出<code>btn</code>。</p>
<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">var btn &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">btn.onclick &#x3D; function () &#123;</span><br><span class="line">  console.log(this.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">btn.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e) &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>
<h3 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h3><p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>
<ul>
<li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li>
<li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li>
</ul>
<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;点击&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>节点之中有一个</code>节点。</p>
<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对``点击，<code>click</code>事件会触发四次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var phases &#x3D; &#123;</span><br><span class="line">  1: &#39;capture&#39;,</span><br><span class="line">  2: &#39;target&#39;,</span><br><span class="line">  3: &#39;bubble&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  var phase &#x3D; phases[event.eventPhase];</span><br><span class="line">  console.log(&quot;Tag: &#39;&quot; + tag + &quot;&#39;. EventPhase: &#39;&quot; + phase + &quot;&#39;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击以后的结果</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;capture&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;bubble&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>click</code>事件被触发了四次：<code>节点的捕获阶段和冒泡阶段各1次，</code>节点的目标阶段触发了2次。</p>
<ol>
<li>捕获阶段：事件从<code>向</code>传播时，触发``的<code>click</code>事件；</li>
<li>目标阶段：事件从<code>到达</code>时，触发``的<code>click</code>事件；</li>
<li>冒泡阶段：事件从<code>传回</code>时，再次触发``的<code>click</code>事件。</li>
</ol>
<p>其中，<code>节点有两个监听函数（`addEventListener`方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为`click`事件触发一次。所以，</code>会在<code>target</code>阶段有两次输出。</p>
<p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>节点里面的</code>节点）。所以，``节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。</p>
<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>
<h3 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h3><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul &#x3D; document.querySelector(&#39;ul&#39;);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  if (event.target.tagName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; some code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的监听函数定义在<code>节点，但是实际上，它处理的是子节点</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个``节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 事件传播到 p 元素后，就不再向下传播了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件冒泡到 p 元素后，就不再向上冒泡了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发``节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 会触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p>
<p>如果想要彻底取消该事件，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 不会被触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>
<h2 id="Event对象"><a href="#Event对象" class="headerlink" title="Event对象"></a>Event对象</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p>
<p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event &#x3D; new Event(type, options);</span><br></pre></td></tr></table></figure>

<p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ev &#x3D; new Event(</span><br><span class="line">  &#39;look&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#39;bubbles&#39;: true,</span><br><span class="line">    &#39;cancelable&#39;: false</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">document.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>
<p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  console.log(&#39;Tag: &#39; + tag); &#x2F;&#x2F; 没有任何输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">var click &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>
<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure>

<p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><h4 id="Event-bubbles-Event-eventPhase"><a href="#Event-bubbles-Event-eventPhase" class="headerlink" title="Event.bubbles,Event.eventPhase"></a>Event.bubbles,Event.eventPhase</h4><p><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p>
<p><code>Event.eventPhase</code>属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var phase &#x3D; event.eventPhase;</span><br></pre></td></tr></table></figure>

<p><code>Event.eventPhase</code>的返回值有四种可能。</p>
<ul>
<li>0，事件目前没有发生。</li>
<li>1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li>
<li>2，事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li>
<li>3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li>
</ul>
<h4 id="Event-cancelable-Event-cancelBubble-event-defaultPrevented"><a href="#Event-cancelable-Event-cancelBubble-event-defaultPrevented" class="headerlink" title="Event.cancelable,Event.cancelBubble,event.defaultPrevented"></a>Event.cancelable,Event.cancelBubble,event.defaultPrevented</h4><p><code>Event.cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p>
<p>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.cancelable  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>
<p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function preventEvent(event) &#123;</span><br><span class="line">  if (event.cancelable) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.warn(&#39;This event couldn\&#39;t be canceled.&#39;);</span><br><span class="line">    console.dir(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p>
<p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (event.defaultPrevented) &#123;</span><br><span class="line">  console.log(&#39;该事件已经取消了&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Event-currentTarget-Event-target"><a href="#Event-currentTarget-Event-target" class="headerlink" title="Event.currentTarget,Event.target"></a>Event.currentTarget,Event.target</h4><p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的原始触发节点（<code>Event.target</code>），另一个是事件当前正在通过的节点（<code>Event.currentTarget</code>）。前者通常是后者的后代节点。</p>
<p><code>Event.currentTarget</code>属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。</p>
<p><code>Event.target</code>属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>
<p>事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">function hide(e) &#123;</span><br><span class="line">  &#x2F;&#x2F; 不管点击 Hello 或 World，总是返回 true</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.currentTarget);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 点击 Hello，返回 true</span><br><span class="line">  &#x2F;&#x2F; 点击 World，返回 false</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;para&#39;).addEventListener(&#39;click&#39;, hide, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>是</code>的子节点，点击<code>或者点击</code>，都会导致监听函数执行。这时，<code>e.target</code>总是指向原始点击位置的那个节点，而<code>e.currentTarget</code>指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以<code>e.currentTarget</code>总是等同于监听函数内部的<code>this</code>。</p>
<h4 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h4><p><code>Event.type</code>属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.type &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Event-timeStamp"><a href="#Event-timeStamp" class="headerlink" title="Event.timeStamp"></a>Event.timeStamp</h4><p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.timeStamp &#x2F;&#x2F; 3683.6999999995896</span><br></pre></td></tr></table></figure>

<p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>
<p>下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> previousX;</span><br><span class="line"><span class="keyword">var</span> previousY;</span><br><span class="line"><span class="keyword">var</span> previousT;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    previousX !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousY !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousT !== <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">var</span> deltaX = event.screenX - previousX;</span><br><span class="line">    <span class="keyword">var</span> deltaY = event.screenY - previousY;</span><br><span class="line">    <span class="keyword">var</span> deltaD = <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(deltaX, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(deltaY, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deltaT = event.timeStamp - previousT;</span><br><span class="line">    <span class="built_in">console</span>.log(deltaD / deltaT * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousX = event.screenX;</span><br><span class="line">  previousY = event.screenY;</span><br><span class="line">  previousT = event.timeStamp;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Event-isTrusted"><a href="#Event-isTrusted" class="headerlink" title="Event.isTrusted"></a>Event.isTrusted</h4><p><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.isTrusted &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p>
<h4 id="Event-detail"><a href="#Event-detail" class="headerlink" title="Event.detail"></a>Event.detail</h4><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dblclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">function giveDetails(e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;p&#39;).onclick &#x3D; giveDetails;</span><br></pre></td></tr></table></figure>

<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h4><p><code>Event.preventDefault</code>方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p>
<p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;my-checkbox&quot; &#x2F;&gt;</span><br><span class="line">var cb &#x3D; document.getElementById(&#39;my-checkbox&#39;);</span><br><span class="line"></span><br><span class="line">cb.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e)&#123; e.preventDefault(); &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>
<p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;my-input&quot; &#x2F;&gt;</span><br><span class="line">var input &#x3D; document.getElementById(&#39;my-input&#39;);</span><br><span class="line">input.addEventListener(&#39;keypress&#39;, checkName, false);</span><br><span class="line"></span><br><span class="line">function checkName(e) &#123;</span><br><span class="line">  if (e.charCode &lt; 97 || e.charCode &gt; 122) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>
<h4 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h4><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function stopEvent(e) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, stopEvent, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p>
<h4 id="Event-stopImmediatePropagation"><a href="#Event-stopImmediatePropagation" class="headerlink" title="Event.stopImmediatePropagation()"></a>Event.stopImmediatePropagation()</h4><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p>
<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function l1(e)&#123;</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function l2(e)&#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, l1, false);</span><br><span class="line">el.addEventListener(&#39;click&#39;, l2, false);</span><br></pre></td></tr></table></figure>

<p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p>
<h4 id="Event-composedPath"><a href="#Event-composedPath" class="headerlink" title="Event.composedPath()"></a>Event.composedPath()</h4><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.composedPath());</span><br><span class="line">&#125;, false);</span><br><span class="line">&#x2F;&#x2F; [p, div, body, html, document, Window]</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><h3 id="鼠标事件的种类"><a href="#鼠标事件的种类" class="headerlink" title="鼠标事件的种类"></a>鼠标事件的种类</h3><p>鼠标事件指与鼠标相关的事件，继承了<code>MouseEvent</code>接口。具体的事件主要有以下一些。</p>
<ul>
<li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。</li>
<li><code>dblclick</code>：在同一个元素上双击鼠标时触发。</li>
<li><code>mousedown</code>：按下鼠标键时触发。</li>
<li><code>mouseup</code>：释放按下的鼠标键时触发。</li>
<li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li>
<li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</li>
<li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</li>
<li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</li>
<li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</li>
<li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。</li>
<li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li>
</ul>
<p><code>click</code>事件指的是，用户在同一个位置先完成<code>mousedown</code>动作，再完成<code>mouseup</code>动作。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p>
<p><code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p>
<p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">   &lt;li&gt;item 1&lt;&#x2F;li&gt;</span><br><span class="line">   &lt;li&gt;item 2&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">var ul &#x3D; document.querySelector(&#39;ul&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进入 ul 节点以后，mouseenter 事件只会触发一次</span><br><span class="line">&#x2F;&#x2F; 以后只要鼠标在节点内移动，都不会再触发这个事件</span><br><span class="line">&#x2F;&#x2F; event.target 是 ul 节点</span><br><span class="line">ul.addEventListener(&#39;mouseenter&#39;, function (event) &#123;</span><br><span class="line">  event.target.style.color &#x3D; &#39;purple&#39;;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    event.target.style.color &#x3D; &#39;&#39;;</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次</span><br><span class="line">&#x2F;&#x2F; event.target 是 li 节点</span><br><span class="line">ul.addEventListener(&#39;mouseover&#39;, function (event) &#123;</span><br><span class="line">  event.target.style.color &#x3D; &#39;orange&#39;;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    event.target.style.color &#x3D; &#39;&#39;;</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p>
<p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而<code>mouseout</code>事件会触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">   &lt;li&gt;item 1&lt;&#x2F;li&gt;</span><br><span class="line">   &lt;li&gt;item 2&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">var ul &#x3D; document.querySelector(&#39;ul&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件</span><br><span class="line">&#x2F;&#x2F; 只有离开 ul 节点时，触发一次 mouseleave</span><br><span class="line">&#x2F;&#x2F; event.target 是 ul 节点</span><br><span class="line">ul.addEventListener(&#39;mouseleave&#39;, function (event) &#123;</span><br><span class="line">  event.target.style.color &#x3D; &#39;purple&#39;;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    event.target.style.color &#x3D; &#39;&#39;;</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次</span><br><span class="line">&#x2F;&#x2F; event.target 是 li 节点</span><br><span class="line">ul.addEventListener(&#39;mouseout&#39;, function (event) &#123;</span><br><span class="line">  event.target.style.color &#x3D; &#39;orange&#39;;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    event.target.style.color &#x3D; &#39;&#39;;</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p>
<h3 id="MouseEvent接口概述"><a href="#MouseEvent接口概述" class="headerlink" title="MouseEvent接口概述"></a>MouseEvent接口概述</h3><p><code>MouseEvent</code>接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是<code>MouseEvent</code>实例。此外，滚轮事件和拖拉事件也是<code>MouseEvent</code>实例。</p>
<p><code>MouseEvent</code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法。它还有自己的属性和方法。</p>
<p>浏览器原生提供一个<code>MouseEvent</code>构造函数，用于新建一个<code>MouseEvent</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var event &#x3D; new MouseEvent(type, options);</span><br></pre></td></tr></table></figure>

<p><code>MouseEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p>
<ul>
<li><code>screenX</code>：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>screenY</code>：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与<code>screenX</code>相同。</li>
<li><code>clientX</code>：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>clientY</code>：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与<code>clientX</code>相同。</li>
<li><code>ctrlKey</code>：布尔值，是否同时按下了 Ctrl 键，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否同时按下了 Shift 键，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否同时按下 Alt 键，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否同时按下 Meta 键，默认值为<code>false</code>。</li>
<li><code>button</code>：数值，表示按下了哪一个鼠标按键，默认值为<code>0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code>1</code>表示按下辅助键（通常是鼠标的中间键），<code>2</code>表示按下次要键（通常是鼠标的右键）。</li>
<li><code>buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为<code>0</code>（没有按下任何键）。<code>1</code>（二进制<code>001</code>）表示按下主键（通常是左键），<code>2</code>（二进制<code>010</code>）表示按下次要键（通常是右键），<code>4</code>（二进制<code>100</code>）表示按下辅助键（通常是中间键）。因此，如果返回<code>3</code>（二进制<code>011</code>）就表示同时按下了左键和右键。</li>
<li><code>relatedTarget</code>：节点对象，表示事件的相关节点，默认为<code>null</code>。<code>mouseenter</code>和<code>mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code>mouseout</code>和<code>mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function simulateClick() &#123;</span><br><span class="line">  var event &#x3D; new MouseEvent(&#39;click&#39;, &#123;</span><br><span class="line">    &#39;bubbles&#39;: true,</span><br><span class="line">    &#39;cancelable&#39;: true</span><br><span class="line">  &#125;);</span><br><span class="line">  var cb &#x3D; document.getElementById(&#39;checkbox&#39;);</span><br><span class="line">  cb.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码生成一个鼠标点击事件，并触发该事件。</p>
<h3 id="MouseEvent接口的实例属性"><a href="#MouseEvent接口的实例属性" class="headerlink" title="MouseEvent接口的实例属性"></a>MouseEvent接口的实例属性</h3><h4 id="MouseEvent-altKey-MouseEvent-ctrlKey-MouseEvent-metaKey-MouseEvent-shiftKey"><a href="#MouseEvent-altKey-MouseEvent-ctrlKey-MouseEvent-metaKey-MouseEvent-shiftKey" class="headerlink" title="MouseEvent.altKey,MouseEvent.ctrlKey,MouseEvent.metaKey,MouseEvent.shiftKey"></a>MouseEvent.altKey,MouseEvent.ctrlKey,MouseEvent.metaKey,MouseEvent.shiftKey</h4><p><code>MouseEvent.altKey</code>、<code>MouseEvent.ctrlKey</code>、<code>MouseEvent.metaKey</code>、<code>MouseEvent.shiftKey</code>这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</p>
<ul>
<li><code>altKey</code>属性：Alt 键</li>
<li><code>ctrlKey</code>属性：Ctrl 键</li>
<li><code>metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li>
<li><code>shiftKey</code>属性：Shift 键</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;body onclick&#x3D;&quot;showKey(event)&quot;&gt;</span><br><span class="line">function showKey(e) &#123;</span><br><span class="line">  console.log(&#39;ALT key pressed: &#39; + e.altKey);</span><br><span class="line">  console.log(&#39;CTRL key pressed: &#39; + e.ctrlKey);</span><br><span class="line">  console.log(&#39;META key pressed: &#39; + e.metaKey);</span><br><span class="line">  console.log(&#39;SHIFT key pressed: &#39; + e.shiftKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击网页会输出是否同时按下对应的键。</p>
<h4 id="MouseEvent-button-MouseEvent-buttons"><a href="#MouseEvent-button-MouseEvent-buttons" class="headerlink" title="MouseEvent.button,MouseEvent.buttons"></a>MouseEvent.button,MouseEvent.buttons</h4><p><code>MouseEvent.button</code>属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。</p>
<ul>
<li>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code>mousemove</code>事件）。</li>
<li>1：按下辅助键（通常是中键或者滚轮键）。</li>
<li>2：按下次键（通常是右键）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;button onmouseup&#x3D;&quot;whichButton(event)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">var whichButton &#x3D; function (e) &#123;</span><br><span class="line">  switch (e.button) &#123;</span><br><span class="line">    case 0:</span><br><span class="line">      console.log(&#39;Left button clicked.&#39;);</span><br><span class="line">      break;</span><br><span class="line">    case 1:</span><br><span class="line">      console.log(&#39;Middle button clicked.&#39;);</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      console.log(&#39;Right button clicked.&#39;);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      console.log(&#39;Unexpected code: &#39; + e.button);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MouseEvent.buttons</code>属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。</p>
<ul>
<li>1：二进制为<code>001</code>（十进制的1），表示按下左键。</li>
<li>2：二进制为<code>010</code>（十进制的2），表示按下右键。</li>
<li>4：二进制为<code>100</code>（十进制的4），表示按下中键或滚轮键。</li>
</ul>
<p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。</p>
<h4 id="MouseEvent-clientX-MouseEvent-clientY"><a href="#MouseEvent-clientX-MouseEvent-clientY" class="headerlink" title="MouseEvent.clientX,MouseEvent.clientY"></a>MouseEvent.clientX,MouseEvent.clientY</h4><p><code>MouseEvent.clientX</code>属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），<code>MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是只读属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;body onmousedown&#x3D;&quot;showCoords(event)&quot;&gt;</span><br><span class="line">function showCoords(evt)&#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#39;clientX value: &#39; + evt.clientX + &#39;\n&#39; +</span><br><span class="line">    &#39;clientY value: &#39; + evt.clientY + &#39;\n&#39;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个属性还分别有一个别名<code>MouseEvent.x</code>和<code>MouseEvent.y</code>。</p>
<h4 id="MouseEvent-movementX-MouseEvent-movementY"><a href="#MouseEvent-movementX-MouseEvent-movementY" class="headerlink" title="MouseEvent.movementX,MouseEvent.movementY"></a>MouseEvent.movementX,MouseEvent.movementY</h4><p><code>MouseEvent.movementX</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.movementX &#x3D; currentEvent.screenX - previousEvent.screenX</span><br></pre></td></tr></table></figure>

<p><code>MouseEvent.movementY</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.movementY &#x3D; currentEvent.screenY - previousEvent.screenY。</span><br></pre></td></tr></table></figure>

<p>这两个属性都是只读属性。</p>
<h4 id="MouseEvent-screenX-MouseEvent-screenY"><a href="#MouseEvent-screenX-MouseEvent-screenY" class="headerlink" title="MouseEvent.screenX,MouseEvent.screenY"></a>MouseEvent.screenX,MouseEvent.screenY</h4><p><code>MouseEvent.screenX</code>属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），<code>MouseEvent.screenY</code>属性返回垂直坐标。这两个属性都是只读属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;body onmousedown&#x3D;&quot;showCoords(event)&quot;&gt;</span><br><span class="line">function showCoords(evt) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#39;screenX value: &#39; + evt.screenX + &#39;\n&#39;,</span><br><span class="line">    &#39;screenY value: &#39; + evt.screenY + &#39;\n&#39;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MouseEvent-offsetX-MouseEvent-offsetY"><a href="#MouseEvent-offsetX-MouseEvent-offsetY" class="headerlink" title="MouseEvent.offsetX,MouseEvent.offsetY"></a>MouseEvent.offsetX,MouseEvent.offsetY</h4><p><code>MouseEvent.offsetX</code>属性返回鼠标位置与目标节点左侧的<code>padding</code>边缘的水平距离（单位像素），<code>MouseEvent.offsetY</code>属性返回与目标节点上方的<code>padding</code>边缘的垂直距离。这两个属性都是只读属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    p &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      padding: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line">p.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e) &#123;</span><br><span class="line">    console.log(e.offsetX);</span><br><span class="line">    console.log(e.offsetY);</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，鼠标如果在<code>p</code>元素的中心位置点击，会返回<code>150 150</code>。因此中心位置距离左侧和上方的<code>padding</code>边缘，等于<code>padding</code>的宽度（100像素）加上元素内容区域一半的宽度（50像素）。</p>
<h4 id="MouseEvent-pageX-MouseEvent-pageY"><a href="#MouseEvent-pageX-MouseEvent-pageY" class="headerlink" title="MouseEvent.pageX,MouseEvent.pageY"></a>MouseEvent.pageX,MouseEvent.pageY</h4><p><code>MouseEvent.pageX</code>属性返回鼠标位置与文档左侧边缘的距离（单位像素），<code>MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">      height: 2000px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line">document.body.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e) &#123;</span><br><span class="line">    console.log(e.pageX);</span><br><span class="line">    console.log(e.pageY);</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，页面高度为2000像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的<code>pageY</code>值会接近2000。</p>
<h4 id="MouseEvent-relatedTarget"><a href="#MouseEvent-relatedTarget" class="headerlink" title="MouseEvent.relatedTarget"></a>MouseEvent.relatedTarget</h4><p><code>MouseEvent.relatedTarget</code>属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回<code>null</code>。该属性只读。</p>
<p>下表列出不同事件的<code>target</code>属性值和<code>relatedTarget</code>属性值义。</p>
<table>
<thead>
<tr>
<th align="left">事件名称</th>
<th align="left">target 属性</th>
<th align="left">relatedTarget 属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">focusin</td>
<td align="left">接受焦点的节点</td>
<td align="left">丧失焦点的节点</td>
</tr>
<tr>
<td align="left">focusout</td>
<td align="left">丧失焦点的节点</td>
<td align="left">接受焦点的节点</td>
</tr>
<tr>
<td align="left">mouseenter</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">mouseleave</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
<tr>
<td align="left">mouseout</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
<tr>
<td align="left">mouseover</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">dragenter</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">dragexit</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
</tbody></table>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  HTML 代码如下</span><br><span class="line">  &lt;div id&#x3D;&quot;outer&quot; style&#x3D;&quot;height:50px;width:50px;border-width:1px solid black;&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;inner&quot; style&#x3D;&quot;height:25px;width:25px;border:1px solid black;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">var inner &#x3D; document.getElementById(&#39;inner&#39;);</span><br><span class="line">inner.addEventListener(&#39;mouseover&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;进入&#39; + event.target.id + &#39; 离开&#39; + event.relatedTarget.id);</span><br><span class="line">&#125;, false);</span><br><span class="line">inner.addEventListener(&#39;mouseenter&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;进入&#39; + event.target.id + &#39; 离开&#39; + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(&#39;mouseout&#39;, function () &#123;</span><br><span class="line">  console.log(&#39;离开&#39; + event.target.id + &#39; 进入&#39; + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(&quot;mouseleave&quot;, function ()&#123;</span><br><span class="line">  console.log(&#39;离开&#39; + event.target.id + &#39; 进入&#39; + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 鼠标从 outer 进入inner，输出</span><br><span class="line">&#x2F;&#x2F; 进入inner 离开outer</span><br><span class="line">&#x2F;&#x2F; 进入inner 离开outer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 鼠标从 inner进入 outer，输出</span><br><span class="line">&#x2F;&#x2F; 离开inner 进入outer</span><br><span class="line">&#x2F;&#x2F; 离开inner 进入outer</span><br></pre></td></tr></table></figure>

<h3 id="MouseEvent接口的实例方法"><a href="#MouseEvent接口的实例方法" class="headerlink" title="MouseEvent接口的实例方法"></a>MouseEvent接口的实例方法</h3><h4 id="MouseEvent-getModifierState"><a href="#MouseEvent-getModifierState" class="headerlink" title="MouseEvent.getModifierState()"></a>MouseEvent.getModifierState()</h4><p><code>MouseEvent.getModifierState</code>方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#Modifier_keys_on_Gecko" target="_blank" rel="noopener">功能键</a>的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.getModifierState(&#39;CapsLock&#39;));</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面的代码可以了解用户是否按下了大写键。</p>
<h3 id="WheelEvent接口"><a href="#WheelEvent接口" class="headerlink" title="WheelEvent接口"></a>WheelEvent接口</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个<code>wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p>
<p>浏览器原生提供<code>WheelEvent()</code>构造函数，用来生成<code>WheelEvent</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var wheelEvent &#x3D; new WheelEvent(type, options);</span><br></pre></td></tr></table></figure>

<p><code>WheelEvent()</code>构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是<code>wheel</code>。第二个参数是事件的配置对象。该对象的属性除了<code>Event</code>、<code>UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p>
<ul>
<li><code>deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li>
<li><code>deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li>
<li><code>deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li>
<li><code>deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code>0</code>表示滚动单位为像素，<code>1</code>表示单位为行，<code>2</code>表示单位为页，默认为<code>0</code>。</li>
</ul>
<h4 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h4><p><code>WheelEvent</code>事件实例除了具有<code>Event</code>和<code>MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p>
<p>下面的属性都是只读属性。</p>
<ul>
<li><code>WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li>
<li><code>WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li>
<li><code>WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</li>
<li><code>WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code>0</code>是像素，<code>1</code>是行，<code>2</code>是页。</li>
</ul>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><h3 id="键盘事件的种类"><a href="#键盘事件的种类" class="headerlink" title="键盘事件的种类"></a>键盘事件的种类</h3><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p>
<ul>
<li><code>keydown</code>：按下键盘时触发。</li>
<li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。</li>
<li><code>keyup</code>：松开键盘时触发该事件。</li>
</ul>
<p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p>
<ol>
<li>keydown</li>
<li>keypress</li>
<li>keydown</li>
<li>keypress</li>
<li>…（重复以上过程）</li>
<li>keyup</li>
</ol>
<h3 id="KeyboardEvent接口概述"><a href="#KeyboardEvent接口概述" class="headerlink" title="KeyboardEvent接口概述"></a>KeyboardEvent接口概述</h3><p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口继承了<code>Event</code>接口，并且定义了自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new KeyboardEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p>
<ul>
<li><code>key</code>：字符串，当前按下的键，默认为空字符串。</li>
<li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li>
<li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li>
<li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li>
<li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li>
</ul>
<h3 id="KeyboardEvent的实例属性"><a href="#KeyboardEvent的实例属性" class="headerlink" title="KeyboardEvent的实例属性"></a>KeyboardEvent的实例属性</h3><h4 id="KeyboardEvent-altKey-KeyboardEvent-ctrlKey-KeyboardEvent-metaKey-KeyboardEvent-shiftKey"><a href="#KeyboardEvent-altKey-KeyboardEvent-ctrlKey-KeyboardEvent-metaKey-KeyboardEvent-shiftKey" class="headerlink" title="KeyboardEvent.altKey,KeyboardEvent.ctrlKey,KeyboardEvent.metaKey,KeyboardEvent.shiftKey"></a>KeyboardEvent.altKey,KeyboardEvent.ctrlKey,KeyboardEvent.metaKey,KeyboardEvent.shiftKey</h4><p>以下属性都是只读属性，返回一个布尔值，表示是否按下对应的键。</p>
<ul>
<li><code>KeyboardEvent.altKey</code>：是否按下 Alt 键</li>
<li><code>KeyboardEvent.ctrlKey</code>：是否按下 Ctrl 键</li>
<li><code>KeyboardEvent.metaKey</code>：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</li>
<li><code>KeyboardEvent.shiftKey</code>：是否按下 Shift 键</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function showChar(e) &#123;</span><br><span class="line">  console.log(&#39;ALT: &#39; + e.altKey);</span><br><span class="line">  console.log(&#39;CTRL: &#39; + e.ctrlKey);</span><br><span class="line">  console.log(&#39;Meta: &#39; + e.metaKey);</span><br><span class="line">  console.log(&#39;Shift: &#39; + e.shiftKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&#39;keydown&#39;, showChar, false);</span><br></pre></td></tr></table></figure>

<h4 id="KeyboardEvent-code"><a href="#KeyboardEvent-code" class="headerlink" title="KeyboardEvent.code"></a>KeyboardEvent.code</h4><p><code>KeyboardEvent.code</code>属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。</p>
<p>下面是一些常用键的字符串形式，其他键请查<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code#Code_values" target="_blank" rel="noopener">文档</a>。</p>
<ul>
<li>数字键0 - 9：返回<code>digital0</code> - <code>digital9</code></li>
<li>字母键A - z：返回<code>KeyA</code> - <code>KeyZ</code></li>
<li>功能键F1 - F12：返回 <code>F1</code> - <code>F12</code></li>
<li>方向键：返回<code>ArrowDown</code>、<code>ArrowUp</code>、<code>ArrowLeft</code>、<code>ArrowRight</code></li>
<li>Alt 键：返回<code>AltLeft</code>或<code>AltRight</code></li>
<li>Shift 键：返回<code>ShiftLeft</code>或<code>ShiftRight</code></li>
<li>Ctrl 键：返回<code>ControlLeft</code>或<code>ControlRight</code></li>
</ul>
<h4 id="KeyboardEvent-key"><a href="#KeyboardEvent-key" class="headerlink" title="KeyboardEvent.key"></a>KeyboardEvent.key</h4><p><code>KeyboardEvent.key</code>属性返回一个字符串，表示按下的键名。该属性只读。</p>
<p>如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。</p>
<p>如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1～F12，NumLock，Scroll 等。</p>
<p>如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回<code>a</code>；按下 Shift + a，则返回大写的<code>A</code>。</p>
<p>如果无法识别键名，返回字符串<code>Unidentified</code>。</p>
<h4 id="KeyboardEvent-location"><a href="#KeyboardEvent-location" class="headerlink" title="KeyboardEvent.location"></a>KeyboardEvent.location</h4><p><code>KeyboardEvent.location</code>属性返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值。</p>
<ul>
<li>0：处在键盘的主区域，或者无法判断处于哪一个区域。</li>
<li>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li>
<li>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li>
<li>3：处在数字小键盘。</li>
</ul>
<h4 id="KeyboardEvent-repeat"><a href="#KeyboardEvent-repeat" class="headerlink" title="KeyboardEvent.repeat"></a>KeyboardEvent.repeat</h4><p><code>KeyboardEvent.repeat</code>返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发<code>keydown</code>和<code>keypress</code>事件，直到用户松开手为止。</p>
<h3 id="KeyboardEvent的实例方法"><a href="#KeyboardEvent的实例方法" class="headerlink" title="KeyboardEvent的实例方法"></a>KeyboardEvent的实例方法</h3><h4 id="KeyboardEvent-getModifierState"><a href="#KeyboardEvent-getModifierState" class="headerlink" title="KeyboardEvent.getModifierState()"></a>KeyboardEvent.getModifierState()</h4><p><code>KeyboardEvent.getModifierState()</code>方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。</p>
<ul>
<li><code>Alt</code>：Alt 键</li>
<li><code>CapsLock</code>：大写锁定键</li>
<li><code>Control</code>：Ctrl 键</li>
<li><code>Meta</code>：Meta 键</li>
<li><code>NumLock</code>：数字键盘开关键</li>
<li><code>Shift</code>：Shift 键</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (</span><br><span class="line">  event.getModifierState(&#39;Control&#39;) +</span><br><span class="line">  event.getModifierState(&#39;Alt&#39;) +</span><br><span class="line">  event.getModifierState(&#39;Meta&#39;) &gt; 1</span><br><span class="line">) &#123;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，只要<code>Control</code>、<code>Alt</code>、<code>Meta</code>里面，同时按下任意两个或两个以上的键就返回。</p>
<h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><h3 id="进度事件的种类"><a href="#进度事件的种类" class="headerlink" title="进度事件的种类"></a>进度事件的种类</h3><p>进度事件用来描述资源加载的进度，主要由 AJAX 请求、<code>、</code>、<code>、</code>、``等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种事件。</p>
<ul>
<li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</li>
<li><code>error</code>：由于错误导致外部资源无法加载时触发。</li>
<li><code>load</code>：外部资源加载成功时触发。</li>
<li><code>loadstart</code>：外部资源开始加载时触发。</li>
<li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。</li>
<li><code>progress</code>：外部资源加载过程中不断触发。</li>
<li><code>timeout</code>：加载超时时触发。</li>
</ul>
<p>注意，除了资源下载，文件上传也存在这些事件。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.addEventListener(&#39;load&#39;, function (event) &#123;</span><br><span class="line">  image.classList.add(&#39;finished&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">image.addEventListener(&#39;error&#39;, function (event) &#123;</span><br><span class="line">  image.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码在图片元素加载完成后，为图片元素添加一个<code>finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p>
<p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code>load</code>和<code>error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code>complete</code>属性先判断一下是否加载完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function loaded() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (image.complete) &#123;</span><br><span class="line">  loaded();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  image.addEventListener(&#39;load&#39;, loaded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code>error</code>事件的监听函数最好放在``元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;wrong&#x2F;url&quot; onerror&#x3D;&quot;this.style.display&#x3D;&#39;none&#39;;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件的监听函数，可以用来取代<code>abort</code>事件、<code>load</code>事件、<code>error</code>事件的监听函数，因为它总是在这些事件之后发生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.addEventListener(&#39;loadend&#39;, loadEnd, false);</span><br><span class="line"></span><br><span class="line">function loadEnd(e) &#123;</span><br><span class="line">  console.log(&#39;传输结束，成功失败未知&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p>
<p>另外，<code>error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code>error</code>事件，不会触发父元素的<code>error</code>事件监听函数。</p>
<h3 id="ProgressEvent接口"><a href="#ProgressEvent接口" class="headerlink" title="ProgressEvent接口"></a>ProgressEvent接口</h3><p><code>ProgressEvent</code>接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<code>、</code>、<code>、</code>等外部资源加载。进度相关的事件都继承了这个接口。</p>
<p>浏览器原生提供了<code>ProgressEvent()</code>构造函数，用来生成事件实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ProgressEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code>Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p>
<ul>
<li><code>lengthComputable</code>：布尔值，表示加载的总量是否可以计算，默认是<code>false</code>。</li>
<li><code>loaded</code>：整数，表示已经加载的量，默认是<code>0</code>。</li>
<li><code>total</code>：整数，表示需要加载的总量，默认是<code>0</code>。</li>
</ul>
<p><code>ProgressEvent</code>具有对应的实例属性。</p>
<ul>
<li><code>ProgressEvent.lengthComputable</code></li>
<li><code>ProgressEvent.loaded</code></li>
<li><code>ProgressEvent.total</code></li>
</ul>
<p>如果<code>ProgressEvent.lengthComputable</code>为<code>false</code>，<code>ProgressEvent.total</code>实际上是没有意义的。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; new ProgressEvent(&#39;load&#39;, &#123;</span><br><span class="line">  lengthComputable: true,</span><br><span class="line">  loaded: 30,</span><br><span class="line">  total: 100,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&#39;load&#39;, function (e) &#123;</span><br><span class="line">  console.log(&#39;已经加载：&#39; + (e.loaded &#x2F; e.total) * 100 + &#39;%&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.body.dispatchEvent(p);</span><br><span class="line">&#x2F;&#x2F; 已经加载：30%</span><br></pre></td></tr></table></figure>

<p>上面代码先构造一个<code>load</code>事件，抛出后被监听函数捕捉到。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(&#39;progress&#39;, updateProgress, false);</span><br><span class="line">xhr.addEventListener(&#39;load&#39;, transferComplete, false);</span><br><span class="line">xhr.addEventListener(&#39;error&#39;, transferFailed, false);</span><br><span class="line">xhr.addEventListener(&#39;abort&#39;, transferCanceled, false);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br><span class="line"></span><br><span class="line">function updateProgress(e) &#123;</span><br><span class="line">  if (e.lengthComputable) &#123;</span><br><span class="line">    var percentComplete &#x3D; e.loaded &#x2F; e.total;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;不能计算进度&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferComplete(e) &#123;</span><br><span class="line">  console.log(&#39;传输结束&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferFailed(evt) &#123;</span><br><span class="line">  console.log(&#39;传输过程中发生错误&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferCanceled(evt) &#123;</span><br><span class="line">  console.log(&#39;用户取消了传输&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是下载过程的进度事件，还存在上传过程的进度事件。这时所有监听函数都要放在<code>XMLHttpRequest.upload</code>对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.upload.addEventListener(&#39;progress&#39;, updateProgress, false);</span><br><span class="line">xhr.upload.addEventListener(&#39;load&#39;, transferComplete, false);</span><br><span class="line">xhr.upload.addEventListener(&#39;error&#39;, transferFailed, false);</span><br><span class="line">xhr.upload.addEventListener(&#39;abort&#39;, transferCanceled, false);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure>

<h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><h3 id="表单事件的种类"><a href="#表单事件的种类" class="headerlink" title="表单事件的种类"></a>表单事件的种类</h3><h4 id="input事件"><a href="#input事件" class="headerlink" title="input事件"></a>input事件</h4><p><code>input</code>事件当<code>、</code>、<code>的值发生变化时触发。对于复选框（</code>）或单选框（``），用户改变选项时，也会触发这个事件。另外，对于打开<code>contenteditable</code>属性的元素，只要值发生变化，也会触发<code>input</code>事件。</p>
<p><code>input</code>事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次<code>input</code>事件。</p>
<p><code>input</code>事件对象继承了<code>InputEvent</code>接口。</p>
<p>该事件跟<code>change</code>事件很像，不同之处在于<code>input</code>事件在元素的值发生变化后立即发生，而<code>change</code>在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，<code>input</code>事件会触发多次，而<code>change</code>事件只在失去焦点时触发一次。</p>
<p>下面是``元素的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line">&lt;select id&#x3D;&quot;mySelect&quot;&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;option&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;2&quot;&gt;2&lt;&#x2F;option&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;3&quot;&gt;3&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">function inputHandler(e) &#123;</span><br><span class="line">  console.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mySelect &#x3D; document.querySelector(&#39;#mySelect&#39;);</span><br><span class="line">mySelect.addEventListener(&#39;input&#39;, inputHandler);</span><br></pre></td></tr></table></figure>

<p>上面代码中，改变下拉框选项时，会触发<code>input</code>事件，从而执行回调函数<code>inputHandler</code>。</p>
<h4 id="select事件"><a href="#select事件" class="headerlink" title="select事件"></a>select事件</h4><p><code>select</code>事件当在<code>、</code>里面选中文本时触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input id&#x3D;&quot;test&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;Select me!&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">var elem &#x3D; document.getElementById(&#39;test&#39;);</span><br><span class="line">elem.addEventListener(&#39;select&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.type); &#x2F;&#x2F; &quot;select&quot;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>选中的文本可以通过<code>event.target</code>元素的<code>selectionDirection</code>、<code>selectionEnd</code>、<code>selectionStart</code>和<code>value</code>属性拿到。</p>
<h4 id="change事件"><a href="#change事件" class="headerlink" title="change事件"></a>change事件</h4><p><code>change</code>事件当<code>、</code>、``的值发生变化时触发。它与<code>input</code>事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p>
<ul>
<li>激活单选框（radio）或复选框（checkbox）时触发。</li>
<li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li>
<li>当文本框或``元素的值发生改变，并且丧失焦点时触发。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;select size&#x3D;&quot;1&quot; onchange&#x3D;&quot;changeEventHandler(event);&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;option&gt;chocolate&lt;&#x2F;option&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;option&gt;strawberry&lt;&#x2F;option&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;option&gt;vanilla&lt;&#x2F;option&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">function changeEventHandler(event) &#123;</span><br><span class="line">  console.log(event.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果比较一下上面<code>input</code>事件的例子，你会发现对于<code>select</code>元素来说，<code>input</code>和<code>change</code>事件基本是等价的。</p>
<h4 id="invalid事件"><a href="#invalid事件" class="headerlink" title="invalid事件"></a>invalid事件</h4><p>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code>invalid</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; required oninvalid&#x3D;&quot;console.log(&#39;invalid input&#39;)&quot; &#x2F;&gt;</span><br><span class="line">  &lt;button type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code>invalid</code>事件，导致提交被取消。</p>
<h4 id="reset事件，submit事件"><a href="#reset事件，submit事件" class="headerlink" title="reset事件，submit事件"></a>reset事件，submit事件</h4><p>这两个事件发生在表单对象``上，而不是发生在表单的成员上。</p>
<p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发。</p>
<p><code>submit</code>事件当表单数据向服务器提交时触发。注意，<code>submit</code>事件的发生对象是<code>元素，而不是</code>元素，因为提交的是表单，而不是按钮。</p>
<h3 id="InputEvent接口"><a href="#InputEvent接口" class="headerlink" title="InputEvent接口"></a>InputEvent接口</h3><p><code>InputEvent</code>接口主要用来描述<code>input</code>事件的实例。该接口继承了<code>Event</code>接口，还定义了一些自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>InputEvent()</code>构造函数，用来生成实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new InputEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>InputEvent</code>构造函数可以接受两个参数。第一个参数是字符串，表示事件名称，该参数是必需的。第二个参数是一个配置对象，用来设置事件实例的属性，该参数是可选的。配置对象的字段除了<code>Event</code>构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。</p>
<ul>
<li><code>inputType</code>：字符串，表示发生变更的类型（详见下文）。</li>
<li><code>data</code>：字符串，表示插入的字符串。如果没有插入的字符串（比如删除操作），则返回<code>null</code>或空字符串。</li>
<li><code>dataTransfer</code>：返回一个 DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效。</li>
</ul>
<p><code>InputEvent</code>的实例属性主要就是上面三个属性，这三个实例属性都是只读的。</p>
<p><strong>（1）InputEvent.data</strong></p>
<p><code>InputEvent.data</code>属性返回一个字符串，表示变动的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;myInput&quot;&gt;</span><br><span class="line">var input &#x3D; document.getElementById(&#39;myInput&#39;);</span><br><span class="line">input.addEventListener(&#39;input&#39;, myFunction, false);</span><br><span class="line"></span><br><span class="line">function myFunction(e) &#123;</span><br><span class="line">  console.log(e.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果手动在输入框里面输入<code>abc</code>，控制台会先输出<code>a</code>，再在下一行输出<code>b</code>，再在下一行输出<code>c</code>。然后选中<code>abc</code>，一次性将它们删除，控制台会输出<code>null</code>或一个空字符串。</p>
<p><strong>（2）InputEvent.inputType</strong></p>
<p><code>InputEvent.inputType</code>属性返回一个字符串，表示字符串发生变更的类型。</p>
<p>对于常见情况，Chrome 浏览器的返回值如下。完整列表可以参考<a href="https://w3c.github.io/input-events/index.html#dom-inputevent-inputtype" target="_blank" rel="noopener">文档</a>。</p>
<ul>
<li>手动插入文本：<code>insertText</code></li>
<li>粘贴插入文本：<code>insertFromPaste</code></li>
<li>向后删除：<code>deleteContentBackward</code></li>
<li>向前删除：<code>deleteContentForward</code></li>
</ul>
<p><strong>（3）InputEvent.dataTransfer</strong></p>
<p><code>InputEvent.dataTransfer</code>属性返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（<code>insertFromDrop</code>）时才有效。</p>
<h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><h3 id="触摸操作概述"><a href="#触摸操作概述" class="headerlink" title="触摸操作概述"></a>触摸操作概述</h3><p>浏览器的触摸 API 由三个部分组成。</p>
<ul>
<li>Touch：一个触摸点</li>
<li>TouchList：多个触摸点的集合</li>
<li>TouchEvent：触摸引发的事件实例</li>
</ul>
<p><code>Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p>
<p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用<code>event.preventDefault</code>方法阻止发出鼠标事件。</p>
<h3 id="Touch接口"><a href="#Touch接口" class="headerlink" title="Touch接口"></a>Touch接口</h3><h4 id="Touch接口概述"><a href="#Touch接口概述" class="headerlink" title="Touch接口概述"></a>Touch接口概述</h4><p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。</p>
<p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var touch &#x3D; new Touch(touchOptions);</span><br></pre></td></tr></table></figure>

<p><code>Touch</code>构造函数接受一个配置对象作为参数，它有以下属性。</p>
<ul>
<li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li>
<li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li>
<li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li>
<li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li>
<li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li>
<li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li>
<li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li>
<li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li>
<li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li>
<li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li>
<li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li>
<li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li>
</ul>
<h4 id="Touch接口的实例属性"><a href="#Touch接口的实例属性" class="headerlink" title="Touch接口的实例属性"></a>Touch接口的实例属性</h4><p><strong>（1）Touch.identifier</strong></p>
<p><code>Touch.identifier</code>属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(&#39;touchmove&#39;, function (e) &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">    console.log(e.changedTouches[i].identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p><strong>（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY</strong></p>
<p><code>Touch.screenX</code>属性和<code>Touch.screenY</code>属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.clientX</code>属性和<code>Touch.clientY</code>属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.pageX</code>属性和<code>Touch.pageY</code>属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</p>
<p><strong>（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle</strong></p>
<p><code>Touch.radiusX</code>属性和<code>Touch.radiusY</code>属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。</p>
<p><code>Touch.rotationAngle</code>属性表示触摸区域的椭圆的旋转角度，单位为度数，在<code>0</code>到<code>90</code>度之间。</p>
<p>上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p>
<p>下面是一个示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;touchstart&#39;, rotate);</span><br><span class="line">div.addEventListener(&#39;touchmove&#39;, rotate);</span><br><span class="line">div.addEventListener(&#39;touchend&#39;, rotate);</span><br><span class="line"></span><br><span class="line">function rotate(e) &#123;</span><br><span class="line">  var touch &#x3D; e.changedTouches.item(0);</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  src.style.width &#x3D; touch.radiusX * 2 + &#39;px&#39;;</span><br><span class="line">  src.style.height &#x3D; touch.radiusY * 2 + &#39;px&#39;;</span><br><span class="line">  src.style.transform &#x3D; &#39;rotate(&#39; + touch.rotationAngle + &#39;deg)&#39;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（4）Touch.force</strong></p>
<p><code>Touch.force</code>属性返回一个<code>0</code>到<code>1</code>之间的数值，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力。</p>
<p><strong>（5）Touch.target</strong></p>
<p><code>Touch.target</code>属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p>
<h3 id="TouchList接口"><a href="#TouchList接口" class="headerlink" title="TouchList接口"></a>TouchList接口</h3><p><code>TouchList</code>接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是<code>Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code>TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code>Touch</code>实例对象。</p>
<p>它的实例主要通过触摸事件的<code>TouchEvent.touches</code>、<code>TouchEvent.changedTouches</code>、<code>TouchEvent.targetTouches</code>这几个属性获取。</p>
<p>它的实例属性和实例方法只有两个。</p>
<ul>
<li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li>
<li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li>
</ul>
<h3 id="TouchEvent接口"><a href="#TouchEvent接口" class="headerlink" title="TouchEvent接口"></a>TouchEvent接口</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>TouchEvent 接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p>
<p>浏览器原生提供<code>TouchEvent()</code>构造函数，用来生成触摸事件的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new TouchEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了<code>Event</code>接口的配置属性，该接口还有一些自己的配置属性。</p>
<ul>
<li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code>。</li>
</ul>
<h4 id="实例属性-2"><a href="#实例属性-2" class="headerlink" title="实例属性"></a>实例属性</h4><p>TouchEvent 接口的实例具有<code>Event</code>实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p>
<p><strong>（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey</strong></p>
<ul>
<li><code>TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li>
<li><code>TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li>
<li><code>TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li>
<li><code>TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(&#39;touchstart&#39;, function (e) &#123;</span><br><span class="line">  console.log(&#39;altKey &#x3D; &#39; + e.altKey);</span><br><span class="line">  console.log(&#39;ctrlKey &#x3D; &#39; + e.ctrlKey);</span><br><span class="line">  console.log(&#39;metaKey &#x3D; &#39; + e.metaKey);</span><br><span class="line">  console.log(&#39;shiftKey &#x3D; &#39; + e.shiftKey);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p><strong>（2）TouchEvent.changedTouches</strong></p>
<p><code>TouchEvent.changedTouches</code>属性返回一个<code>TouchList</code>实例，成员是一组<code>Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p>
<p>对于不同的时间，该属性的含义有所不同。</p>
<ul>
<li><code>touchstart</code>事件：被激活的触摸点</li>
<li><code>touchmove</code>事件：发生变化的触摸点</li>
<li><code>touchend</code>事件：消失的触摸点（即不再被触碰的点）</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(&#39;touchmove&#39;, function (e) &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">    console.log(e.changedTouches[i].identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p><strong>（3）TouchEvent.touches</strong></p>
<p><code>TouchEvent.touches</code>属性返回一个<code>TouchList</code>实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。</p>
<p>下面是一个示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(&#39;touchstart&#39;, function (e) &#123;</span><br><span class="line">  switch (e.touches.length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 一根手指触摸</span><br><span class="line">    case 1: handle_one_touch(e); break;</span><br><span class="line">    &#x2F;&#x2F; 两根手指触摸</span><br><span class="line">    case 2: handle_two_touches(e); break;</span><br><span class="line">    &#x2F;&#x2F; 三根手指触摸</span><br><span class="line">    case 3: handle_three_touches(e); break;</span><br><span class="line">    &#x2F;&#x2F; 其他情况</span><br><span class="line">    default: console.log(&#39;Not supported&#39;); break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p><strong>（4）TouchEvent.targetTouches</strong></p>
<p><code>TouchEvent.targetTouches</code>属性返回一个<code>TouchList</code>实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function touches_in_target(ev) &#123;</span><br><span class="line">  return (ev.touches.length &#x3D;&#x3D;&#x3D; ev.targetTouches.length ? true : false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用来判断，是否所有触摸点都在目标元素内。</p>
<h3 id="触摸事件的种类"><a href="#触摸事件的种类" class="headerlink" title="触摸事件的种类"></a>触摸事件的种类</h3><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p>
<ul>
<li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li>
<li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li>
<li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li>
<li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; document.getElementsByTagName(&#39;canvas&#39;)[0];</span><br><span class="line">el.addEventListener(&#39;touchstart&#39;, handleStart, false);</span><br><span class="line">el.addEventListener(&#39;touchmove&#39;, handleMove, false);</span><br><span class="line"></span><br><span class="line">function handleStart(evt) &#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  var touches &#x3D; evt.changedTouches;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; touches.length; i++) &#123;</span><br><span class="line">    console.log(touches[i].pageX, touches[i].pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleMove(evt) &#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  var touches &#x3D; evt.changedTouches;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; touches.length; i++) &#123;</span><br><span class="line">    var touch &#x3D; touches[i];</span><br><span class="line">    console.log(touch.pageX, touch.pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拖拉事件"><a href="#拖拉事件" class="headerlink" title="拖拉事件"></a>拖拉事件</h2><h3 id="拖拉事件的种类"><a href="#拖拉事件的种类" class="headerlink" title="拖拉事件的种类"></a>拖拉事件的种类</h3><p>拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p>
<p>拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div draggable&#x3D;&quot;true&quot;&gt;</span><br><span class="line">  此区域可拖拉</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p><code>draggable</code>属性可用于任何元素节点，但是图片（<code>）和链接（</code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p>
<p>注意，一旦某个元素节点的<code>draggable</code>属性设为<code>true</code>，就无法再用鼠标选中该节点内部的文字或子节点了。</p>
<p>当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</p>
<ul>
<li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li>
<li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
<li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li>
<li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li>
<li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li>
<li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li>
<li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li>
</ul>
<p>下面的例子展示，如何动态改变被拖动节点的背景色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;dragstart&#39;, function (e) &#123;</span><br><span class="line">  this.style.backgroundColor &#x3D; &#39;red&#39;;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;dragend&#39;, function (e) &#123;</span><br><span class="line">  this.style.backgroundColor &#x3D; &#39;green&#39;;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p>
<p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line"> &lt;div class&#x3D;&quot;dropzone&quot;&gt;</span><br><span class="line">   &lt;div id&#x3D;&quot;draggable&quot; draggable&#x3D;&quot;true&quot;&gt;</span><br><span class="line">     该节点可拖拉</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line"> &lt;div class&#x3D;&quot;dropzone&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;div class&#x3D;&quot;dropzone&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;div class&#x3D;&quot;dropzone&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 被拖拉节点</span><br><span class="line">var dragged;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;dragstart&#39;, function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 保存被拖拉节点</span><br><span class="line">  dragged &#x3D; event.target;</span><br><span class="line">  &#x2F;&#x2F; 被拖拉节点的背景色变透明</span><br><span class="line">  event.target.style.opacity &#x3D; 0.5;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;dragend&#39;, function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 被拖拉节点的背景色恢复正常</span><br><span class="line">  event.target.style.opacity &#x3D; &#39;&#39;;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;dragover&#39;, function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 防止拖拉效果被重置，允许被拖拉的节点放入目标节点</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;dragenter&#39;, function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 目标节点的背景色变紫色</span><br><span class="line">  &#x2F;&#x2F; 由于该事件会冒泡，所以要过滤节点</span><br><span class="line">  if (event.target.className &#x3D;&#x3D;&#x3D; &#39;dropzone&#39;) &#123;</span><br><span class="line">    event.target.style.background &#x3D; &#39;purple&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;dragleave&#39;, function( event ) &#123;</span><br><span class="line">  &#x2F;&#x2F; 目标节点的背景色恢复原样</span><br><span class="line">  if (event.target.className &#x3D;&#x3D;&#x3D; &#39;dropzone&#39;) &#123;</span><br><span class="line">    event.target.style.background &#x3D; &#39;&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;drop&#39;, function( event ) &#123;</span><br><span class="line">  &#x2F;&#x2F; 防止事件默认行为（比如某些元素节点上可以打开链接），</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  if (event.target.className &#x3D;&#x3D;&#x3D; &#39;dropzone&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 恢复目标节点背景色</span><br><span class="line">    event.target.style.background &#x3D; &#39;&#39;;</span><br><span class="line">    &#x2F;&#x2F; 将被拖拉节点插入目标节点</span><br><span class="line">    dragged.parentNode.removeChild(dragged);</span><br><span class="line">    event.target.appendChild( dragged );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>关于拖拉事件，有以下几个注意点。</p>
<ul>
<li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li>
<li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li>
<li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ondragover&#x3D;&quot;return false&quot;&gt;</span><br><span class="line">&lt;div ondragover&#x3D;&quot;event.preventDefault()&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在<code>div</code>节点上放下被拖拉的节点。</p>
<h3 id="DragEvent接口"><a href="#DragEvent接口" class="headerlink" title="DragEvent接口"></a>DragEvent接口</h3><p>拖拉事件都继承了<code>DragEvent</code>接口，这个接口又继承了<code>MouseEvent</code>接口和<code>Event</code>接口。</p>
<p>浏览器原生提供一个<code>DragEvent()</code>构造函数，用来生成拖拉事件的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new DragEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>DragEvent()</code>构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。配置对象除了接受<code>MouseEvent</code>接口和<code>Event</code>接口的配置属性，还可以设置<code>dataTransfer</code>属性要么是<code>null</code>，要么是一个<code>DataTransfer</code>接口的实例。</p>
<p><code>DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。</p>
<h3 id="DataTransfer接口概述"><a href="#DataTransfer接口概述" class="headerlink" title="DataTransfer接口概述"></a>DataTransfer接口概述</h3><p>所有拖拉事件的实例都有一个<code>DragEvent.dataTransfer</code>属性，用来读写需要传递的数据。这个属性的值是一个<code>DataTransfer</code>接口的实例。</p>
<p>浏览器原生提供一个<code>DataTransfer()</code>构造函数，用来生成<code>DataTransfer</code>实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dataTrans &#x3D; new DataTransfer();</span><br></pre></td></tr></table></figure>

<p><code>DataTransfer()</code>构造函数不接受参数。</p>
<p>拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如<code>text/plain</code>、<code>image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p>
<p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code>dragenter</code>和<code>dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code>text/uri-list</code>。</p>
<p>发生<code>drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</p>
<h3 id="DataTransfer的实例属性"><a href="#DataTransfer的实例属性" class="headerlink" title="DataTransfer的实例属性"></a>DataTransfer的实例属性</h3><h4 id="DataTransfer-dropEffect"><a href="#DataTransfer-dropEffect" class="headerlink" title="DataTransfer.dropEffect"></a>DataTransfer.dropEffect</h4><p><code>DataTransfer.dropEffect</code>属性用来设置放下（drop）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉的节点的链接</li>
<li>none：无法放下被拖拉的节点</li>
</ul>
<p>除了上面这些值，设置其他的值都是无效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(&#39;dragover&#39;, function (e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  e.dataTransfer.dropEffect &#x3D; &#39;copy&#39;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，被拖拉元素一旦<code>drop</code>，接受的区域会复制该节点。</p>
<p><code>dropEffect</code>属性一般在<code>dragenter</code>和<code>dragover</code>事件的监听函数中设置，对于<code>dragstart</code>、<code>drag</code>、<code>dragleave</code>这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p>
<h4 id="DataTransfer-effectAllowed"><a href="#DataTransfer-effectAllowed" class="headerlink" title="DataTransfer.effectAllowed"></a>DataTransfer.effectAllowed</h4><p><code>DataTransfer.effectAllowed</code>属性设置本次拖拉中允许的效果。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉节点的链接</li>
<li>copyLink：允许<code>copy</code>或<code>link</code></li>
<li>copyMove：允许<code>copy</code>或<code>move</code></li>
<li>linkMove：允许<code>link</code>或<code>move</code></li>
<li>all：允许所有效果</li>
<li>none：无法放下被拖拉的节点</li>
<li>uninitialized：默认值，等同于<code>all</code></li>
</ul>
<p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p>
<p>这个属性与<code>dropEffect</code>属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</p>
<p><code>dragstart</code>事件的监听函数，可以用来设置这个属性。其他事件的监听函数里面设置这个属性是无效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(&#39;dragstart&#39;, function (e) &#123;</span><br><span class="line">  e.dataTransfer.effectAllowed &#x3D; &#39;move&#39;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.addEventListener(&#39;dragover&#39;, function (e) &#123;</span><br><span class="line">  ev.dataTransfer.dropEffect &#x3D; &#39;move&#39;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只要<code>dropEffect</code>属性和<code>effectAllowed</code>属性之中，有一个为<code>none</code>，就无法在目标节点上完成<code>drop</code>操作。</p>
<h4 id="DataTransfer-files"><a href="#DataTransfer-files" class="headerlink" title="DataTransfer.files"></a>DataTransfer.files</h4><p><code>DataTransfer.files</code>属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</p>
<p>下面就是一个接收拖拉文件的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;output&quot; style&#x3D;&quot;min-height: 200px;border: 1px solid black;&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   文件拖拉到这里</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.getElementById(&#39;output&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&quot;dragenter&quot;, function( event ) &#123;</span><br><span class="line">  div.textContent &#x3D; &#39;&#39;;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&quot;dragover&quot;, function( event ) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&quot;drop&quot;, function( event ) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  var files &#x3D; event.dataTransfer.files;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    div.textContent +&#x3D; files[i].name + &#39; &#39; + files[i].size + &#39;字节\n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>dataTransfer.files</code>属性读取被拖拉的文件的信息。如果想要读取文件内容，就要使用<code>FileReader</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;drop&#39;, function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line"></span><br><span class="line">  var fileList &#x3D; e.dataTransfer.files;</span><br><span class="line">  if (fileList.length &gt; 0) &#123;</span><br><span class="line">    var file &#x3D; fileList[0];</span><br><span class="line">    var reader &#x3D; new FileReader();</span><br><span class="line">    reader.onloadend &#x3D; function(e) &#123;</span><br><span class="line">      if (e.target.readyState &#x3D;&#x3D;&#x3D; FileReader.DONE) &#123;</span><br><span class="line">        var content &#x3D; reader.result;</span><br><span class="line">        div.innerHTML &#x3D; &#39;File: &#39; + file.name + &#39;\n\n&#39; + content;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reader.readAsBinaryString(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="DataTransfer-types"><a href="#DataTransfer-types" class="headerlink" title="DataTransfer.types"></a>DataTransfer.types</h4><p><code>DataTransfer.types</code>属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是<code>text/plain</code>。</p>
<p>下面是一个例子，通过检查<code>dataTransfer</code>属性的类型，决定是否允许在当前节点执行<code>drop</code>操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function contains(list, value)&#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; list.length; ++i) &#123;</span><br><span class="line">    if(list[i] &#x3D;&#x3D;&#x3D; value) return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doDragOver(event) &#123;</span><br><span class="line">  var isLink &#x3D; contains(event.dataTransfer.types, &#39;text&#x2F;uri-list&#39;);</span><br><span class="line">  if (isLink) event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只有当被拖拉的节点是一个链接时，才允许在当前节点放下。</p>
<h4 id="DataTransfer-items"><a href="#DataTransfer-items" class="headerlink" title="DataTransfer.items"></a>DataTransfer.items</h4><p><code>DataTransfer.items</code>属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</p>
<p>DataTransferItemList 实例具有以下的属性和方法。</p>
<ul>
<li><code>length</code>：返回成员的数量</li>
<li><code>add(data, type)</code>：增加一个指定内容和类型（比如<code>text/html</code>和<code>text/plain</code>）的字符串作为成员</li>
<li><code>add(file)</code>：<code>add</code>方法的另一种用法，增加一个文件作为成员</li>
<li><code>remove(index)</code>：移除指定位置的成员</li>
<li><code>clear()</code>：移除所有的成员</li>
</ul>
<p>DataTransferItem 实例具有以下的属性和方法。</p>
<ul>
<li><code>kind</code>：返回成员的种类（<code>string</code>还是<code>file</code>）。</li>
<li><code>type</code>：返回成员的类型（通常是 MIME 值）。</li>
<li><code>getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回<code>null</code>。</li>
<li><code>getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;drop&#39;, function (e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  if (e.dataTransfer.items !&#x3D; null) &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; e.dataTransfer.items.length; i++) &#123;</span><br><span class="line">      console.log(e.dataTransfer.items[i].kind + &#39;: &#39; + e.dataTransfer.items[i].type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="DataTransfer的实例方法"><a href="#DataTransfer的实例方法" class="headerlink" title="DataTransfer的实例方法"></a>DataTransfer的实例方法</h3><h4 id="DataTransfer-setData"><a href="#DataTransfer-setData" class="headerlink" title="DataTransfer.setData()"></a>DataTransfer.setData()</h4><p><code>DataTransfer.setData()</code>方法用来设置拖拉事件所带有的数据。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.dataTransfer.setData(&#39;text&#x2F;plain&#39;, &#39;Text to drag&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码为当前的拖拉事件加入纯文本数据。</p>
<p>该方法接受两个参数，都是字符串。第一个参数表示数据类型（比如<code>text/plain</code>），第二个参数是具体数据。如果指定类型的数据在<code>dataTransfer</code>属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p>
<p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到<code>dataTransfer</code>属性，不用手动指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div draggable&#x3D;&quot;true&quot;&gt;</span><br><span class="line">  aaa</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，拖拉这个``元素会自动带上文本数据<code>aaa</code>。</p>
<p>使用<code>setData</code>方法，可以替换到原有数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  draggable&#x3D;&quot;true&quot;</span><br><span class="line">  ondragstart&#x3D;&quot;event.dataTransfer.setData(&#39;text&#x2F;plain&#39;, &#39;bbb&#39;)&quot;</span><br><span class="line">&gt;</span><br><span class="line">  aaa</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，拖拉数据实际上是<code>bbb</code>，而不是<code>aaa</code>。</p>
<p>下面是添加其他类型的数据。由于<code>text/plain</code>是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var dt &#x3D; event.dataTransfer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加链接</span><br><span class="line">dt.setData(&#39;text&#x2F;uri-list&#39;, &#39;http:&#x2F;&#x2F;www.example.com&#39;);</span><br><span class="line">dt.setData(&#39;text&#x2F;plain&#39;, &#39;http:&#x2F;&#x2F;www.example.com&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加 HTML 代码</span><br><span class="line">dt.setData(&#39;text&#x2F;html&#39;, &#39;Hello there, &lt;strong&gt;stranger&lt;&#x2F;strong&gt;&#39;);</span><br><span class="line">dt.setData(&#39;text&#x2F;plain&#39;, &#39;Hello there, &lt;strong&gt;stranger&lt;&#x2F;strong&gt;&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加图像的 URL</span><br><span class="line">dt.setData(&#39;text&#x2F;uri-list&#39;, imageurl);</span><br><span class="line">dt.setData(&#39;text&#x2F;plain&#39;, imageurl);</span><br></pre></td></tr></table></figure>

<p>可以一次提供多种格式的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dt &#x3D; event.dataTransfer;</span><br><span class="line">dt.setData(&#39;application&#x2F;x-bookmark&#39;, bookmarkString);</span><br><span class="line">dt.setData(&#39;text&#x2F;uri-list&#39;, &#39;http:&#x2F;&#x2F;www.example.com&#39;);</span><br><span class="line">dt.setData(&#39;text&#x2F;plain&#39;, &#39;http:&#x2F;&#x2F;www.example.com&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，<code>drop</code>不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能<code>drop</code>（读取到）这个数据。</p>
<h4 id="DataTransfer-getData"><a href="#DataTransfer-getData" class="headerlink" title="DataTransfer.getData()"></a>DataTransfer.getData()</h4><p><code>DataTransfer.getData()</code>方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用<code>setData</code>方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有<code>drop</code>事件触发后，才能取出数据。</p>
<p>下面是一个<code>drop</code>事件的监听函数，用来取出指定类型的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function onDrop(event) &#123;</span><br><span class="line">  var data &#x3D; event.dataTransfer.getData(&#39;text&#x2F;plain&#39;);</span><br><span class="line">  event.target.textContent &#x3D; data;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p>
<p><code>getData</code>方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function doDrop(event) &#123;</span><br><span class="line">  var lines &#x3D; event.dataTransfer.getData(&#39;text&#x2F;uri-list&#39;).split(&#39;\n&#39;);</span><br><span class="line">  for (let line of lines) &#123;</span><br><span class="line">    let link &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">    link.href &#x3D; line;</span><br><span class="line">    link.textContent &#x3D; line;</span><br><span class="line">    event.target.appendChild(link);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getData</code>方法返回的是一组链接，就必须自行解析。</p>
<p>类型值指定为<code>URL</code>，可以取出第一个有效链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var link &#x3D; event.dataTransfer.getData(&#39;URL&#39;);</span><br></pre></td></tr></table></figure>

<p>下面的例子是从多种类型的数据里面取出数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doDrop(event) &#123;</span><br><span class="line">  var types &#x3D; event.dataTransfer.types;</span><br><span class="line">  var supportedTypes &#x3D; [&#39;text&#x2F;uri-list&#39;, &#39;text&#x2F;plain&#39;];</span><br><span class="line">  types &#x3D; supportedTypes.filter(function (value) &#123; types.includes(value) &#125;);</span><br><span class="line">  if (types.length) &#123;</span><br><span class="line">    var data &#x3D; event.dataTransfer.getData(types[0]);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DataTransfer-clearData"><a href="#DataTransfer-clearData" class="headerlink" title="DataTransfer.clearData()"></a>DataTransfer.clearData()</h4><p><code>DataTransfer.clearData()</code>方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.dataTransfer.clearData(&#39;text&#x2F;uri-list&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码清除事件所带的<code>text/uri-list</code>类型的数据。</p>
<p>该方法不会移除拖拉的文件，因此调用该方法后，<code>DataTransfer.types</code>属性可能依然会返回<code>Files</code>类型（前提是存在文件拖拉）。</p>
<p>注意，该方法只能在<code>dragstart</code>事件的监听函数之中使用，因为这是拖拉操作的数据唯一可写的时机。</p>
<h4 id="DataTransfer-setDragImage"><a href="#DataTransfer-setDragImage" class="headerlink" title="DataTransfer.setDragImage()"></a>DataTransfer.setDragImage()</h4><p>拖动过程中（<code>dragstart</code>事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置。</p>
<p><code>DataTransfer.setDragImage()</code>方法可以自定义这张图片。它接受三个参数。第一个是<code>节点或者</code>节点，如果省略或为<code>null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line"> &lt;div id&#x3D;&quot;drag-with-image&quot; class&#x3D;&quot;dragdemo&quot; draggable&#x3D;&quot;true&quot;&gt;</span><br><span class="line">   drag me</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.getElementById(&#39;drag-with-image&#39;);</span><br><span class="line">div.addEventListener(&#39;dragstart&#39;, function (e) &#123;</span><br><span class="line">  var img &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">  img.src &#x3D; &#39;http:&#x2F;&#x2F;path&#x2F;to&#x2F;img&#39;;</span><br><span class="line">  e.dataTransfer.setDragImage(img, 0, 0);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<h2 id="其他常见事件"><a href="#其他常见事件" class="headerlink" title="其他常见事件"></a>其他常见事件</h2><h3 id="资源事件"><a href="#资源事件" class="headerlink" title="资源事件"></a>资源事件</h3><h4 id="beforeunload事件"><a href="#beforeunload事件" class="headerlink" title="beforeunload事件"></a>beforeunload事件</h4><p><code>beforeunload</code>事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。</p>
<p>如果该事件对象的<code>returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;beforeunload&#39;, function (event) &#123;</span><br><span class="line">  event.returnValue &#x3D; &#39;你确定离开吗？&#39;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，用户如果关闭窗口，浏览器会弹出一个窗口，要求用户确认。</p>
<p>浏览器对这个事件的行为很不一致，有的浏览器调用<code>event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。因此，可以采用下面的写法，取得最大的兼容性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;beforeunload&#39;, function (e) &#123;</span><br><span class="line">  var confirmationMessage &#x3D; &#39;确认关闭窗口？&#39;;</span><br><span class="line"></span><br><span class="line">  e.returnValue &#x3D; confirmationMessage;</span><br><span class="line">  return confirmationMessage;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，许多手机浏览器默认忽略这个事件，桌面浏览器也有办法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭窗口。另外，一旦使用了<code>beforeunload</code>事件，浏览器就不会缓存当前网页，使用“回退”按钮将重新向服务器请求网页。这是因为监听这个事件的目的，一般是修改初始状态，这时缓存初始页面就没意义了。</p>
<p>基本上，只有一种场合可以监听<code>unload</code>事件，其他情况都不应该监听：用户修改了表单，还没有保存就要离开。</p>
<h4 id="unload事件"><a href="#unload事件" class="headerlink" title="unload事件"></a>unload事件</h4><p><code>unload</code>事件在窗口关闭或者<code>document</code>对象将要卸载时触发。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。</p>
<p><code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;unload&#39;, function(event) &#123;</span><br><span class="line">  console.log(&#39;文档将要卸载&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且跟<code>beforeunload</code>事件一样，一旦使用了<code>unload</code>事件，浏览器就不会缓存当前网页，理由同上。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。</p>
<h4 id="load事件，error事件"><a href="#load事件，error事件" class="headerlink" title="load事件，error事件"></a>load事件，error事件</h4><p><code>load</code>事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;load&#39;, function(event) &#123;</span><br><span class="line">  console.log(&#39;所有资源都加载完成&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>error</code>事件是在页面或资源加载失败时触发。<code>abort</code>事件在用户取消加载时触发。</p>
<p>这三个事件实际上属于进度事件，不仅发生在<code>document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和<code>document</code>对象、<code>window</code>对象、XMLHttpRequestUpload 对象，都会触发<code>load</code>事件和<code>error</code>事件。</p>
<h3 id="session历史事件"><a href="#session历史事件" class="headerlink" title="session历史事件"></a>session历史事件</h3><h4 id="pageshow事件，pagehide事件"><a href="#pageshow事件，pagehide事件" class="headerlink" title="pageshow事件，pagehide事件"></a>pageshow事件，pagehide事件</h4><p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</p>
<p>pageshow 事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p>
<p>第一次加载时，它的触发顺序排在<code>load</code>事件后面。从缓存加载时，<code>load</code>事件不会触发，因为网页在缓存中的样子通常是<code>load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;pageshow&#39;, function(event) &#123;</span><br><span class="line">  console.log(&#39;pageshow: &#39;, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>pageshow 事件有一个<code>persisted</code>属性，返回一个布尔值。页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;pageshow&#39;, function(event)&#123;</span><br><span class="line">  if (event.persisted) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</p>
<p><code>pagehide</code>事件实例也有一个<code>persisted</code>属性，将这个属性设为<code>true</code>，就表示页面要保存在缓存中；设为<code>false</code>，表示网页不保存在缓存中，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p>
<p>如果页面包含<code>或</code>元素，则``页面的<code>pageshow</code>事件和<code>pagehide</code>事件，都会在主页面之前触发。</p>
<p>注意，这两个事件只在浏览器的<code>history</code>对象发生变化时触发，跟网页是否可见没有关系。</p>
<h4 id="popstate事件"><a href="#popstate事件" class="headerlink" title="popstate事件"></a>popstate事件</h4><p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发。</p>
<p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;state: &#39; + event.state);</span><br><span class="line">&#125;;</span><br><span class="line">history.pushState(&#123;page: 1&#125;, &#39;title 1&#39;, &#39;?page&#x3D;1&#39;);</span><br><span class="line">history.pushState(&#123;page: 2&#125;, &#39;title 2&#39;, &#39;?page&#x3D;2&#39;);</span><br><span class="line">history.replaceState(&#123;page: 3&#125;, &#39;title 3&#39;, &#39;?page&#x3D;3&#39;);</span><br><span class="line">history.back(); &#x2F;&#x2F; state: &#123;&quot;page&quot;:1&#125;</span><br><span class="line">history.back(); &#x2F;&#x2F; state: null</span><br><span class="line">history.go(2);  &#x2F;&#x2F; state: &#123;&quot;page&quot;:3&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>pushState</code>方法向<code>history</code>添加了两条记录，然后<code>replaceState</code>方法替换掉当前记录。因此，连续两次<code>back</code>方法，会让当前条目退回到原始网址，它没有附带<code>state</code>对象，所以事件的<code>state</code>属性为<code>null</code>，然后前进两条记录，又回到<code>replaceState</code>方法添加的记录。</p>
<p>浏览器对于页面首次加载，是否触发<code>popstate</code>事件，处理不一样，Firefox 不触发该事件。</p>
<h4 id="hashchange事件"><a href="#hashchange事件" class="headerlink" title="hashchange事件"></a>hashchange事件</h4><p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听。</p>
<p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; URL 是 http:&#x2F;&#x2F;www.example.com&#x2F;</span><br><span class="line">window.addEventListener(&#39;hashchange&#39;, myFunction);</span><br><span class="line"></span><br><span class="line">function myFunction(e) &#123;</span><br><span class="line">  console.log(e.oldURL);</span><br><span class="line">  console.log(e.newURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location.hash &#x3D; &#39;part2&#39;;</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;www.example.com&#x2F;</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;www.example.com&#x2F;#part2</span><br></pre></td></tr></table></figure>

<h3 id="网页状态事件"><a href="#网页状态事件" class="headerlink" title="网页状态事件"></a>网页状态事件</h3><h4 id="DOMContentLoaded事件"><a href="#DOMContentLoaded事件" class="headerlink" title="DOMContentLoaded事件"></a>DOMContentLoaded事件</h4><p>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比<code>load</code>事件，发生时间早得多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;DOMContentLoaded&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;DOM生成&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;DOMContentLoaded&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;DOM 生成&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段代码会推迟触发 DOMContentLoaded 事件</span><br><span class="line">for(var i &#x3D; 0; i &lt; 1000000000; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="readystatechange事件"><a href="#readystatechange事件" class="headerlink" title="readystatechange事件"></a>readystatechange事件</h4><p><code>readystatechange</code>事件当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发。<code>document.readyState</code>有三个可能的值：<code>loading</code>（网页正在加载）、<code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）和<code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">  if (document.readyState &#x3D;&#x3D;&#x3D; &#39;interactive&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个事件可以看作<code>DOMContentLoaded</code>事件的另一种实现方法。</p>
<h3 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h3><h4 id="scroll事件"><a href="#scroll事件" class="headerlink" title="scroll事件"></a>scroll事件</h4><p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;scroll&#39;, callback);</span><br></pre></td></tr></table></figure>

<p>该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  var throttle &#x3D; function (type, name, obj) &#123;</span><br><span class="line">    var obj &#x3D; obj || window;</span><br><span class="line">    var running &#x3D; false;</span><br><span class="line">    var func &#x3D; function () &#123;</span><br><span class="line">      if (running) &#123; return; &#125;</span><br><span class="line">      running &#x3D; true;</span><br><span class="line">      requestAnimationFrame(function() &#123;</span><br><span class="line">        obj.dispatchEvent(new CustomEvent(name));</span><br><span class="line">        running &#x3D; false;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.addEventListener(type, func);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将 scroll 事件重定义为 optimizedScroll 事件</span><br><span class="line">  throttle(&#39;scroll&#39;, &#39;optimizedScroll&#39;);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;optimizedScroll&#39;, function() &#123;</span><br><span class="line">  console.log(&#39;Resource conscious scroll callback!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>throttle</code>函数用于控制事件触发频率，<code>requestAnimationFrame</code>方法保证每次页面重绘（每秒60次），只会触发一次<code>scroll</code>事件的监听函数。也就是说，上面方法将<code>scroll</code>事件的触发频率，限制在每秒60次。具体来说，就是<code>scroll</code>事件只要频率低于每秒60次，就会触发<code>optimizedScroll</code>事件，从而执行<code>optimizedScroll</code>事件的监听函数。</p>
<p>改用<code>setTimeout</code>方法，可以放置更大的时间间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  window.addEventListener(&#39;scroll&#39;, scrollThrottler, false);</span><br><span class="line"></span><br><span class="line">  var scrollTimeout;</span><br><span class="line">  function scrollThrottler() &#123;</span><br><span class="line">    if (!scrollTimeout) &#123;</span><br><span class="line">      scrollTimeout &#x3D; setTimeout(function () &#123;</span><br><span class="line">        scrollTimeout &#x3D; null;</span><br><span class="line">        actualScrollHandler();</span><br><span class="line">      &#125;, 66);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function actualScrollHandler() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>上面代码中，每次<code>scroll</code>事件都会执行<code>scrollThrottler</code>函数。该函数里面有一个定时器<code>setTimeout</code>，每66毫秒触发一次（每秒15次）真正执行的任务<code>actualScrollHandler</code>。</p>
<p>下面是一个更一般的<code>throttle</code>函数的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">  var time &#x3D; Date.now();</span><br><span class="line">  return function() &#123;</span><br><span class="line">    if ((time + wait - Date.now()) &lt; 0) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      time &#x3D; Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;scroll&#39;, throttle(callback, 1000));</span><br></pre></td></tr></table></figure>

<p>上面的代码将<code>scroll</code>事件的触发频率，限制在一秒一次。</p>
<p><code>lodash</code>函数库提供了现成的<code>throttle</code>函数，可以直接使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;scroll&#39;, _.throttle(callback, 1000));</span><br></pre></td></tr></table></figure>

<p>本书前面介绍过<code>debounce</code>的概念，<code>throttle</code>与它区别在于，<code>throttle</code>是“节流”，确保一段时间内只执行一次，而<code>debounce</code>是“防抖”，要连续操作结束后再执行。以网页滚动为例，<code>debounce</code>要等到用户停止滚动后才执行，<code>throttle</code>则是如果用户一直在滚动网页，那么在滚动过程中还是会执行。</p>
<h4 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h4><p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var resizeMethod &#x3D; function () &#123;</span><br><span class="line">  if (document.body.clientWidth &lt; 768) &#123;</span><br><span class="line">    console.log(&#39;移动设备的视口&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;resize&#39;, resizeMethod, true);</span><br></pre></td></tr></table></figure>

<p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p>
<h4 id="fullscreenchange事件，fullscreenerror事件"><a href="#fullscreenchange事件，fullscreenerror事件" class="headerlink" title="fullscreenchange事件，fullscreenerror事件"></a>fullscreenchange事件，fullscreenerror事件</h4><p><code>fullscreenchange</code>事件在进入或退出全屏状态时触发，该事件发生在<code>document</code>对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;fullscreenchange&#39;, function (event) &#123;</span><br><span class="line">  console.log(document.fullscreenElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fullscreenerror</code>事件在浏览器无法切换到全屏状态时触发。</p>
<h3 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h3><p>以下三个事件属于剪贴板操作的相关事件。</p>
<ul>
<li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li>
<li><code>copy</code>：进行复制动作时触发。</li>
<li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li>
</ul>
<p>这三个事件都是<code>ClipboardEvent</code>接口的实例。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;copy&#39;, function (e) &#123;</span><br><span class="line">  e.clipboardData.setData(&#39;text&#x2F;plain&#39;, &#39;Hello, world!&#39;);</span><br><span class="line">  e.clipboardData.setData(&#39;text&#x2F;html&#39;, &#39;&lt;b&gt;Hello, world!&lt;&#x2F;b&gt;&#39;);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p>
<ul>
<li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li>
<li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li>
<li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li>
<li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li>
</ul>
<p>这四个事件都继承了<code>FocusEvent</code>接口。<code>FocusEvent</code>实例具有以下属性。</p>
<ul>
<li><code>FocusEvent.target</code>：事件的目标节点。</li>
<li><code>FocusEvent.relatedTarget</code>：对于<code>focusin</code>事件，返回失去焦点的节点；对于<code>focusout</code>事件，返回将要接受焦点的节点；对于<code>focus</code>和<code>blur</code>事件，返回<code>null</code>。</li>
</ul>
<p>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">form.addEventListener(&#39;focus&#39;, function (event) &#123;</span><br><span class="line">  event.target.style.background &#x3D; &#39;pink&#39;;</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">form.addEventListener(&#39;blur&#39;, function (event) &#123;</span><br><span class="line">  event.target.style.background &#x3D; &#39;&#39;;</span><br><span class="line">&#125;, true);</span><br></pre></td></tr></table></figure>

<p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p>
<h3 id="CustomEvent接口"><a href="#CustomEvent接口" class="headerlink" title="CustomEvent接口"></a>CustomEvent接口</h3><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new CustomEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var event &#x3D; new CustomEvent(&#39;build&#39;, &#123; &#39;detail&#39;: &#39;hello&#39; &#125;);</span><br><span class="line"></span><br><span class="line">function eventHandler(e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&#39;build&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myEvent &#x3D; new CustomEvent(&#39;myevent&#39;, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    foo: &#39;bar&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  bubbles: true,</span><br><span class="line">  cancelable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;myevent&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;Hello &#39; + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>

<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p>
<h2 id="GlobalEventHandlers接口"><a href="#GlobalEventHandlers接口" class="headerlink" title="GlobalEventHandlers接口"></a>GlobalEventHandlers接口</h2><p>指定事件的回调函数，推荐使用的方法是元素的<code>addEventListener</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, clickHandler, false);</span><br></pre></td></tr></table></figure>

<p>除了之外，还有一种方法可以直接指定事件的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.onclick &#x3D; clickHandler;</span><br></pre></td></tr></table></figure>

<p>这个接口是由<code>GlobalEventHandlers</code>接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。</p>
<p><code>HTMLElement</code>、<code>Document</code>和<code>Window</code>都继承了这个接口，也就是说，各种 HTML 元素、<code>document</code>对象、<code>window</code>对象上面都可以使用<code>GlobalEventHandlers</code>接口提供的属性。下面就列出这个接口提供的主要的事件属性。</p>
<h3 id="GlobalEventHandlers-onabort"><a href="#GlobalEventHandlers-onabort" class="headerlink" title="GlobalEventHandlers.onabort"></a>GlobalEventHandlers.onabort</h3><p>某个对象的<code>abort</code>事件（停止加载）发生时，就会调用<code>onabort</code>属性指定的回调函数。</p>
<p>各种元素的停止加载事件，到底如何触发，目前并没有统一的规定。因此实际上，这个属性现在一般只用在``元素上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;img src&#x3D;&quot;example.jpg&quot; id&#x3D;&quot;img&quot;&gt;</span><br><span class="line">var img &#x3D; document.getElementById(&#39;img&#39;);</span><br><span class="line">img.onabort &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;image load aborted.&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GlobalEventHandlers-onerror"><a href="#GlobalEventHandlers-onerror" class="headerlink" title="GlobalEventHandlers.onerror"></a>GlobalEventHandlers.onerror</h3><p><code>error</code>事件发生时，就会调用<code>onerror</code>属性指定的回调函数。</p>
<p><code>error</code>事件分成两种。</p>
<p>一种是 JavaScript 的运行时错误，这会传到<code>window</code>对象，导致<code>window.onerror()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function (message, source, lineno, colno, error) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.onerror</code>的处理函数共接受五个参数，含义如下。</p>
<ul>
<li>message：错误信息字符串</li>
<li>source：报错脚本的 URL</li>
<li>lineno：报错的行号，是一个整数</li>
<li>colno：报错的列号，是一个整数</li>
<li>error： 错误对象</li>
</ul>
<p>另一种是资源加载错误，比如<code>或</code>加载的资源出现加载错误。这时，Error 对象会传到对应的元素，导致该元素的<code>onerror</code>属性开始执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.onerror &#x3D; function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，一般来说，资源的加载错误不会触发<code>window.onerror</code>。</p>
<h3 id="GlobalEventHandlers-onload-GlobalEventHandlers-onloadstart"><a href="#GlobalEventHandlers-onload-GlobalEventHandlers-onloadstart" class="headerlink" title="GlobalEventHandlers.onload,GlobalEventHandlers.onloadstart"></a>GlobalEventHandlers.onload,GlobalEventHandlers.onloadstart</h3><p>元素完成加载时，会触发<code>load</code>事件，执行<code>onload()</code>。它的典型使用场景是<code>window</code>对象和``元素。对于<code>window</code>对象来说，只有页面的所有资源加载完成（包括图片、脚本、样式表、字体等所有外部资源），才会触发<code>load</code>事件。</p>
<p>对于<code>和</code>等元素，加载开始时还会触发<code>loadstart</code>事件，导致执行<code>onloadstart</code>。</p>
<h3 id="GlobalEventHandlers-onfocus-GlobalEventHandlers-onblur"><a href="#GlobalEventHandlers-onfocus-GlobalEventHandlers-onblur" class="headerlink" title="GlobalEventHandlers.onfocus,GlobalEventHandlers.onblur"></a>GlobalEventHandlers.onfocus,GlobalEventHandlers.onblur</h3><p>当前元素获得焦点时，会触发<code>element.onfocus</code>；失去焦点时，会触发<code>element.onblur</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">element.onfocus &#x3D; function () &#123;</span><br><span class="line">  console.log(&quot;onfocus event detected!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">element.onblur &#x3D; function () &#123;</span><br><span class="line">  console.log(&quot;onblur event detected!&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，如果不是可以接受用户输入的元素，要触发<code>onfocus</code>，该元素必须有<code>tabindex</code>属性。</p>
<h3 id="GlobalEventHandlers-onscroll"><a href="#GlobalEventHandlers-onscroll" class="headerlink" title="GlobalEventHandlers.onscroll"></a>GlobalEventHandlers.onscroll</h3><p>页面或元素滚动时，会触发<code>scroll</code>事件，导致执行<code>onscroll()</code>。</p>
<h3 id="GlobalEventHandlers-oncontextmenu-GlobalEventHandlers-onshow"><a href="#GlobalEventHandlers-oncontextmenu-GlobalEventHandlers-onshow" class="headerlink" title="GlobalEventHandlers.oncontextmenu,GlobalEventHandlers.onshow"></a>GlobalEventHandlers.oncontextmenu,GlobalEventHandlers.onshow</h3><p>用户在页面上按下鼠标的右键，会触发<code>contextmenu</code>事件，导致执行<code>oncontextmenu()</code>。如果该属性执行后返回<code>false</code>，就等于禁止了右键菜单。<code>document.oncontextmenu</code>与<code>window.oncontextmenu</code>效果一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.oncontextmenu &#x3D; function () &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>oncontextmenu</code>属性执行后返回<code>false</code>，右键菜单就不会出现。</p>
<p>元素的右键菜单显示时，会触发该元素的<code>onshow</code>监听函数。</p>
<h3 id="其他的事件属性"><a href="#其他的事件属性" class="headerlink" title="其他的事件属性"></a>其他的事件属性</h3><p>鼠标的事件属性。</p>
<ul>
<li>onclick</li>
<li>ondblclick</li>
<li>onmousedown</li>
<li>onmouseenter</li>
<li>onmouseleave</li>
<li>onmousemove</li>
<li>onmouseout</li>
<li>onmouseover</li>
<li>onmouseup</li>
<li>onwheel</li>
</ul>
<p>键盘的事件属性。</p>
<ul>
<li>onkeydown</li>
<li>onkeypress</li>
<li>onkeyup</li>
</ul>
<p>焦点的事件属性。</p>
<ul>
<li>onblur</li>
<li>onfocus</li>
</ul>
<p>表单的事件属性。</p>
<ul>
<li>oninput</li>
<li>onchange</li>
<li>onsubmit</li>
<li>onreset</li>
<li>oninvalid</li>
<li>onselect</li>
</ul>
<p>触摸的事件属性。</p>
<ul>
<li>ontouchcancel</li>
<li>ontouchend</li>
<li>ontouchmove</li>
<li>ontouchstart</li>
</ul>
<p>拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。</p>
<p>被拖动元素的事件属性。</p>
<ul>
<li>ondragstart：拖动开始</li>
<li>ondrag：拖动过程中，每隔几百毫秒触发一次</li>
<li>ondragend：拖动结束</li>
</ul>
<p>接收被拖动元素的容器元素的事件属性。</p>
<ul>
<li>ondragenter：被拖动元素进入容器元素。</li>
<li>ondragleave：被拖动元素离开容器元素。</li>
<li>ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。</li>
<li>ondrop：松开鼠标后，被拖动元素放入容器元素。</li>
</ul>
<p>``对话框元素的事件属性。</p>
<ul>
<li>oncancel</li>
<li>onclose</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cheers</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xiaoxin1993.gitee.io/2020/05/06/js-%E4%BA%8B%E4%BB%B6/">https://xiaoxin1993.gitee.io/2020/05/06/js-%E4%BA%8B%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/06/js-%E9%99%84%E5%BD%95%EF%BC%9A%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E6%8E%A5%E5%8F%A3/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">js-附录：网页元素接口</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/24/js-%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">js-语法专题</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/23/js-异步操作/" title="js-异步操作"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-23</div><div class="relatedPosts_title">js-异步操作</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/23/js-导论/" title="js-导论"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-23</div><div class="relatedPosts_title">js-导论</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/24/js-语法专题/" title="js-语法专题"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-24</div><div class="relatedPosts_title">js-语法专题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/js-附录：网页元素接口/" title="js-附录：网页元素接口"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">js-附录：网页元素接口</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/23/js-面向对象编程/" title="js-面向对象编程"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-23</div><div class="relatedPosts_title">js-面向对象编程</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/11/js-基本语法+数据类型+运算符/" title="js-基本语法+数据类型+运算符"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-11</div><div class="relatedPosts_title">js-基本语法+数据类型+运算符</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Cheers</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/algolia.js"></script></body></html>