<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>js-DOM模型 | Cheers's blog</title><meta name="description" content="概述DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都"><meta name="keywords" content="JavaScript"><meta name="author" content="Cheers"><meta name="copyright" content="Cheers"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="js-DOM模型"><meta name="twitter:description" content="概述DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="js-DOM模型"><meta property="og:url" content="https://xiaoxin1993.gitee.io/2020/04/23/js-DOM%E6%A8%A1%E5%9E%8B/"><meta property="og:site_name" content="Cheers's blog"><meta property="og:description" content="概述DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-04-23T12:57:22.878Z"><meta property="article:modified_time" content="2020-04-23T12:57:22.878Z"><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta name="msapplication-TileColor" content="#fff"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://xiaoxin1993.gitee.io/2020/04/23/js-DOM%E6%A8%A1%E5%9E%8B/"><link rel="prev" title="js-BOM模型" href="https://xiaoxin1993.gitee.io/2020/04/23/js-BOM%E6%A8%A1%E5%9E%8B/"><link rel="next" title="js-异步操作" href="https://xiaoxin1993.gitee.io/2020/04/23/js-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar_img.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">45</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM"><span class="toc-number">1.1.</span> <span class="toc-text">DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点"><span class="toc-number">1.2.</span> <span class="toc-text">节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点树"><span class="toc-number">1.3.</span> <span class="toc-text">节点树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node接口"><span class="toc-number">2.</span> <span class="toc-text">Node接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">2.1.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-nodeType"><span class="toc-number">2.1.1.</span> <span class="toc-text">Node.prototype.nodeType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-nodeName"><span class="toc-number">2.1.2.</span> <span class="toc-text">Node.prototype.nodeName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-nodeValue"><span class="toc-number">2.1.3.</span> <span class="toc-text">Node.prototype.nodeValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-textContent"><span class="toc-number">2.1.4.</span> <span class="toc-text">Node.prototype.textContent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-baseURI"><span class="toc-number">2.1.5.</span> <span class="toc-text">Node.prototype.baseURI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-ownerDocument"><span class="toc-number">2.1.6.</span> <span class="toc-text">Node.prototype.ownerDocument</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-nextSibling"><span class="toc-number">2.1.7.</span> <span class="toc-text">Node.prototype.nextSibling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-previousSibling"><span class="toc-number">2.1.8.</span> <span class="toc-text">Node.prototype.previousSibling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-parentNode"><span class="toc-number">2.1.9.</span> <span class="toc-text">Node.prototype.parentNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-parentElement"><span class="toc-number">2.1.10.</span> <span class="toc-text">Node.prototype.parentElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-firstChild-Node-prototype-lastChild"><span class="toc-number">2.1.11.</span> <span class="toc-text">Node.prototype.firstChild,Node.prototype.lastChild</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-childNodes"><span class="toc-number">2.1.12.</span> <span class="toc-text">Node.prototype.childNodes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-isConnected"><span class="toc-number">2.1.13.</span> <span class="toc-text">Node.prototype.isConnected</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">2.2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-appendChild"><span class="toc-number">2.2.1.</span> <span class="toc-text">Node.prototype.appendChild()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-hasChildNodes"><span class="toc-number">2.2.2.</span> <span class="toc-text">Node.prototype.hasChildNodes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-cloneNode"><span class="toc-number">2.2.3.</span> <span class="toc-text">Node.prototype.cloneNode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-insertBefore"><span class="toc-number">2.2.4.</span> <span class="toc-text">Node.prototype.insertBefore()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-removeChild"><span class="toc-number">2.2.5.</span> <span class="toc-text">Node.prototype.removeChild()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-replaceChild"><span class="toc-number">2.2.6.</span> <span class="toc-text">Node.prototype.replaceChild()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-contains"><span class="toc-number">2.2.7.</span> <span class="toc-text">Node.prototype.contains()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-compareDocumentPosition"><span class="toc-number">2.2.8.</span> <span class="toc-text">Node.prototype.compareDocumentPosition()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-isEqualNode-Node-prototype-isSameNode"><span class="toc-number">2.2.9.</span> <span class="toc-text">Node.prototype.isEqualNode(),Node.prototype.isSameNode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-normalize"><span class="toc-number">2.2.10.</span> <span class="toc-text">Node.prototype.normalize()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-prototype-getRootNode"><span class="toc-number">2.2.11.</span> <span class="toc-text">Node.prototype.getRootNode()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeList接口，HTMLCollection接口"><span class="toc-number">3.</span> <span class="toc-text">NodeList接口，HTMLCollection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NodeList接口"><span class="toc-number">3.1.</span> <span class="toc-text">NodeList接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-1"><span class="toc-number">3.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodeList-prototype-length"><span class="toc-number">3.1.2.</span> <span class="toc-text">NodeList.prototype.length</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodeList-prototype-forEach"><span class="toc-number">3.1.3.</span> <span class="toc-text">NodeList.prototype.forEach()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodeList-prototype-item"><span class="toc-number">3.1.4.</span> <span class="toc-text">NodeList.prototype.item()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodeList-prototype-keys-NodeList-prototype-values-NodeList-prototype-entries"><span class="toc-number">3.1.5.</span> <span class="toc-text">NodeList.prototype.keys(),NodeList.prototype.values(),NodeList.prototype.entries()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTMLCollection接口"><span class="toc-number">3.2.</span> <span class="toc-text">HTMLCollection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLCollection-prototype-length"><span class="toc-number">3.2.2.</span> <span class="toc-text">HTMLCollection.prototype.length</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLCollection-prototype-item"><span class="toc-number">3.2.3.</span> <span class="toc-text">HTMLCollection.prototype.item()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLCollection-prototype-namedItem"><span class="toc-number">3.2.4.</span> <span class="toc-text">HTMLCollection.prototype.namedItem()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ParentNode接口，ChildNode接口"><span class="toc-number">4.</span> <span class="toc-text">ParentNode接口，ChildNode接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ParentNode接口"><span class="toc-number">4.1.</span> <span class="toc-text">ParentNode接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ParentNode-children"><span class="toc-number">4.1.1.</span> <span class="toc-text">ParentNode.children</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParentNode-firstElementChild"><span class="toc-number">4.1.2.</span> <span class="toc-text">ParentNode.firstElementChild</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParentNode-lastElementChild"><span class="toc-number">4.1.3.</span> <span class="toc-text">ParentNode.lastElementChild</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParentNode-childElementCount"><span class="toc-number">4.1.4.</span> <span class="toc-text">ParentNode.childElementCount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParentNode-append-ParentNode-prepend"><span class="toc-number">4.1.5.</span> <span class="toc-text">ParentNode.append(),ParentNode.prepend()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ChildNode接口"><span class="toc-number">4.2.</span> <span class="toc-text">ChildNode接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ChildNode-remove"><span class="toc-number">4.2.1.</span> <span class="toc-text">ChildNode.remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChildNode-before-ChildNode-after"><span class="toc-number">4.2.2.</span> <span class="toc-text">ChildNode.before(),ChildNode.after()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChildNode-replaceWith"><span class="toc-number">4.2.3.</span> <span class="toc-text">ChildNode.replaceWith()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Document节点"><span class="toc-number">5.</span> <span class="toc-text">Document节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-3"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性-1"><span class="toc-number">5.2.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快捷方式属性"><span class="toc-number">5.2.1.</span> <span class="toc-text">快捷方式属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#节点集合属性"><span class="toc-number">5.2.2.</span> <span class="toc-text">节点集合属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文档静态信息属性"><span class="toc-number">5.2.3.</span> <span class="toc-text">文档静态信息属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文档状态属性"><span class="toc-number">5.2.4.</span> <span class="toc-text">文档状态属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-cookie"><span class="toc-number">5.2.5.</span> <span class="toc-text">document.cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-designMode"><span class="toc-number">5.2.6.</span> <span class="toc-text">document.designMode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-currentScript"><span class="toc-number">5.2.7.</span> <span class="toc-text">document.currentScript</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-implementation"><span class="toc-number">5.2.8.</span> <span class="toc-text">document.implementation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法-1"><span class="toc-number">5.3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#document-open-document-close"><span class="toc-number">5.3.1.</span> <span class="toc-text">document.open(),document.close()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-write-document-writeln"><span class="toc-number">5.3.2.</span> <span class="toc-text">document.write(),document.writeln()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-querySelector-document-querySelectorAll"><span class="toc-number">5.3.3.</span> <span class="toc-text">document.querySelector(),document.querySelectorAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-getElementsByTagName"><span class="toc-number">5.3.4.</span> <span class="toc-text">document.getElementsByTagName()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-getElementsByClassName"><span class="toc-number">5.3.5.</span> <span class="toc-text">document.getElementsByClassName()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-getElementsByName"><span class="toc-number">5.3.6.</span> <span class="toc-text">document.getElementsByName()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-getElementById"><span class="toc-number">5.3.7.</span> <span class="toc-text">document.getElementById()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-elementFromPoint-document-elementsFromPoint"><span class="toc-number">5.3.8.</span> <span class="toc-text">document.elementFromPoint(),document.elementsFromPoint()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createElement"><span class="toc-number">5.3.9.</span> <span class="toc-text">document.createElement()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createTextNode"><span class="toc-number">5.3.10.</span> <span class="toc-text">document.createTextNode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createAttribute"><span class="toc-number">5.3.11.</span> <span class="toc-text">document.createAttribute()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createComment"><span class="toc-number">5.3.12.</span> <span class="toc-text">document.createComment()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createDocumentFragment"><span class="toc-number">5.3.13.</span> <span class="toc-text">document.createDocumentFragment()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createEvent"><span class="toc-number">5.3.14.</span> <span class="toc-text">document.createEvent()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-addEventListener-document-removeEventListener-document-dispatchEvent"><span class="toc-number">5.3.15.</span> <span class="toc-text">document.addEventListener(),document.removeEventListener(),document.dispatchEvent()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-hasFocus"><span class="toc-number">5.3.16.</span> <span class="toc-text">document.hasFocus()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-adoptNode-document-importNode"><span class="toc-number">5.3.17.</span> <span class="toc-text">document.adoptNode(),document.importNode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createNodeIterator"><span class="toc-number">5.3.18.</span> <span class="toc-text">document.createNodeIterator()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-createTreeWalker"><span class="toc-number">5.3.19.</span> <span class="toc-text">document.createTreeWalker()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-execCommand-document-queryCommandSupported-document-queryCommandEnabled"><span class="toc-number">5.3.20.</span> <span class="toc-text">document.execCommand(),document.queryCommandSupported(),document.queryCommandEnabled()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-getSelection"><span class="toc-number">5.3.21.</span> <span class="toc-text">document.getSelection()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Element节点"><span class="toc-number">6.</span> <span class="toc-text">Element节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例属性"><span class="toc-number">6.2.</span> <span class="toc-text">实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#元素特性的相关属性"><span class="toc-number">6.2.1.</span> <span class="toc-text">元素特性的相关属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元素状态的相关属性"><span class="toc-number">6.2.2.</span> <span class="toc-text">元素状态的相关属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-attributes"><span class="toc-number">6.2.3.</span> <span class="toc-text">Element.attributes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-className-Element-classList"><span class="toc-number">6.2.4.</span> <span class="toc-text">Element.className,Element.classList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-dataset"><span class="toc-number">6.2.5.</span> <span class="toc-text">Element.dataset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-innerHTML"><span class="toc-number">6.2.6.</span> <span class="toc-text">Element.innerHTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-outerHTML"><span class="toc-number">6.2.7.</span> <span class="toc-text">Element.outerHTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-clientHeight-Element-clientWidth"><span class="toc-number">6.2.8.</span> <span class="toc-text">Element.clientHeight,Element.clientWidth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-clientLeft-Element-clientTop"><span class="toc-number">6.2.9.</span> <span class="toc-text">Element.clientLeft,Element.clientTop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-scrollHeight-Element-scrollWidth"><span class="toc-number">6.2.10.</span> <span class="toc-text">Element.scrollHeight,Element.scrollWidth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-scrollLeft-Element-scrollTop"><span class="toc-number">6.2.11.</span> <span class="toc-text">Element.scrollLeft,Element.scrollTop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-offsetParent"><span class="toc-number">6.2.12.</span> <span class="toc-text">Element.offsetParent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-offsetHeight-Element-offsetWidth"><span class="toc-number">6.2.13.</span> <span class="toc-text">Element.offsetHeight,Element.offsetWidth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-offsetLeft-Element-offsetTop"><span class="toc-number">6.2.14.</span> <span class="toc-text">Element.offsetLeft,Element.offsetTop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-style"><span class="toc-number">6.2.15.</span> <span class="toc-text">Element.style</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-children-Element-childElementCount"><span class="toc-number">6.2.16.</span> <span class="toc-text">Element.children,Element.childElementCount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-firstElementChild-Element-lastElementChild"><span class="toc-number">6.2.17.</span> <span class="toc-text">Element.firstElementChild,Element.lastElementChild</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-nextElementSibling-Element-previousElementSibling"><span class="toc-number">6.2.18.</span> <span class="toc-text">Element.nextElementSibling,Element.previousElementSibling</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例方法"><span class="toc-number">6.3.</span> <span class="toc-text">实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性相关方法"><span class="toc-number">6.3.1.</span> <span class="toc-text">属性相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-querySelector"><span class="toc-number">6.3.2.</span> <span class="toc-text">Element.querySelector()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-querySelectorAll"><span class="toc-number">6.3.3.</span> <span class="toc-text">Element.querySelectorAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-getElementsByClassName"><span class="toc-number">6.3.4.</span> <span class="toc-text">Element.getElementsByClassName()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-getElementsByTagName"><span class="toc-number">6.3.5.</span> <span class="toc-text">Element.getElementsByTagName()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-closest"><span class="toc-number">6.3.6.</span> <span class="toc-text">Element.closest()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-matches"><span class="toc-number">6.3.7.</span> <span class="toc-text">Element.matches()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件相关方法"><span class="toc-number">6.3.8.</span> <span class="toc-text">事件相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-scrollIntoView"><span class="toc-number">6.3.9.</span> <span class="toc-text">Element.scrollIntoView()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-getBoundingClientRect"><span class="toc-number">6.3.10.</span> <span class="toc-text">Element.getBoundingClientRect()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-getClientRects"><span class="toc-number">6.3.11.</span> <span class="toc-text">Element.getClientRects()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-insertAdjacentElement"><span class="toc-number">6.3.12.</span> <span class="toc-text">Element.insertAdjacentElement()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-insertAdjacentHTML-Element-insertAdjacentText"><span class="toc-number">6.3.13.</span> <span class="toc-text">Element.insertAdjacentHTML(),Element.insertAdjacentText()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-remove"><span class="toc-number">6.3.14.</span> <span class="toc-text">Element.remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-focus-Element-blur"><span class="toc-number">6.3.15.</span> <span class="toc-text">Element.focus(),Element.blur()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-click"><span class="toc-number">6.3.16.</span> <span class="toc-text">Element.click()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性的操作"><span class="toc-number">7.</span> <span class="toc-text">属性的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Element-attributes属性"><span class="toc-number">7.1.</span> <span class="toc-text">Element.attributes属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素的标准属性"><span class="toc-number">7.2.</span> <span class="toc-text">元素的标准属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性操作的标准方法"><span class="toc-number">7.3.</span> <span class="toc-text">属性操作的标准方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-4"><span class="toc-number">7.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-getAttribute"><span class="toc-number">7.3.2.</span> <span class="toc-text">Element.getAttribute()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-getAttributeNames"><span class="toc-number">7.3.3.</span> <span class="toc-text">Element.getAttributeNames()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-setAttribute"><span class="toc-number">7.3.4.</span> <span class="toc-text">Element.setAttribute()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-hasAttribute"><span class="toc-number">7.3.5.</span> <span class="toc-text">Element.hasAttribute()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-hasAttributes"><span class="toc-number">7.3.6.</span> <span class="toc-text">Element.hasAttributes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element-removeAttribute"><span class="toc-number">7.3.7.</span> <span class="toc-text">Element.removeAttribute()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dataset属性"><span class="toc-number">7.4.</span> <span class="toc-text">dataset属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Text节点和DocumentFragment节点"><span class="toc-number">8.</span> <span class="toc-text">Text节点和DocumentFragment节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Text节点的概念"><span class="toc-number">8.1.</span> <span class="toc-text">Text节点的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Text节点的属性"><span class="toc-number">8.2.</span> <span class="toc-text">Text节点的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data"><span class="toc-number">8.2.1.</span> <span class="toc-text">data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wholeText"><span class="toc-number">8.2.2.</span> <span class="toc-text">wholeText</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#length"><span class="toc-number">8.2.3.</span> <span class="toc-text">length</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextElementSibling，previousElementSibling"><span class="toc-number">8.2.4.</span> <span class="toc-text">nextElementSibling，previousElementSibling</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Text节点的方法"><span class="toc-number">8.3.</span> <span class="toc-text">Text节点的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#appendData-deleteData-insertData-replaceData-subStringData"><span class="toc-number">8.3.1.</span> <span class="toc-text">appendData(),deleteData(),insertData(),replaceData(),subStringData()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove"><span class="toc-number">8.3.2.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#splitText"><span class="toc-number">8.3.3.</span> <span class="toc-text">splitText()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DocumentFragment节点"><span class="toc-number">8.4.</span> <span class="toc-text">DocumentFragment节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS操作"><span class="toc-number">9.</span> <span class="toc-text">CSS操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML元素的style属性"><span class="toc-number">9.1.</span> <span class="toc-text">HTML元素的style属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSSStyleDeclaration接口"><span class="toc-number">9.2.</span> <span class="toc-text">CSSStyleDeclaration接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSSStyleDeclaration实例属性"><span class="toc-number">9.2.2.</span> <span class="toc-text">CSSStyleDeclaration实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSSStyleDeclaration实例方法"><span class="toc-number">9.2.3.</span> <span class="toc-text">CSSStyleDeclaration实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS模块的侦测"><span class="toc-number">9.3.</span> <span class="toc-text">CSS模块的侦测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS对象"><span class="toc-number">9.4.</span> <span class="toc-text">CSS对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-escape"><span class="toc-number">9.4.1.</span> <span class="toc-text">CSS.escape()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-supports"><span class="toc-number">9.4.2.</span> <span class="toc-text">CSS.supports()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-getComputedStyle"><span class="toc-number">9.5.</span> <span class="toc-text">window.getComputedStyle()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS伪元素"><span class="toc-number">9.6.</span> <span class="toc-text">CSS伪元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StyleSheet接口"><span class="toc-number">9.7.</span> <span class="toc-text">StyleSheet接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-5"><span class="toc-number">9.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例属性-1"><span class="toc-number">9.7.2.</span> <span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例方法-1"><span class="toc-number">9.7.3.</span> <span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例：添加样式表"><span class="toc-number">9.8.</span> <span class="toc-text">实例：添加样式表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSSRuleList接口"><span class="toc-number">9.9.</span> <span class="toc-text">CSSRuleList接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSSRule接口"><span class="toc-number">9.10.</span> <span class="toc-text">CSSRule接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-6"><span class="toc-number">9.10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSSRule实例的属性"><span class="toc-number">9.10.2.</span> <span class="toc-text">CSSRule实例的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSSStyleRule接口"><span class="toc-number">9.10.3.</span> <span class="toc-text">CSSStyleRule接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSSMediaRule接口"><span class="toc-number">9.10.4.</span> <span class="toc-text">CSSMediaRule接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-matchMedia"><span class="toc-number">9.11.</span> <span class="toc-text">window.matchMedia()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-number">9.11.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MediaQueryList接口的实例属性"><span class="toc-number">9.11.2.</span> <span class="toc-text">MediaQueryList接口的实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MediaQueryList接口的实例方法"><span class="toc-number">9.11.3.</span> <span class="toc-text">MediaQueryList接口的实例方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutation-Observer-API"><span class="toc-number">10.</span> <span class="toc-text">Mutation Observer API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-7"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutationObserver构造函数"><span class="toc-number">10.2.</span> <span class="toc-text">MutationObserver构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutationObserver的实例方法"><span class="toc-number">10.3.</span> <span class="toc-text">MutationObserver的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#observe"><span class="toc-number">10.3.1.</span> <span class="toc-text">observe()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#disconnect-takeRecords"><span class="toc-number">10.3.2.</span> <span class="toc-text">disconnect(),takeRecords()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutationRecord对象"><span class="toc-number">10.4.</span> <span class="toc-text">MutationRecord对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用示例"><span class="toc-number">10.5.</span> <span class="toc-text">应用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#子元素的变动"><span class="toc-number">10.5.1.</span> <span class="toc-text">子元素的变动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的变动"><span class="toc-number">10.5.2.</span> <span class="toc-text">属性的变动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取代DOMContentLoaded事件"><span class="toc-number">10.5.3.</span> <span class="toc-text">取代DOMContentLoaded事件</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Cheers's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">js-DOM模型</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-04-23 20:57:22"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-04-23</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-04-23 20:57:22"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-04-23</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/">JavaScript</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/notes/">notes</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/notes/DOM/">DOM</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p>
<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>
<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>
<p>节点的类型有七种。</p>
<ul>
<li><code>Document</code>：整个文档树的顶层节点</li>
<li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>!DOCTYPE html</code>）</li>
<li><code>Element</code>：网页的各种HTML标签（比如<code>body</code>、<code>a</code>等）</li>
<li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li>
<li><code>Text</code>：标签之间或标签包含的文本</li>
<li><code>Comment</code>：注释</li>
<li><code>DocumentFragment</code>：文档的片段</li>
</ul>
<p>浏览器提供一个原生的节点对象<code>Node</code>，上面这七种节点都继承了<code>Node</code>，因此具有一些共同的属性和方法。</p>
<h3 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h3><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。</p>
<p>浏览器原生提供<code>document</code>节点，代表整个文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document</span><br><span class="line">&#x2F;&#x2F; 整个文档树</span><br></pre></td></tr></table></figure>

<p>文档的第一层有两个节点，第一个是文档类型节点（<code>!doctype html</code>），第二个是 HTML 网页的顶层容器标签<code>html</code>。后者构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p>
<p>除了根节点，其他节点都有三种层级关系。</p>
<ul>
<li>父节点关系（parentNode）：直接的那个上级节点</li>
<li>子节点关系（childNodes）：直接的下级节点</li>
<li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>
<p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括<code>firstChild</code>（第一个子节点）和<code>lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code>nextSibling</code>（紧邻在后的那个同级节点）和<code>previousSibling</code>（紧邻在前的那个同级节点）属性。</p>
<h2 id="Node接口"><a href="#Node接口" class="headerlink" title="Node接口"></a>Node接口</h2><p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="Node-prototype-nodeType"><a href="#Node-prototype-nodeType" class="headerlink" title="Node.prototype.nodeType"></a>Node.prototype.nodeType</h4><p><code>nodeType</code>属性返回一个整数值，表示节点的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.nodeType &#x2F;&#x2F; 9</span><br></pre></td></tr></table></figure>

<p>上面代码中，文档节点的类型值为9。</p>
<p>Node 对象定义了几个常量，对应这些类型值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.nodeType &#x3D;&#x3D;&#x3D; Node.DOCUMENT_NODE &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，文档节点的<code>nodeType</code>属性等于常量<code>Node.DOCUMENT_NODE</code>。</p>
<p>不同节点的<code>nodeType</code>属性值和对应的常量如下。</p>
<ul>
<li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li>
<li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li>
<li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li>
<li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li>
<li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li>
<li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li>
<li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code></li>
</ul>
<p>确定节点类型时，使用<code>nodeType</code>属性是常用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var node &#x3D; document.documentElement.firstChild;</span><br><span class="line">if (node.nodeType &#x3D;&#x3D;&#x3D; Node.ELEMENT_NODE) &#123;</span><br><span class="line">  console.log(&#39;该节点是元素节点&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Node-prototype-nodeName"><a href="#Node-prototype-nodeName" class="headerlink" title="Node.prototype.nodeName"></a>Node.prototype.nodeName</h4><p><code>nodeName</code>属性返回节点的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;d1&quot;&gt;hello world&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.getElementById(&#39;d1&#39;);</span><br><span class="line">div.nodeName &#x2F;&#x2F; &quot;DIV&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，元素节点<code>div</code>的<code>nodeName</code>属性就是大写的标签名<code>DIV</code>。</p>
<p>不同节点的<code>nodeName</code>属性值如下。</p>
<ul>
<li>文档节点（document）：<code>#document</code></li>
<li>元素节点（element）：大写的标签名</li>
<li>属性节点（attr）：属性的名称</li>
<li>文本节点（text）：<code>#text</code></li>
<li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li>
<li>文档类型节点（DocumentType）：文档的类型</li>
<li>注释节点（Comment）：<code>#comment</code></li>
</ul>
<h4 id="Node-prototype-nodeValue"><a href="#Node-prototype-nodeValue" class="headerlink" title="Node.prototype.nodeValue"></a>Node.prototype.nodeValue</h4><p><code>nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>
<p>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。同样的，也只有这三类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;d1&quot;&gt;hello world&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.getElementById(&#39;d1&#39;);</span><br><span class="line">div.nodeValue &#x2F;&#x2F; null</span><br><span class="line">div.firstChild.nodeValue &#x2F;&#x2F; &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>是元素节点，<code>nodeValue</code>属性返回<code>null</code>。<code>div.firstChild</code>是文本节点，所以可以返回文本值。</p>
<h4 id="Node-prototype-textContent"><a href="#Node-prototype-textContent" class="headerlink" title="Node.prototype.textContent"></a>Node.prototype.textContent</h4><p><code>textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;&#x2F;span&gt; text&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;divA&#39;).textContent</span><br><span class="line">&#x2F;&#x2F; This is some text</span><br></pre></td></tr></table></figure>

<p><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p>
<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;foo&#39;).textContent &#x3D; &#39;&lt;p&gt;GoodBye!&lt;&#x2F;p&gt;&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码在插入文本时，会将<code>p</code>标签解释为文本，而不会当作标签处理。</p>
<p>对于文本节点（text）、注释节点（comment）和属性节点（attr），<code>textContent</code>属性的值与<code>nodeValue</code>属性相同。对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。</p>
<p>文档节点（document）和文档类型节点（doctype）的<code>textContent</code>属性为<code>null</code>。如果要读取整个文档的内容，可以使用<code>document.documentElement.textContent</code>。</p>
<h4 id="Node-prototype-baseURI"><a href="#Node-prototype-baseURI" class="headerlink" title="Node.prototype.baseURI"></a>Node.prototype.baseURI</h4><p><code>baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当前网页的网址为</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;www.example.com&#x2F;index.html</span><br><span class="line">document.baseURI</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;www.example.com&#x2F;index.html&quot;</span><br></pre></td></tr></table></figure>

<p>如果无法读到网页的 URL，<code>baseURI</code>属性返回<code>null</code>。</p>
<p>该属性的值一般由当前网址的 URL（即<code>window.location</code>属性）决定，但是可以使用 HTML 的<code>base</code>标签，改变该属性的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&#x2F;page.html&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>设置了以后，<code>baseURI</code>属性就返回<code>base</code>标签设置的值。</p>
<h4 id="Node-prototype-ownerDocument"><a href="#Node-prototype-ownerDocument" class="headerlink" title="Node.prototype.ownerDocument"></a>Node.prototype.ownerDocument</h4><p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; p.ownerDocument;</span><br><span class="line">d &#x3D;&#x3D;&#x3D; document &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p>
<h4 id="Node-prototype-nextSibling"><a href="#Node-prototype-nextSibling" class="headerlink" title="Node.prototype.nextSibling"></a>Node.prototype.nextSibling</h4><p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;d1&quot;&gt;hello&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d2&quot;&gt;world&lt;&#x2F;div&gt;</span><br><span class="line">var d1 &#x3D; document.getElementById(&#39;d1&#39;);</span><br><span class="line">var d2 &#x3D; document.getElementById(&#39;d2&#39;);</span><br><span class="line"></span><br><span class="line">d1.nextSibling &#x3D;&#x3D;&#x3D; d2 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d1.nextSibling</code>就是紧跟在<code>d1</code>后面的同级节点<code>d2</code>。</p>
<p>注意，该属性还包括文本节点和注释节点（<code>&lt;!-- comment --&gt;</code>）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>
<p><code>nextSibling</code>属性可以用来遍历所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; document.getElementById(&#39;div1&#39;).firstChild;</span><br><span class="line"></span><br><span class="line">while (el !&#x3D;&#x3D; null) &#123;</span><br><span class="line">  console.log(el.nodeName);</span><br><span class="line">  el &#x3D; el.nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历<code>div1</code>节点的所有子节点。</p>
<h4 id="Node-prototype-previousSibling"><a href="#Node-prototype-previousSibling" class="headerlink" title="Node.prototype.previousSibling"></a>Node.prototype.previousSibling</h4><p><code>previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;d1&quot;&gt;hello&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;d2&quot;&gt;world&lt;&#x2F;div&gt;</span><br><span class="line">var d1 &#x3D; document.getElementById(&#39;d1&#39;);</span><br><span class="line">var d2 &#x3D; document.getElementById(&#39;d2&#39;);</span><br><span class="line"></span><br><span class="line">d2.previousSibling &#x3D;&#x3D;&#x3D; d1 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p>
<p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p>
<h4 id="Node-prototype-parentNode"><a href="#Node-prototype-parentNode" class="headerlink" title="Node.prototype.parentNode"></a>Node.prototype.parentNode</h4><p><code>parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (node.parentNode) &#123;</span><br><span class="line">  node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面移除。</p>
<p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</p>
<h4 id="Node-prototype-parentElement"><a href="#Node-prototype-parentElement" class="headerlink" title="Node.prototype.parentElement"></a>Node.prototype.parentElement</h4><p><code>parentElement</code>属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (node.parentElement) &#123;</span><br><span class="line">  node.parentElement.style.color &#x3D; &#39;red&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，父元素节点的样式设定了红色。</p>
<p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</p>
<h4 id="Node-prototype-firstChild-Node-prototype-lastChild"><a href="#Node-prototype-firstChild-Node-prototype-lastChild" class="headerlink" title="Node.prototype.firstChild,Node.prototype.lastChild"></a>Node.prototype.firstChild,Node.prototype.lastChild</h4><p><code>firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;p1&quot;&gt;&lt;span&gt;First span&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br><span class="line">var p1 &#x3D; document.getElementById(&#39;p1&#39;);</span><br><span class="line">p1.firstChild.nodeName &#x2F;&#x2F; &quot;SPAN&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素的第一个子节点是<code>span</code>元素。</p>
<p>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;p1&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;span&gt;First span&lt;&#x2F;span&gt;</span><br><span class="line">&#x2F;&#x2F;  &lt;&#x2F;p&gt;</span><br><span class="line">var p1 &#x3D; document.getElementById(&#39;p1&#39;);</span><br><span class="line">p1.firstChild.nodeName &#x2F;&#x2F; &quot;#text&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p>
<p><code>lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。</p>
<h4 id="Node-prototype-childNodes"><a href="#Node-prototype-childNodes" class="headerlink" title="Node.prototype.childNodes"></a>Node.prototype.childNodes</h4><p><code>childNodes</code>属性返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.querySelector(&#39;ul&#39;).childNodes;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p>
<p>使用该属性，可以遍历某个节点的所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line">var children &#x3D; div.childNodes;</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; children.length; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.childNodes;</span><br><span class="line">for (var i &#x3D; 0; i &lt; children.length; i++) &#123;</span><br><span class="line">  console.log(children[i].nodeType);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 10</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p>
<p>注意，除了元素节点，<code>childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p>
<h4 id="Node-prototype-isConnected"><a href="#Node-prototype-isConnected" class="headerlink" title="Node.prototype.isConnected"></a>Node.prototype.isConnected</h4><p><code>isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">test.isConnected &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">document.body.appendChild(test);</span><br><span class="line">test.isConnected &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Node-prototype-appendChild"><a href="#Node-prototype-appendChild" class="headerlink" title="Node.prototype.appendChild()"></a>Node.prototype.appendChild()</h4><p><code>appendChild()</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">document.body.appendChild(p);</span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>p</code>节点，将其插入<code>document.body</code>的尾部。</p>
<p>==如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">document.body.appendChild(div);</span><br></pre></td></tr></table></figure>

<p>上面代码中，插入的是一个已经存在的节点<code>myDiv</code>，结果就是该节点会从原来的位置，移动到<code>document.body</code>的尾部。</p>
<p>如果<code>appendChild()</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</p>
<h4 id="Node-prototype-hasChildNodes"><a href="#Node-prototype-hasChildNodes" class="headerlink" title="Node.prototype.hasChildNodes()"></a>Node.prototype.hasChildNodes()</h4><p><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; document.getElementById(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">if (foo.hasChildNodes()) &#123;</span><br><span class="line">  foo.removeChild(foo.childNodes[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p>
<p>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p>
<p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</p>
<ul>
<li><code>node.hasChildNodes()</code></li>
<li><code>node.firstChild !== null</code></li>
<li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li>
</ul>
<p><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以遍历当前节点的所有后代节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function DOMComb(parent, callback) &#123;</span><br><span class="line">  if (parent.hasChildNodes()) &#123;</span><br><span class="line">    for (var node &#x3D; parent.firstChild; node; node &#x3D; node.nextSibling) &#123;</span><br><span class="line">      DOMComb(node, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callback(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用法</span><br><span class="line">DOMComb(document.body, console.log)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>
<h4 id="Node-prototype-cloneNode"><a href="#Node-prototype-cloneNode" class="headerlink" title="Node.prototype.cloneNode()"></a>Node.prototype.cloneNode()</h4><p><code>cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cloneUL &#x3D; document.querySelector(&#39;ul&#39;).cloneNode(true);</span><br></pre></td></tr></table></figure>

<p>该方法有一些使用注意点。</p>
<p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>
<p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</p>
<p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=&quot;xxx&quot;</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</p>
<h4 id="Node-prototype-insertBefore"><a href="#Node-prototype-insertBefore" class="headerlink" title="Node.prototype.insertBefore()"></a>Node.prototype.insertBefore()</h4><p><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var insertedNode &#x3D; parentNode.insertBefore(newNode, referenceNode);</span><br></pre></td></tr></table></figure>

<p><code>insertBefore</code>方法接受两个参数，第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">document.body.insertBefore(p, document.body.firstChild);</span><br></pre></td></tr></table></figure>

<p>上面代码中，新建一个<code>p</code>节点，插在<code>document.body.firstChild</code>的前面，也就是成为<code>document.body</code>的第一个子节点。</p>
<p>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">document.body.insertBefore(p, null);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>将成为<code>document.body</code>的最后一个子节点。这也说明<code>insertBefore</code>的第二个参数不能省略。</p>
<p>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p>
<p>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.insertBefore(s1, s2.nextSibling);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</p>
<p>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</p>
<h4 id="Node-prototype-removeChild"><a href="#Node-prototype-removeChild" class="headerlink" title="Node.prototype.removeChild()"></a>Node.prototype.removeChild()</h4><p><code>removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var divA &#x3D; document.getElementById(&#39;A&#39;);</span><br><span class="line">divA.parentNode.removeChild(divA);</span><br></pre></td></tr></table></figure>

<p>上面代码移除了<code>divA</code>节点。注意，这个方法是在<code>divA</code>的父节点上调用的，不是在<code>divA</code>上调用的。</p>
<p>下面是如何移除当前节点的所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var element &#x3D; document.getElementById(&#39;top&#39;);</span><br><span class="line">while (element.firstChild) &#123;</span><br><span class="line">  element.removeChild(element.firstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>
<p>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</p>
<h4 id="Node-prototype-replaceChild"><a href="#Node-prototype-replaceChild" class="headerlink" title="Node.prototype.replaceChild()"></a>Node.prototype.replaceChild()</h4><p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var replacedNode &#x3D; parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var divA &#x3D; document.getElementById(&#39;divA&#39;);</span><br><span class="line">var newSpan &#x3D; document.createElement(&#39;span&#39;);</span><br><span class="line">newSpan.textContent &#x3D; &#39;Hello World!&#39;;</span><br><span class="line">divA.parentNode.replaceChild(newSpan, divA);</span><br></pre></td></tr></table></figure>

<p>上面代码是如何将指定节点<code>divA</code>替换走。</p>
<h4 id="Node-prototype-contains"><a href="#Node-prototype-contains" class="headerlink" title="Node.prototype.contains()"></a>Node.prototype.contains()</h4><p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p>
<ul>
<li>参数节点为当前节点。</li>
<li>参数节点为当前节点的子节点。</li>
<li>参数节点为当前节点的后代节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.contains(node)</span><br></pre></td></tr></table></figure>

<p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>
<p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeA.contains(nodeA) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="Node-prototype-compareDocumentPosition"><a href="#Node-prototype-compareDocumentPosition" class="headerlink" title="Node.prototype.compareDocumentPosition()"></a>Node.prototype.compareDocumentPosition()</h4><p><code>compareDocumentPosition</code>方法的用法，与<code>contains</code>方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</p>
<table>
<thead>
<tr>
<th align="left">二进制值</th>
<th align="left">十进制值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000000</td>
<td align="left">0</td>
<td align="left">两个节点相同</td>
</tr>
<tr>
<td align="left">000001</td>
<td align="left">1</td>
<td align="left">两个节点不在同一个文档（即有一个节点不在当前文档）</td>
</tr>
<tr>
<td align="left">000010</td>
<td align="left">2</td>
<td align="left">参数节点在当前节点的前面</td>
</tr>
<tr>
<td align="left">000100</td>
<td align="left">4</td>
<td align="left">参数节点在当前节点的后面</td>
</tr>
<tr>
<td align="left">001000</td>
<td align="left">8</td>
<td align="left">参数节点包含当前节点</td>
</tr>
<tr>
<td align="left">010000</td>
<td align="left">16</td>
<td align="left">当前节点包含参数节点</td>
</tr>
<tr>
<td align="left">100000</td>
<td align="left">32</td>
<td align="left">浏览器内部使用</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;mydiv&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;form&gt;&lt;input id&#x3D;&quot;test&quot; &#x2F;&gt;&lt;&#x2F;form&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">var input &#x3D; document.getElementById(&#39;test&#39;);</span><br><span class="line"></span><br><span class="line">div.compareDocumentPosition(input) &#x2F;&#x2F; 20</span><br><span class="line">input.compareDocumentPosition(div) &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<p>上面代码中，节点<code>div</code>包含节点<code>input</code>（二进制<code>010000</code>），而且节点<code>input</code>在节点<code>div</code>的后面（二进制<code>000100</code>），所以第一个<code>compareDocumentPosition</code>方法返回<code>20</code>（二进制<code>010100</code>，即<code>010000 + 000100</code>），第二个<code>compareDocumentPosition</code>方法返回<code>10</code>（二进制<code>001010</code>）。</p>
<p>由于<code>compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var head &#x3D; document.head;</span><br><span class="line">var body &#x3D; document.body;</span><br><span class="line">if (head.compareDocumentPosition(body) &amp; 4) &#123;</span><br><span class="line">  console.log(&#39;文档结构正确&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#39;&lt;body&gt; 不能在 &lt;head&gt; 前面&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>compareDocumentPosition</code>的返回值与<code>4</code>（又称掩码）进行与运算（<code>&amp;</code>），得到一个布尔值，表示<code>head</code>是否在<code>body</code>前面。</p>
<h4 id="Node-prototype-isEqualNode-Node-prototype-isSameNode"><a href="#Node-prototype-isEqualNode-Node-prototype-isSameNode" class="headerlink" title="Node.prototype.isEqualNode(),Node.prototype.isSameNode()"></a>Node.prototype.isEqualNode(),Node.prototype.isSameNode()</h4><p><code>isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">var p2 &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">p1.isEqualNode(p2) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">var p2 &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">p1.isSameNode(p2) &#x2F;&#x2F; false</span><br><span class="line">p1.isSameNode(p1) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="Node-prototype-normalize"><a href="#Node-prototype-normalize" class="headerlink" title="Node.prototype.normalize()"></a>Node.prototype.normalize()</h4><p><code>normalize</code>方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var wrapper &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line"></span><br><span class="line">wrapper.appendChild(document.createTextNode(&#39;Part 1 &#39;));</span><br><span class="line">wrapper.appendChild(document.createTextNode(&#39;Part 2 &#39;));</span><br><span class="line"></span><br><span class="line">wrapper.childNodes.length &#x2F;&#x2F; 2</span><br><span class="line">wrapper.normalize();</span><br><span class="line">wrapper.childNodes.length &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>normalize</code>方法之前，<code>wrapper</code>节点有两个毗邻的文本子节点。使用<code>normalize</code>方法之后，两个文本子节点被合并成一个。</p>
<p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p>
<h4 id="Node-prototype-getRootNode"><a href="#Node-prototype-getRootNode" class="headerlink" title="Node.prototype.getRootNode()"></a>Node.prototype.getRootNode()</h4><p><code>getRootNode()</code>方法返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.body.firstChild.getRootNode() &#x3D;&#x3D;&#x3D; document</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">document.body.firstChild.getRootNode() &#x3D;&#x3D;&#x3D; document.body.firstChild.ownerDocument</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>该方法可用于<code>document</code>节点自身，这一点与<code>document.ownerDocument</code>不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getRootNode() &#x2F;&#x2F; document</span><br><span class="line">document.ownerDocument &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<h2 id="NodeList接口，HTMLCollection接口"><a href="#NodeList接口，HTMLCollection接口" class="headerlink" title="NodeList接口，HTMLCollection接口"></a>NodeList接口，HTMLCollection接口</h2><p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：<code>NodeList</code>和<code>HTMLCollection</code>。</p>
<p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是<code>NodeList</code>实例或<code>HTMLCollection</code>实例。主要区别是，<code>NodeList</code>可以包含各种类型的节点，<code>HTMLCollection</code>只能包含 HTML 元素节点。</p>
<h3 id="NodeList接口"><a href="#NodeList接口" class="headerlink" title="NodeList接口"></a>NodeList接口</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><code>NodeList</code>实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到<code>NodeList</code>实例。</p>
<ul>
<li><code>Node.childNodes</code></li>
<li><code>document.querySelectorAll()</code>等节点搜索方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes instanceof NodeList &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>NodeList</code>实例很像数组，可以使用<code>length</code>属性和<code>forEach</code>方法。但是，它不是数组，不能使用<code>pop</code>或<code>push</code>之类数组特有的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.body.childNodes;</span><br><span class="line"></span><br><span class="line">Array.isArray(children) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">children.length &#x2F;&#x2F; 34</span><br><span class="line">children.forEach(console.log)</span><br></pre></td></tr></table></figure>

<p>上面代码中，NodeList 实例<code>children</code>不是数组，但是具有<code>length</code>属性和<code>forEach</code>方法。</p>
<p>如果<code>NodeList</code>实例要使用数组方法，可以将其转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.body.childNodes;</span><br><span class="line">var nodeArr &#x3D; Array.prototype.slice.call(children);</span><br></pre></td></tr></table></figure>

<p>除了使用<code>forEach</code>方法遍历 NodeList 实例，还可以使用<code>for</code>循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.body.childNodes;</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; children.length; i++) &#123;</span><br><span class="line">  var item &#x3D; children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有<code>Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.body.childNodes;</span><br><span class="line">children.length &#x2F;&#x2F; 18</span><br><span class="line">document.body.appendChild(document.createElement(&#39;p&#39;));</span><br><span class="line">children.length &#x2F;&#x2F; 19</span><br></pre></td></tr></table></figure>

<p>上面代码中，文档增加一个子节点，NodeList 实例<code>children</code>的<code>length</code>属性就增加了1。</p>
<h4 id="NodeList-prototype-length"><a href="#NodeList-prototype-length" class="headerlink" title="NodeList.prototype.length"></a>NodeList.prototype.length</h4><p><code>length</code>属性返回 NodeList 实例包含的节点数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.querySelectorAll(&#39;xxx&#39;).length</span><br><span class="line">&#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.querySelectorAll</code>返回一个 NodeList 集合。对于那些不存在的 HTML 标签，<code>length</code>属性返回<code>0</code>。</p>
<h4 id="NodeList-prototype-forEach"><a href="#NodeList-prototype-forEach" class="headerlink" title="NodeList.prototype.forEach()"></a>NodeList.prototype.forEach()</h4><p><code>forEach</code>方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code>forEach</code>方法完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.body.childNodes;</span><br><span class="line">children.forEach(function f(item, i, list) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;, this);</span><br></pre></td></tr></table></figure>

<p>上面代码中，回调函数<code>f</code>的三个参数依次是当前成员、位置和当前 NodeList 实例。<code>forEach</code>方法的第二个参数，用于绑定回调函数内部的<code>this</code>，该参数可省略。</p>
<h4 id="NodeList-prototype-item"><a href="#NodeList-prototype-item" class="headerlink" title="NodeList.prototype.item()"></a>NodeList.prototype.item()</h4><p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes.item(0)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>item(0)</code>返回第一个成员。</p>
<p>如果参数值大于实际长度，或者索引不合法（比如负数），<code>item</code>方法返回<code>null</code>。如果省略参数，<code>item</code>方法会报错。</p>
<p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用<code>item</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes[0]</span><br></pre></td></tr></table></figure>

<h4 id="NodeList-prototype-keys-NodeList-prototype-values-NodeList-prototype-entries"><a href="#NodeList-prototype-keys-NodeList-prototype-values-NodeList-prototype-entries" class="headerlink" title="NodeList.prototype.keys(),NodeList.prototype.values(),NodeList.prototype.entries()"></a>NodeList.prototype.keys(),NodeList.prototype.values(),NodeList.prototype.entries()</h4><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code>for...of</code>循环遍历获取每一个成员的信息。区别在于，<code>keys()</code>返回键名的遍历器，<code>values()</code>返回键值的遍历器，<code>entries()</code>返回的遍历器同时包含键名和键值的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var children &#x3D; document.body.childNodes;</span><br><span class="line"></span><br><span class="line">for (var key of children.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">for (var value of children.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; #text</span><br><span class="line">&#x2F;&#x2F; &lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">for (var entry of children.entries()) &#123;</span><br><span class="line">  console.log(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Array [ 0, #text ]</span><br><span class="line">&#x2F;&#x2F; Array [ 1, &lt;script&gt; ]</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure>

<h3 id="HTMLCollection接口"><a href="#HTMLCollection接口" class="headerlink" title="HTMLCollection接口"></a>HTMLCollection接口</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p><code>HTMLCollection</code>是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与<code>NodeList</code>接口不同，<code>HTMLCollection</code>没有<code>forEach</code>方法，只能使用<code>for</code>循环遍历。</p>
<p>返回<code>HTMLCollection</code>实例的，主要是一些<code>Document</code>对象的集合属性，比如<code>document.links</code>、<code>document.forms</code>、<code>document.images</code>等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.links instanceof HTMLCollection &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>HTMLCollection</code>实例都是动态集合，节点的变化会实时反映在集合中。</p>
<p>如果元素节点有<code>id</code>或<code>name</code>属性，那么<code>HTMLCollection</code>实例上面，可以使用<code>id</code>属性或<code>name</code>属性引用该节点元素。如果没有对应的节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;img id&#x3D;&quot;pic&quot; src&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;foo.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">var pic &#x3D; document.getElementById(&#39;pic&#39;);</span><br><span class="line">document.images.pic &#x3D;&#x3D;&#x3D; pic &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.images</code>是一个<code>HTMLCollection</code>实例，可以通过``元素的<code>id</code>属性值，从<code>HTMLCollection</code>实例上取到这个元素。</p>
<h4 id="HTMLCollection-prototype-length"><a href="#HTMLCollection-prototype-length" class="headerlink" title="HTMLCollection.prototype.length"></a>HTMLCollection.prototype.length</h4><p><code>length</code>属性返回<code>HTMLCollection</code>实例包含的成员数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.links.length &#x2F;&#x2F; 18</span><br></pre></td></tr></table></figure>

<h4 id="HTMLCollection-prototype-item"><a href="#HTMLCollection-prototype-item" class="headerlink" title="HTMLCollection.prototype.item()"></a>HTMLCollection.prototype.item()</h4><p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var c &#x3D; document.images;</span><br><span class="line">var img0 &#x3D; c.item(0);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>item(0)</code>表示返回0号位置的成员。由于方括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符。</p>
<p>如果参数值超出成员数量或者不合法（比如小于0），那么<code>item</code>方法返回<code>null</code>。</p>
<h4 id="HTMLCollection-prototype-namedItem"><a href="#HTMLCollection-prototype-namedItem" class="headerlink" title="HTMLCollection.prototype.namedItem()"></a>HTMLCollection.prototype.namedItem()</h4><p><code>namedItem</code>方法的参数是一个字符串，表示<code>id</code>属性或<code>name</code>属性的值，返回对应的元素节点。如果没有对应的节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;img id&#x3D;&quot;pic&quot; src&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;foo.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">var pic &#x3D; document.getElementById(&#39;pic&#39;);</span><br><span class="line">document.images.namedItem(&#39;pic&#39;) &#x3D;&#x3D;&#x3D; pic &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="ParentNode接口，ChildNode接口"><a href="#ParentNode接口，ChildNode接口" class="headerlink" title="ParentNode接口，ChildNode接口"></a>ParentNode接口，ChildNode接口</h2><p>节点对象除了继承 Node 接口以外，还拥有其他接口。<code>ParentNode</code>接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code>ChildNode</code>接口表示当前节点是一个子节点，提供一些相关方法。</p>
<h3 id="ParentNode接口"><a href="#ParentNode接口" class="headerlink" title="ParentNode接口"></a>ParentNode接口</h3><p>如果当前节点是父节点，就会混入了（mixin）<code>ParentNode</code>接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会拥有<code>ParentNode</code>接口。</p>
<h4 id="ParentNode-children"><a href="#ParentNode-children" class="headerlink" title="ParentNode.children"></a>ParentNode.children</h4><p><code>children</code>属性返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有元素子节点。该属性只读。</p>
<p>下面是遍历某个节点的所有元素子节点的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; el.children.length; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>children</code>属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值<code>HTMLCollection</code>实例的<code>length</code>属性为<code>0</code>。</p>
<p>另外，<code>HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</p>
<h4 id="ParentNode-firstElementChild"><a href="#ParentNode-firstElementChild" class="headerlink" title="ParentNode.firstElementChild"></a>ParentNode.firstElementChild</h4><p><code>firstElementChild</code>属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.firstElementChild.nodeName</span><br><span class="line">&#x2F;&#x2F; &quot;HTML&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document</code>节点的第一个元素子节点是``。</p>
<h4 id="ParentNode-lastElementChild"><a href="#ParentNode-lastElementChild" class="headerlink" title="ParentNode.lastElementChild"></a>ParentNode.lastElementChild</h4><p><code>lastElementChild</code>属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.lastElementChild.nodeName</span><br><span class="line">&#x2F;&#x2F; &quot;HTML&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document</code>节点的最后一个元素子节点是``（因为<code>document</code>只包含这一个元素子节点）。</p>
<h4 id="ParentNode-childElementCount"><a href="#ParentNode-childElementCount" class="headerlink" title="ParentNode.childElementCount"></a>ParentNode.childElementCount</h4><p><code>childElementCount</code>属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回<code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childElementCount &#x2F;&#x2F; 13</span><br></pre></td></tr></table></figure>

<h4 id="ParentNode-append-ParentNode-prepend"><a href="#ParentNode-append-ParentNode-prepend" class="headerlink" title="ParentNode.append(),ParentNode.prepend()"></a>ParentNode.append(),ParentNode.prepend()</h4><p><code>append</code>方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p>
<p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var parent &#x3D; document.body;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加元素子节点</span><br><span class="line">var p &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">parent.append(p);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加文本子节点</span><br><span class="line">parent.append(&#39;Hello&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加多个元素子节点</span><br><span class="line">var p1 &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">var p2 &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">parent.append(p1, p2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加元素子节点和文本子节点</span><br><span class="line">var p &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">parent.append(&#39;Hello&#39;, p);</span><br></pre></td></tr></table></figure>

<p>注意，该方法没有返回值。</p>
<p><code>prepend</code>方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与<code>append</code>方法完全一致，也是没有返回值。</p>
<h3 id="ChildNode接口"><a href="#ChildNode接口" class="headerlink" title="ChildNode接口"></a>ChildNode接口</h3><p>如果一个节点有父节点，那么该节点就拥有了<code>ChildNode</code>接口。</p>
<h4 id="ChildNode-remove"><a href="#ChildNode-remove" class="headerlink" title="ChildNode.remove()"></a>ChildNode.remove()</h4><p><code>remove</code>方法用于从父节点移除当前节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.remove()</span><br></pre></td></tr></table></figure>

<p>上面代码在 DOM 里面移除了<code>el</code>节点。</p>
<h4 id="ChildNode-before-ChildNode-after"><a href="#ChildNode-before-ChildNode-after" class="headerlink" title="ChildNode.before(),ChildNode.after()"></a>ChildNode.before(),ChildNode.after()</h4><p><code>before</code>方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p>
<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line">var p1 &#x3D; document.createElement(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入元素节点</span><br><span class="line">el.before(p);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入文本节点</span><br><span class="line">el.before(&#39;Hello&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入多个元素节点</span><br><span class="line">el.before(p, p1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入元素节点和文本节点</span><br><span class="line">el.before(p, &#39;Hello&#39;);</span><br></pre></td></tr></table></figure>

<p><code>after</code>方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与<code>before</code>方法完全相同。</p>
<h4 id="ChildNode-replaceWith"><a href="#ChildNode-replaceWith" class="headerlink" title="ChildNode.replaceWith()"></a>ChildNode.replaceWith()</h4><p><code>replaceWith</code>方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var span &#x3D; document.createElement(&#39;span&#39;);</span><br><span class="line">el.replaceWith(span);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>el</code>节点将被<code>span</code>节点替换。</p>
<h2 id="Document节点"><a href="#Document节点" class="headerlink" title="Document节点"></a>Document节点</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><code>document</code>节点对象代表整个文档，每张网页都有自己的<code>document</code>对象。<code>window.document</code>属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p>
<p><code>document</code>对象有不同的办法可以获取。</p>
<ul>
<li>正常的网页，直接使用<code>document</code>或<code>window.document</code>。</li>
<li><code>iframe</code>框架里面的网页，使用<code>iframe</code>节点的<code>contentDocument</code>属性。</li>
<li>Ajax 操作返回的文档，使用<code>XMLHttpRequest</code>对象的<code>responseXML</code>属性。</li>
<li>内部节点的<code>ownerDocument</code>属性。</li>
</ul>
<p><code>document</code>对象继承了<code>EventTarget</code>接口和<code>Node</code>接口，并且混入（mixin）了<code>ParentNode</code>接口。这意味着，这些接口的方法都可以在<code>document</code>对象上调用。除此之外，<code>document</code>对象还有很多自己的属性和方法。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><h4 id="快捷方式属性"><a href="#快捷方式属性" class="headerlink" title="快捷方式属性"></a>快捷方式属性</h4><p>以下属性是指向文档内部的某个节点的快捷方式。</p>
<p><strong>（1）document.defaultView</strong></p>
<p><code>document.defaultView</code>属性返回<code>document</code>对象所属的<code>window</code>对象。如果当前文档不属于<code>window</code>对象，该属性返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.defaultView &#x3D;&#x3D;&#x3D; window &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><strong>（2）document.doctype</strong></p>
<p>对于 HTML 文档来说，<code>document</code>对象一般有两个子节点。第一个子节点是<code>document.doctype</code>，指向<code>节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成</code>。如果网页没有声明 DTD，该属性返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var doctype &#x3D; document.doctype;</span><br><span class="line">doctype &#x2F;&#x2F; &quot;&lt;!DOCTYPE html&gt;&quot;</span><br><span class="line">doctype.name &#x2F;&#x2F; &quot;html&quot;</span><br></pre></td></tr></table></figure>

<p><code>document.firstChild</code>通常就返回这个节点。</p>
<p><strong>（3）document.documentElement</strong></p>
<p><code>document.documentElement</code>属性返回当前文档的根元素节点（root）。它通常是<code>document</code>节点的第二个子节点，紧跟在<code>document.doctype</code>节点后面。HTML网页的该属性，一般是``节点。</p>
<p><strong>（4）document.body，document.head</strong></p>
<p><code>document.body</code>属性指向<code>节点，`document.head`属性指向</code>节点。</p>
<p>这两个属性总是存在的，如果网页源码里面省略了<code>或</code>，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p>
<p><strong>（5）document.scrollingElement</strong></p>
<p><code>document.scrollingElement</code>属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p>
<p>标准模式下，这个属性返回的文档的根元素<code>document.documentElement</code>（即<code>）。兼容（quirk）模式下，返回的是</code>元素，如果该元素不存在，返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 页面滚动到浏览器顶部</span><br><span class="line">document.scrollingElement.scrollTop &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p><strong>（6）document.activeElement</strong></p>
<p><code>document.activeElement</code>属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是<code>、</code>、<code>等表单元素，如果当前没有焦点元素，返回</code>元素或<code>null</code>。</p>
<p><strong>（7）document.fullscreenElement</strong></p>
<p><code>document.fullscreenElement</code>属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (document.fullscreenElement.nodeName &#x3D;&#x3D; &#39;VIDEO&#39;) &#123;</span><br><span class="line">  console.log(&#39;全屏播放视频&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>document.fullscreenElement</code>可以知道``元素有没有处在全屏状态，从而判断用户行为。</p>
<h4 id="节点集合属性"><a href="#节点集合属性" class="headerlink" title="节点集合属性"></a>节点集合属性</h4><p>以下属性返回一个<code>HTMLCollection</code>实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p>
<p><strong>（1）document.links</strong></p>
<p><code>document.links</code>属性返回当前文档所有设定了<code>href</code>属性的<code>及</code>节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打印文档所有的链接</span><br><span class="line">var links &#x3D; document.links;</span><br><span class="line">for(var i &#x3D; 0; i &lt; links.length; i++) &#123;</span><br><span class="line">  console.log(links[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）document.forms</strong></p>
<p><code>document.forms</code>属性返回所有``表单节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selectForm &#x3D; document.forms[0];</span><br></pre></td></tr></table></figure>

<p>上面代码获取文档第一个表单。</p>
<p>除了使用位置序号，<code>id</code>属性和<code>name</code>属性也可以用来引用表单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line">  &lt;form name&#x3D;&quot;foo&quot; id&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line">document.forms[0] &#x3D;&#x3D;&#x3D; document.forms.foo &#x2F;&#x2F; true</span><br><span class="line">document.forms.bar &#x3D;&#x3D;&#x3D; document.forms.foo &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><strong>（3）document.images</strong></p>
<p><code>document.images</code>属性返回页面所有``图片节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var imglist &#x3D; document.images;</span><br><span class="line"></span><br><span class="line">for(var i &#x3D; 0; i &lt; imglist.length; i++) &#123;</span><br><span class="line">  if (imglist[i].src &#x3D;&#x3D;&#x3D; &#39;banner.gif&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码在所有<code>img</code>标签中，寻找某张图片。</p>
<p><strong>（4）document.embeds，document.plugins</strong></p>
<p><code>document.embeds</code>属性和<code>document.plugins</code>属性，都返回所有``节点。</p>
<p><strong>（5）document.scripts</strong></p>
<p><code>document.scripts</code>属性返回所有``节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var scripts &#x3D; document.scripts;</span><br><span class="line">if (scripts.length !&#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">  console.log(&#39;当前网页有脚本&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）document.styleSheets</strong></p>
<p><code>document.styleSheets</code>属性返回文档内嵌或引入的样式表集合，详细介绍请看《CSS 对象模型》一章。</p>
<p><strong>（7）小结</strong></p>
<p>除了<code>document.styleSheets</code>，以上的集合属性返回的都是<code>HTMLCollection</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.links instanceof HTMLCollection &#x2F;&#x2F; true</span><br><span class="line">document.images instanceof HTMLCollection &#x2F;&#x2F; true</span><br><span class="line">document.forms instanceof HTMLCollection &#x2F;&#x2F; true</span><br><span class="line">document.embeds instanceof HTMLCollection &#x2F;&#x2F; true</span><br><span class="line">document.scripts instanceof HTMLCollection &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>HTMLCollection</code>实例是类似数组的对象，所以这些属性都有<code>length</code>属性，都可以使用方括号运算符引用成员。如果成员有<code>id</code>或<code>name</code>属性，还可以用这两个属性的值，在<code>HTMLCollection</code>实例上引用到这个成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;form name&#x3D;&quot;myForm&quot;&gt;</span><br><span class="line">document.myForm &#x3D;&#x3D;&#x3D; document.forms.myForm &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="文档静态信息属性"><a href="#文档静态信息属性" class="headerlink" title="文档静态信息属性"></a>文档静态信息属性</h4><p>以下属性返回文档信息。</p>
<p><strong>（1）document.documentURI，document.URL</strong></p>
<p><code>document.documentURI</code>属性和<code>document.URL</code>属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code>documentURI</code>继承自<code>Document</code>接口，可用于所有文档；<code>URL</code>继承自<code>HTMLDocument</code>接口，只能用于 HTML 文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.URL</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;www.example.com&#x2F;about</span><br><span class="line"></span><br><span class="line">document.documentURI &#x3D;&#x3D;&#x3D; document.URL</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>如果文档的锚点（<code>#anchor</code>）变化，这两个属性都会跟着变化。</p>
<p><strong>（2）document.domain</strong></p>
<p><code>document.domain</code>属性返回当前文档的域名，不包含协议和端口。比如，网页的网址是<code>http://www.example.com:80/hello.html</code>，那么<code>document.domain</code>属性就等于<code>www.example.com</code>。如果无法获取域名，该属性返回<code>null</code>。</p>
<p><code>document.domain</code>基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把<code>document.domain</code>设为对应的上级域名。比如，当前域名是<code>a.sub.example.com</code>，则<code>document.domain</code>属性可以设置为<code>sub.example.com</code>，也可以设为<code>example.com</code>。修改后，<code>document.domain</code>相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p>
<p>另外，设置<code>document.domain</code>会导致端口被改成<code>null</code>。因此，如果通过设置<code>document.domain</code>来进行通信，双方网页都必须设置这个值，才能保证端口相同。</p>
<p><strong>（3）document.location</strong></p>
<p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>
<p>关于这个对象的详细介绍，请看《浏览器模型》部分的《Location 对象》章节。</p>
<p><strong>（4）document.lastModified</strong></p>
<p><code>document.lastModified</code>属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.lastModified</span><br><span class="line">&#x2F;&#x2F; &quot;03&#x2F;07&#x2F;2018 11:18:27&quot;</span><br></pre></td></tr></table></figure>

<p>注意，<code>document.lastModified</code>属性的值是字符串，所以不能直接用来比较。<code>Date.parse</code>方法将其转为<code>Date</code>实例，才能比较两个网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lastVisitedDate &#x3D; Date.parse(&#39;01&#x2F;01&#x2F;2018&#39;);</span><br><span class="line">if (Date.parse(document.lastModified) &gt; lastVisitedDate) &#123;</span><br><span class="line">  console.log(&#39;网页已经变更&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果页面上有 JavaScript 生成的内容，<code>document.lastModified</code>属性返回的总是当前时间。</p>
<p><strong>（5）document.title</strong></p>
<p><code>document.title</code>属性返回当前文档的标题。默认情况下，返回``节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.title &#x3D; &#39;新标题&#39;;</span><br><span class="line">document.title &#x2F;&#x2F; &quot;新标题&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（6）document.characterSet</strong></p>
<p><code>document.characterSet</code>属性返回当前文档的编码，比如<code>UTF-8</code>、<code>ISO-8859-1</code>等等。</p>
<p><strong>（7）document.referrer</strong></p>
<p><code>document.referrer</code>属性返回一个字符串，表示当前文档的访问者来自哪里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.referrer</span><br><span class="line">&#x2F;&#x2F; &quot;https:&#x2F;&#x2F;example.com&#x2F;path&quot;</span><br></pre></td></tr></table></figure>

<p>如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，<code>document.referrer</code>返回一个空字符串。</p>
<p><code>document.referrer</code>的值，总是与 HTTP 头信息的<code>Referer</code>字段保持一致。但是，<code>document.referrer</code>的拼写有两个<code>r</code>，而头信息的<code>Referer</code>字段只有一个<code>r</code>。</p>
<p><strong>（8）document.dir</strong></p>
<p><code>document.dir</code>返回一个字符串，表示文字方向。它只有两个可能的值：<code>rtl</code>表示文字从右到左，阿拉伯文是这种方式；<code>ltr</code>表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p>
<p><strong>（9）document.compatMode</strong></p>
<p><code>compatMode</code>属性返回浏览器处理文档的模式，可能的值为<code>BackCompat</code>（向后兼容模式）和<code>CSS1Compat</code>（严格模式）。</p>
<p>一般来说，如果网页代码的第一行设置了明确的<code>DOCTYPE</code>（比如``），<code>document.compatMode</code>的值都为<code>CSS1Compat</code>。</p>
<h4 id="文档状态属性"><a href="#文档状态属性" class="headerlink" title="文档状态属性"></a>文档状态属性</h4><p><strong>（1）document.hidden</strong></p>
<p><code>document.hidden</code>属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得<code>document.hidden</code>返回<code>true</code>。</p>
<p>这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。</p>
<p><strong>（2）document.visibilityState</strong></p>
<p><code>document.visibilityState</code>返回文档的可见状态。</p>
<p>它的值有四种可能。</p>
<blockquote>
<ul>
<li><code>visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li>
<li><code>hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li>
<li><code>prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li>
<li><code>unloaded</code>：页面从内存里面卸载了。</li>
</ul>
</blockquote>
<p>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</p>
<p><strong>（3）document.readyState</strong></p>
<p><code>document.readyState</code>属性返回当前文档的状态，共有三种可能的值。</p>
<ul>
<li><code>loading</code>：加载 HTML 代码阶段（尚未完成解析）</li>
<li><code>interactive</code>：加载外部资源阶段</li>
<li><code>complete</code>：加载完成</li>
</ul>
<p>这个属性变化的过程如下。</p>
<ol>
<li>浏览器开始解析 HTML 文档，<code>document.readyState</code>属性等于<code>loading</code>。</li>
<li>浏览器遇到 HTML 文档中的``元素，并且没有<code>async</code>或<code>defer</code>属性，就暂停解析，开始执行脚本，这时<code>document.readyState</code>属性还是等于<code>loading</code>。</li>
<li>HTML 文档解析完成，<code>document.readyState</code>属性变成<code>interactive</code>。</li>
<li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code>document.readyState</code>属性变成<code>complete</code>。</li>
</ol>
<p>下面的代码用来检查网页是否加载成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本检查</span><br><span class="line">if (document.readyState &#x3D;&#x3D;&#x3D; &#39;complete&#39;) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 轮询检查</span><br><span class="line">var interval &#x3D; setInterval(function() &#123;</span><br><span class="line">  if (document.readyState &#x3D;&#x3D;&#x3D; &#39;complete&#39;) &#123;</span><br><span class="line">    clearInterval(interval);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 100);</span><br></pre></td></tr></table></figure>

<p>另外，每次状态变化都会触发一个<code>readystatechange</code>事件。</p>
<h4 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h4><p><code>document.cookie</code>属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。</p>
<h4 id="document-designMode"><a href="#document-designMode" class="headerlink" title="document.designMode"></a>document.designMode</h4><p><code>document.designMode</code>属性控制当前文档是否可编辑。该属性只有两个值<code>on</code>和<code>off</code>，默认值为<code>off</code>。一旦设为<code>on</code>，用户就可以编辑整个文档的内容。</p>
<p>下面代码打开<code>iframe</code>元素内部文档的<code>designMode</code>属性，就能将其变为一个所见即所得的编辑器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;iframe id&#x3D;&quot;editor&quot; src&#x3D;&quot;about:blank&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">var editor &#x3D; document.getElementById(&#39;editor&#39;);</span><br><span class="line">editor.contentDocument.designMode &#x3D; &#39;on&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="document-currentScript"><a href="#document-currentScript" class="headerlink" title="document.currentScript"></a>document.currentScript</h4><p><code>document.currentScript</code>属性只用在<code>元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即</code>元素的 DOM 节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">  console.log(</span><br><span class="line">    document.currentScript &#x3D;&#x3D;&#x3D; document.getElementById(&#39;foo&#39;)</span><br><span class="line">  ); &#x2F;&#x2F; true</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.currentScript</code>就是``元素节点。</p>
<h4 id="document-implementation"><a href="#document-implementation" class="headerlink" title="document.implementation"></a>document.implementation</h4><p><code>document.implementation</code>属性返回一个<code>DOMImplementation</code>对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。</p>
<ul>
<li><code>DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li>
<li><code>DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li>
<li><code>DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li>
</ul>
<p>下面是创建 HTML 文档的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var doc &#x3D; document.implementation.createHTMLDocument(&#39;Title&#39;);</span><br><span class="line">var p &#x3D; doc.createElement(&#39;p&#39;);</span><br><span class="line">p.innerHTML &#x3D; &#39;hello world&#39;;</span><br><span class="line">doc.body.appendChild(p);</span><br><span class="line"></span><br><span class="line">document.replaceChild(</span><br><span class="line">  doc.documentElement,</span><br><span class="line">  document.documentElement</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一步生成一个新的 HTML 文档<code>doc</code>，然后用它的根元素<code>document.documentElement</code>替换掉<code>document.documentElement</code>。这会使得当前文档的内容全部消失，变成<code>hello world</code>。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="document-open-document-close"><a href="#document-open-document-close" class="headerlink" title="document.open(),document.close()"></a>document.open(),document.close()</h4><p><code>document.open</code>方法清除当前文档所有内容，使得文档处于可写状态，供<code>document.write</code>方法写入内容。</p>
<p><code>document.close</code>方法用来关闭<code>document.open()</code>打开的文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.open();</span><br><span class="line">document.write(&#39;hello world&#39;);</span><br><span class="line">document.close();</span><br></pre></td></tr></table></figure>

<h4 id="document-write-document-writeln"><a href="#document-write-document-writeln" class="headerlink" title="document.write(),document.writeln()"></a>document.write(),document.writeln()</h4><p><code>document.write</code>方法用于向当前文档写入内容。</p>
<p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行<code>document.close()</code>），<code>document.write</code>写入的内容就会追加在已有内容的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 页面显示“helloworld”</span><br><span class="line">document.open();</span><br><span class="line">document.write(&#39;hello&#39;);</span><br><span class="line">document.write(&#39;world&#39;);</span><br><span class="line">document.close();</span><br></pre></td></tr></table></figure>

<p>注意，<code>document.write</code>会当作 HTML 代码解析，不会转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(&#39;&lt;p&gt;hello world&lt;&#x2F;p&gt;&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.write</code>会将``当作 HTML 标签解释。</p>
<p>如果页面已经解析完成（<code>DOMContentLoaded</code>事件发生之后），再调用<code>write</code>方法，它会先调用<code>open</code>方法，擦除当前文档所有内容，然后再写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;DOMContentLoaded&#39;, function (event) &#123;</span><br><span class="line">  document.write(&#39;&lt;p&gt;Hello World!&lt;&#x2F;p&gt;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">document.addEventListener(&#39;DOMContentLoaded&#39;, function (event) &#123;</span><br><span class="line">  document.open();</span><br><span class="line">  document.write(&#39;&lt;p&gt;Hello World!&lt;&#x2F;p&gt;&#39;);</span><br><span class="line">  document.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果在页面渲染过程中调用<code>write</code>方法，并不会自动调用<code>open</code>方法。（可以理解成，<code>open</code>方法已调用，但<code>close</code>方法还未调用。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">hello</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  document.write(&quot;world&quot;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>在浏览器打开上面网页，将会显示<code>hello world</code>。</p>
<p><code>document.write</code>是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对<code>innerHTML</code>属性赋值）。所以，除了某些特殊情况，应该尽量避免使用<code>document.write</code>这个方法。</p>
<p><code>document.writeln</code>方法与<code>write</code>方法完全一致，除了会在输出内容的尾部添加换行符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.write(1);</span><br><span class="line">document.write(2);</span><br><span class="line">&#x2F;&#x2F; 12</span><br><span class="line"></span><br><span class="line">document.writeln(1);</span><br><span class="line">document.writeln(2);</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<p>注意，<code>writeln</code>方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<code></code>。</p>
<h4 id="document-querySelector-document-querySelectorAll"><a href="#document-querySelector-document-querySelectorAll" class="headerlink" title="document.querySelector(),document.querySelectorAll()"></a>document.querySelector(),document.querySelectorAll()</h4><p><code>document.querySelector</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el1 &#x3D; document.querySelector(&#39;.myclass&#39;);</span><br><span class="line">var el2 &#x3D; document.querySelector(&#39;#myParent &gt; [ng-click]&#39;);</span><br></pre></td></tr></table></figure>

<p><code>document.querySelectorAll</code>方法与<code>querySelector</code>用法类似，区别是返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementList &#x3D; document.querySelectorAll(&#39;.myclass&#39;);</span><br></pre></td></tr></table></figure>

<p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var matches &#x3D; document.querySelectorAll(&#39;div.note, div.alert&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码返回<code>class</code>属性是<code>note</code>或<code>alert</code>的<code>div</code>元素。</p>
<p>这两个方法都支持复杂的 CSS 选择器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 选中 data-foo-bar 属性等于 someval 的元素</span><br><span class="line">document.querySelectorAll(&#39;[data-foo-bar&#x3D;&quot;someval&quot;]&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选中 myForm 表单中所有不通过验证的元素</span><br><span class="line">document.querySelectorAll(&#39;#myForm :invalid&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选中div元素，那些 class 含 ignore 的除外</span><br><span class="line">document.querySelectorAll(&#39;DIV:not(.ignore)&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同时选中 div，a，script 三类元素</span><br><span class="line">document.querySelectorAll(&#39;DIV, A, SCRIPT&#39;);</span><br></pre></td></tr></table></figure>

<p>但是，它们不支持 CSS 伪元素的选择器（比如<code>:first-line</code>和<code>:first-letter</code>）和伪类的选择器（比如<code>:link</code>和<code>:visited</code>），即无法选中伪元素和伪类。</p>
<p>如果<code>querySelectorAll</code>方法的参数是字符串<code>*</code>，则会返回文档中的所有元素节点。另外，<code>querySelectorAll</code>的返回结果不是动态集合，不会实时反映元素节点的变化。</p>
<p>最后，这两个方法除了定义在<code>document</code>对象上，还定义在元素节点上，即在元素节点上也可以调用。</p>
<h4 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName()"></a>document.getElementsByTagName()</h4><p><code>document.getElementsByTagName</code>方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（<code>HTMLCollection</code>实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var paras &#x3D; document.getElementsByTagName(&#39;p&#39;);</span><br><span class="line">paras instanceof HTMLCollection &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码返回当前文档的所有<code>p</code>元素节点。</p>
<p>HTML 标签名是大小写不敏感的，因此<code>getElementsByTagName</code>方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p>
<p>如果传入<code>*</code>，就可以返回文档中所有 HTML 元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var allElements &#x3D; document.getElementsByTagName(&#39;*&#39;);</span><br></pre></td></tr></table></figure>

<p>注意，元素节点本身也定义了<code>getElementsByTagName</code>方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var firstPara &#x3D; document.getElementsByTagName(&#39;p&#39;)[0];</span><br><span class="line">var spans &#x3D; firstPara.getElementsByTagName(&#39;span&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码选中第一个<code>p</code>元素内部的所有<code>span</code>元素。</p>
<h4 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName()"></a>document.getElementsByClassName()</h4><p><code>document.getElementsByClassName</code>方法返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括了所有<code>class</code>名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements &#x3D; document.getElementsByClassName(names);</span><br></pre></td></tr></table></figure>

<p>由于<code>class</code>是保留字，所以 JavaScript 一律使用<code>className</code>表示 CSS 的<code>class</code>。</p>
<p>参数可以是多个<code>class</code>，它们之间使用空格分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements &#x3D; document.getElementsByClassName(&#39;foo bar&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码返回同时具有<code>foo</code>和<code>bar</code>两个<code>class</code>的元素，<code>foo</code>和<code>bar</code>的顺序不重要。</p>
<p>注意，正常模式下，CSS 的<code>class</code>是大小写敏感的。（<code>quirks mode</code>下，大小写不敏感。）</p>
<p>与<code>getElementsByTagName</code>方法一样，<code>getElementsByClassName</code>方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 非document对象上调用</span><br><span class="line">var elements &#x3D; rootElement.getElementsByClassName(names)</span><br></pre></td></tr></table></figure>

<h4 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName()"></a>document.getElementsByName()</h4><p><code>document.getElementsByName</code>方法用于选择拥有<code>name</code>属性的 HTML 元素（比如<code>、</code>、<code>、</code>、<code>和</code>等），返回一个类似数组的的对象（<code>NodeList</code>实例），因为<code>name</code>属性相同的元素可能不止一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 表单为 &lt;form name&#x3D;&quot;x&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line">var forms &#x3D; document.getElementsByName(&#39;x&#39;);</span><br><span class="line">forms[0].tagName &#x2F;&#x2F; &quot;FORM&quot;</span><br></pre></td></tr></table></figure>

<h4 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById()"></a>document.getElementById()</h4><p><code>document.getElementById</code>方法返回匹配指定<code>id</code>属性的元素节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elem &#x3D; document.getElementById(&#39;para1&#39;);</span><br></pre></td></tr></table></figure>

<p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的<code>id</code>属性是<code>main</code>，那么<code>document.getElementById(&#39;Main&#39;)</code>将返回<code>null</code>。</p>
<p><code>document.getElementById</code>方法与<code>document.querySelector</code>方法都能获取元素节点，不同之处是<code>document.querySelector</code>方法的参数使用 CSS 选择器语法，<code>document.getElementById</code>方法的参数是元素的<code>id</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;myElement&#39;)</span><br><span class="line">document.querySelector(&#39;#myElement&#39;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，两个方法都能选中<code>id</code>为<code>myElement</code>的元素，但是<code>document.getElementById()</code>比<code>document.querySelector()</code>效率高得多。</p>
<p>另外，这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用。</p>
<h4 id="document-elementFromPoint-document-elementsFromPoint"><a href="#document-elementFromPoint-document-elementsFromPoint" class="headerlink" title="document.elementFromPoint(),document.elementsFromPoint()"></a>document.elementFromPoint(),document.elementsFromPoint()</h4><p><code>document.elementFromPoint</code>方法返回位于页面指定位置最上层的元素节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var element &#x3D; document.elementFromPoint(50, 50);</span><br></pre></td></tr></table></figure>

<p>上面代码选中在<code>(50, 50)</code>这个坐标位置的最上层的那个 HTML 元素。</p>
<p><code>elementFromPoint</code>方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回<code>null</code>。</p>
<p><code>document.elementsFromPoint()</code>返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements &#x3D; document.elementsFromPoint(x, y);</span><br></pre></td></tr></table></figure>

<h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h4><p><code>document.createElement</code>方法用来生成元素节点，并返回该节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newDiv &#x3D; document.createElement(&#39;div&#39;);</span><br></pre></td></tr></table></figure>

<p><code>createElement</code>方法的参数为元素的标签名，即元素节点的<code>tagName</code>属性，对于 HTML 网页大小写不敏感，即参数为<code>div</code>或<code>DIV</code>返回的是同一种节点。如果参数里面包含尖括号（即<code>&lt;</code>和<code>&gt;</code>）会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.createElement(&#39;&lt;div&gt;&#39;);</span><br><span class="line">&#x2F;&#x2F; DOMException: The tag name provided (&#39;&lt;div&gt;&#39;) is not a valid name</span><br></pre></td></tr></table></figure>

<p>注意，<code>document.createElement</code>的参数可以是自定义的标签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.createElement(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h4><p><code>document.createTextNode</code>方法用来生成文本节点（<code>Text</code>实例），并返回该节点。它的参数是文本节点的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var newDiv &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">var newContent &#x3D; document.createTextNode(&#39;Hello&#39;);</span><br><span class="line">newDiv.appendChild(newContent);</span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>div</code>节点和一个文本节点，然后将文本节点插入<code>div</code>节点。</p>
<p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">div.appendChild(document.createTextNode(&#39;&lt;span&gt;Foo &amp; bar&lt;&#x2F;span&gt;&#39;));</span><br><span class="line">console.log(div.innerHTML)</span><br><span class="line">&#x2F;&#x2F; &lt;span&gt;Foo &amp; bar&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>createTextNode</code>方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p>
<p>需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function escapeHtml(str) &#123;</span><br><span class="line">  var div &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">  div.appendChild(document.createTextNode(str));</span><br><span class="line">  return div.innerHTML;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var userWebsite &#x3D; &#39;&quot; onmouseover&#x3D;&quot;alert(\&#39;derp\&#39;)&quot; &quot;&#39;;</span><br><span class="line">var profileLink &#x3D; &#39;&lt;a href&#x3D;&quot;&#39; + escapeHtml(userWebsite) + &#39;&quot;&gt;Bob&lt;&#x2F;a&gt;&#39;;</span><br><span class="line">var div &#x3D; document.getElementById(&#39;target&#39;);</span><br><span class="line">div.innerHTML &#x3D; profileLink;</span><br><span class="line">&#x2F;&#x2F; &lt;a href&#x3D;&quot;&quot; onmouseover&#x3D;&quot;alert(&#39;derp&#39;)&quot; &quot;&quot;&gt;Bob&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>createTextNode</code>方法不转义双引号，导致<code>onmouseover</code>方法被注入了代码。</p>
<h4 id="document-createAttribute"><a href="#document-createAttribute" class="headerlink" title="document.createAttribute()"></a>document.createAttribute()</h4><p><code>document.createAttribute</code>方法生成一个新的属性节点（<code>Attr</code>实例），并返回它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var attribute &#x3D; document.createAttribute(name);</span><br></pre></td></tr></table></figure>

<p><code>document.createAttribute</code>方法的参数<code>name</code>，是属性的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var node &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line"></span><br><span class="line">var a &#x3D; document.createAttribute(&#39;my_attrib&#39;);</span><br><span class="line">a.value &#x3D; &#39;newVal&#39;;</span><br><span class="line"></span><br><span class="line">node.setAttributeNode(a);</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">node.setAttribute(&#39;my_attrib&#39;, &#39;newVal&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码为<code>div1</code>节点，插入一个值为<code>newVal</code>的<code>my_attrib</code>属性。</p>
<h4 id="document-createComment"><a href="#document-createComment" class="headerlink" title="document.createComment()"></a>document.createComment()</h4><p><code>document.createComment</code>方法生成一个新的注释节点，并返回该节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var CommentNode &#x3D; document.createComment(data);</span><br></pre></td></tr></table></figure>

<p><code>document.createComment</code>方法的参数是一个字符串，会成为注释节点的内容。</p>
<h4 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h4><p><code>document.createDocumentFragment</code>方法生成一个空的文档片段对象（<code>DocumentFragment</code>实例）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var docFragment &#x3D; document.createDocumentFragment();</span><br></pre></td></tr></table></figure>

<p><code>DocumentFragment</code>是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为<code>DocumentFragment</code>不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var docfrag &#x3D; document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4].forEach(function (e) &#123;</span><br><span class="line">  var li &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">  li.textContent &#x3D; e;</span><br><span class="line">  docfrag.appendChild(li);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var element  &#x3D; document.getElementById(&#39;ul&#39;);</span><br><span class="line">element.appendChild(docfrag);</span><br></pre></td></tr></table></figure>

<p>上面代码中，文档片断<code>docfrag</code>包含四个``节点，这些子节点被一次性插入了当前文档。</p>
<h4 id="document-createEvent"><a href="#document-createEvent" class="headerlink" title="document.createEvent()"></a>document.createEvent()</h4><p><code>document.createEvent</code>方法生成一个事件对象（<code>Event</code>实例），该对象可以被<code>element.dispatchEvent</code>方法使用，触发指定事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var event &#x3D; document.createEvent(type);</span><br></pre></td></tr></table></figure>

<p><code>document.createEvent</code>方法的参数是事件类型，比如<code>UIEvents</code>、<code>MouseEvents</code>、<code>MutationEvents</code>、<code>HTMLEvents</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var event &#x3D; document.createEvent(&#39;Event&#39;);</span><br><span class="line">event.initEvent(&#39;build&#39;, true, true);</span><br><span class="line">document.addEventListener(&#39;build&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.type); &#x2F;&#x2F; &quot;build&quot;</span><br><span class="line">&#125;, false);</span><br><span class="line">document.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码新建了一个名为<code>build</code>的事件实例，然后触发该事件。</p>
<h4 id="document-addEventListener-document-removeEventListener-document-dispatchEvent"><a href="#document-addEventListener-document-removeEventListener-document-dispatchEvent" class="headerlink" title="document.addEventListener(),document.removeEventListener(),document.dispatchEvent()"></a>document.addEventListener(),document.removeEventListener(),document.dispatchEvent()</h4><p>这三个方法用于处理<code>document</code>节点的事件。它们都继承自<code>EventTarget</code>接口，详细介绍参见《EventTarget 接口》一章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加事件监听函数</span><br><span class="line">document.addEventListener(&#39;click&#39;, listener, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除事件监听函数</span><br><span class="line">document.removeEventListener(&#39;click&#39;, listener, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 触发事件</span><br><span class="line">var event &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">document.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<h4 id="document-hasFocus"><a href="#document-hasFocus" class="headerlink" title="document.hasFocus()"></a>document.hasFocus()</h4><p><code>document.hasFocus</code>方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var focused &#x3D; document.hasFocus();</span><br></pre></td></tr></table></figure>

<p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p>
<h4 id="document-adoptNode-document-importNode"><a href="#document-adoptNode-document-importNode" class="headerlink" title="document.adoptNode(),document.importNode()"></a>document.adoptNode(),document.importNode()</h4><p><code>document.adoptNode</code>方法将某个节点及其子节点，从原来所在的文档或<code>DocumentFragment</code>里面移除，归属当前<code>document</code>对象，返回插入后的新节点。插入的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var node &#x3D; document.adoptNode(externalNode);</span><br><span class="line">document.appendChild(node);</span><br></pre></td></tr></table></figure>

<p>注意，<code>document.adoptNode</code>方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用<code>appendChild</code>方法或<code>insertBefore</code>方法，将新节点插入当前文档树。</p>
<p><code>document.importNode</code>方法则是从原来所在的文档或<code>DocumentFragment</code>里面，拷贝某个节点及其子节点，让它们归属当前<code>document</code>对象。拷贝的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var node &#x3D; document.importNode(externalNode, deep);</span><br></pre></td></tr></table></figure>

<p><code>document.importNode</code>方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为<code>true</code>。</p>
<p>注意，<code>document.importNode</code>方法只是拷贝外部节点，这时该节点的父节点是<code>null</code>。下一步还必须将这个节点插入当前文档树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var iframe &#x3D; document.getElementsByTagName(&#39;iframe&#39;)[0];</span><br><span class="line">var oldNode &#x3D; iframe.contentWindow.document.getElementById(&#39;myNode&#39;);</span><br><span class="line">var newNode &#x3D; document.importNode(oldNode, true);</span><br><span class="line">document.getElementById(&quot;container&quot;).appendChild(newNode);</span><br></pre></td></tr></table></figure>

<p>上面代码从<code>iframe</code>窗口，拷贝一个指定节点<code>myNode</code>，插入当前文档。</p>
<h4 id="document-createNodeIterator"><a href="#document-createNodeIterator" class="headerlink" title="document.createNodeIterator()"></a>document.createNodeIterator()</h4><p><code>document.createNodeIterator</code>方法返回一个子节点遍历器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var nodeIterator &#x3D; document.createNodeIterator(</span><br><span class="line">  document.body,</span><br><span class="line">  NodeFilter.SHOW_ELEMENT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码返回``元素子节点的遍历器。</p>
<p><code>document.createNodeIterator</code>方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（<code>NodeFilter.SHOW_ELEMENT</code>）。几种主要的节点类型写法如下。</p>
<ul>
<li>所有节点：NodeFilter.SHOW_ALL</li>
<li>元素节点：NodeFilter.SHOW_ELEMENT</li>
<li>文本节点：NodeFilter.SHOW_TEXT</li>
<li>评论节点：NodeFilter.SHOW_COMMENT</li>
</ul>
<p><code>document.createNodeIterator</code>方法返回一个“遍历器”对象（<code>NodeFilter</code>实例）。该实例的<code>nextNode()</code>方法和<code>previousNode()</code>方法，可以用来遍历所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var nodeIterator &#x3D; document.createNodeIterator(document.body);</span><br><span class="line">var pars &#x3D; [];</span><br><span class="line">var currentNode;</span><br><span class="line"></span><br><span class="line">while (currentNode &#x3D; nodeIterator.nextNode()) &#123;</span><br><span class="line">  pars.push(currentNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用遍历器的<code>nextNode</code>方法，将根节点的所有子节点，依次读入一个数组。<code>nextNode</code>方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回<code>null</code>。<code>previousNode</code>方法则是先将指针移向上一个节点，然后返回该节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var nodeIterator &#x3D; document.createNodeIterator(</span><br><span class="line">  document.body,</span><br><span class="line">  NodeFilter.SHOW_ELEMENT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var currentNode &#x3D; nodeIterator.nextNode();</span><br><span class="line">var previousNode &#x3D; nodeIterator.previousNode();</span><br><span class="line"></span><br><span class="line">currentNode &#x3D;&#x3D;&#x3D; previousNode &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>currentNode</code>和<code>previousNode</code>都指向同一个的节点。</p>
<p>注意，遍历器返回的第一个节点，总是根节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pars[0] &#x3D;&#x3D;&#x3D; document.body &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="document-createTreeWalker"><a href="#document-createTreeWalker" class="headerlink" title="document.createTreeWalker()"></a>document.createTreeWalker()</h4><p><code>document.createTreeWalker</code>方法返回一个 DOM 的子树遍历器。它与<code>document.createNodeIterator</code>方法基本是类似的，区别在于它返回的是<code>TreeWalker</code>实例，后者返回的是<code>NodeIterator</code>实例。另外，它的第一个节点不是根节点。</p>
<p><code>document.createTreeWalker</code>方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与<code>document.createNodeIterator</code>方法的第二个参数相同）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var treeWalker &#x3D; document.createTreeWalker(</span><br><span class="line">  document.body,</span><br><span class="line">  NodeFilter.SHOW_ELEMENT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var nodeList &#x3D; [];</span><br><span class="line"></span><br><span class="line">while(treeWalker.nextNode()) &#123;</span><br><span class="line">  nodeList.push(treeWalker.currentNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历``节点下属的所有元素节点，将它们插入<code>nodeList</code>数组。</p>
<h4 id="document-execCommand-document-queryCommandSupported-document-queryCommandEnabled"><a href="#document-execCommand-document-queryCommandSupported-document-queryCommandEnabled" class="headerlink" title="document.execCommand(),document.queryCommandSupported(),document.queryCommandEnabled()"></a>document.execCommand(),document.queryCommandSupported(),document.queryCommandEnabled()</h4><p><strong>（1）document.execCommand()</strong></p>
<p>如果<code>document.designMode</code>属性设为<code>on</code>，那么整个文档用户可编辑；如果元素的<code>contenteditable</code>属性设为<code>true</code>，那么该元素可编辑。这两种情况下，可以使用<code>document.execCommand()</code>方法，改变内容的样式，比如<code>document.execCommand(&#39;bold&#39;)</code>会使得字体加粗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.execCommand(command, showDefaultUI, input)</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>command</code>：字符串，表示所要实施的样式。</li>
<li><code>showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为<code>false</code>。</li>
<li><code>input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为<code>true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; window.prompt(&#39;请输入网址&#39;);</span><br><span class="line"></span><br><span class="line">if (url) &#123;</span><br><span class="line">  document.execCommand(&#39;createlink&#39;, false, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先提示用户输入所要链接的网址，然后手动生成超级链接。注意，第二个参数是<code>false</code>，表示此时不需要自动弹出提示框。</p>
<p><code>document.execCommand()</code>的返回值是一个布尔值。如果为<code>false</code>，表示这个方法无法生效。</p>
<p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p>
<p><code>document.execCommand()</code>方法可以执行的样式改变有很多种，下面是其中的一些：bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo。这些值都可以用作第一个参数，它们的含义不难从字面上看出来。</p>
<p><strong>（2）document.queryCommandSupported()</strong></p>
<p><code>document.queryCommandSupported()</code>方法返回一个布尔值，表示浏览器是否支持<code>document.execCommand()</code>的某个命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (document.queryCommandSupported(&#39;SelectAll&#39;)) &#123;</span><br><span class="line">  console.log(&#39;浏览器支持选中可编辑区域的所有内容&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）document.queryCommandEnabled()</strong></p>
<p><code>document.queryCommandEnabled()</code>方法返回一个布尔值，表示当前是否可用<code>document.execCommand()</code>的某个命令。比如，<code>bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;Copy&quot; onclick&#x3D;&quot;doCopy()&quot;&gt;</span><br><span class="line"></span><br><span class="line">function doCopy()&#123;</span><br><span class="line">  &#x2F;&#x2F; 浏览器是否支持 copy 命令（选中内容复制到剪贴板）</span><br><span class="line">  if (document.queryCommandSupported(&#39;copy&#39;)) &#123;</span><br><span class="line">    copyText(&#39;你好&#39;);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    console.log(&#39;浏览器不支持&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyText(text) &#123;</span><br><span class="line">  var input &#x3D; document.createElement(&#39;textarea&#39;);</span><br><span class="line">  document.body.appendChild(input);</span><br><span class="line">  input.value &#x3D; text;</span><br><span class="line">  input.focus();</span><br><span class="line">  input.select();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前是否有选中文字</span><br><span class="line">  if (document.queryCommandEnabled(&#39;copy&#39;)) &#123;</span><br><span class="line">    var success &#x3D; document.execCommand(&#39;copy&#39;);</span><br><span class="line">    input.remove();</span><br><span class="line">    console.log(&#39;Copy Ok&#39;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;queryCommandEnabled is false&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先判断浏览器是否支持<code>copy</code>命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p>
<h4 id="document-getSelection"><a href="#document-getSelection" class="headerlink" title="document.getSelection()"></a>document.getSelection()</h4><p>这个方法指向<code>window.getSelection()</code>，参见<code>window</code>对象一节的介绍。</p>
<h2 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Element</code>节点对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个<code>Element</code>节点对象（以下简称元素节点）。</p>
<p>元素节点的<code>nodeType</code>属性都是<code>1</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line">p.nodeName &#x2F;&#x2F; &quot;P&quot;</span><br><span class="line">p.nodeType &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p><code>Element</code>对象继承了<code>Node</code>接口，因此<code>Node</code>的属性和方法在<code>Element</code>对象都存在。</p>
<p>此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如<code>元素的构造函数是`HTMLAnchorElement()`，</code>是<code>HTMLButtonElement()</code>。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承<code>Element</code>对象的属性和方法，还有各自独有的属性和方法。</p>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><h4 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="headerlink" title="元素特性的相关属性"></a>元素特性的相关属性</h4><p><strong>（1）Element.id</strong></p>
<p><code>Element.id</code>属性返回指定元素的<code>id</code>属性，该属性可读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为 &lt;p id&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line">p.id &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>

<p>注意，<code>id</code>属性的值是大小写敏感，即浏览器能正确识别<code>和</code>这两个元素的<code>id</code>属性，但是最好不要这样命名。</p>
<p><strong>（2）Element.tagName</strong></p>
<p><code>Element.tagName</code>属性返回指定元素的大写标签名，与<code>nodeName</code>属性的值相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML代码为</span><br><span class="line">&#x2F;&#x2F; &lt;span id&#x3D;&quot;myspan&quot;&gt;Hello&lt;&#x2F;span&gt;</span><br><span class="line">var span &#x3D; document.getElementById(&#39;myspan&#39;);</span><br><span class="line">span.id &#x2F;&#x2F; &quot;myspan&quot;</span><br><span class="line">span.tagName &#x2F;&#x2F; &quot;SPAN&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（3）Element.dir</strong></p>
<p><code>Element.dir</code>属性用于读写当前元素的文字方向，可能是从左到右（<code>&quot;ltr&quot;</code>），也可能是从右到左（<code>&quot;rtl&quot;</code>）。</p>
<p><strong>（4）Element.accessKey</strong></p>
<p><code>Element.accessKey</code>属性用于读写分配给当前元素的快捷键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;button accesskey&#x3D;&quot;h&quot; id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">var btn &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">btn.accessKey &#x2F;&#x2F; &quot;h&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>btn</code>元素的快捷键是<code>h</code>，按下<code>Alt + h</code>就能将焦点转移到它上面。</p>
<p><strong>（5）Element.draggable</strong></p>
<p><code>Element.draggable</code>属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p>
<p><strong>（6）Element.lang</strong></p>
<p><code>Element.lang</code>属性返回当前元素的语言设置。该属性可读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">document.documentElement.lang &#x2F;&#x2F; &quot;en&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（7）Element.tabIndex</strong></p>
<p><code>Element.tabIndex</code>属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p>
<p><code>tabIndex</code>属性值如果是负值（通常是<code>-1</code>），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的<code>tabIndex</code>属性的正整数值相同，则按照出现的顺序遍历。遍历完所有<code>tabIndex</code>为正整数的元素以后，再遍历所有<code>tabIndex</code>等于<code>0</code>、或者属性值是非法值、或者没有<code>tabIndex</code>属性的元素，顺序为它们在网页中出现的顺序。</p>
<p><strong>（8）Element.title</strong></p>
<p><code>Element.title</code>属性用来读写当前元素的 HTML 属性<code>title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p>
<h4 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="headerlink" title="元素状态的相关属性"></a>元素状态的相关属性</h4><p><strong>（1）Element.hidden</strong></p>
<p><code>Element.hidden</code>属性返回一个布尔值，表示当前元素的<code>hidden</code>属性，用来控制当前元素是否可见。该属性可读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var btn &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">  mydiv.hidden &#x3D; !mydiv.hidden;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，<code>Element.hidden</code>并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p>
<p>CSS 的设置高于<code>Element.hidden</code>。如果 CSS 指定了该元素不可见（<code>display: none</code>）或可见（<code>display: hidden</code>），那么<code>Element.hidden</code>并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p>
<p><strong>（2）Element.contentEditable，Element.isContentEditable</strong></p>
<p>HTML 元素可以设置<code>contentEditable</code>属性，使得元素的内容可以编辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div contenteditable&gt;123&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，``元素有<code>contenteditable</code>属性，因此用户可以在网页上编辑这个区块的内容。</p>
<p><code>Element.contentEditable</code>属性返回一个字符串，表示是否设置了<code>contenteditable</code>属性，有三种可能的值。该属性可写。</p>
<ul>
<li><code>&quot;true&quot;</code>：元素内容可编辑</li>
<li><code>&quot;false&quot;</code>：元素内容不可编辑</li>
<li><code>&quot;inherit&quot;</code>：元素是否可编辑，继承了父元素的设置</li>
</ul>
<p><code>Element.isContentEditable</code>属性返回一个布尔值，同样表示是否设置了<code>contenteditable</code>属性。该属性只读。</p>
<h4 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h4><p><code>Element.attributes</code>属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点，详见《属性的操作》一章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line">var attrs &#x3D; p.attributes;</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; attrs.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">  console.log(attrs[i].name + &#39;-&gt;&#39; + attrs[i].value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历<code>p</code>元素的所有属性。</p>
<h4 id="Element-className-Element-classList"><a href="#Element-className-Element-classList" class="headerlink" title="Element.className,Element.classList"></a>Element.className,Element.classList</h4><p><code>className</code>属性用来读写当前元素节点的<code>class</code>属性。它的值是一个字符串，每个<code>class</code>之间用空格分割。</p>
<p><code>classList</code>属性返回一个类似数组的对象，当前元素节点的每个<code>class</code>就是这个对象的一个成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码 &lt;div class&#x3D;&quot;one two three&quot; id&#x3D;&quot;myDiv&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line"></span><br><span class="line">div.className</span><br><span class="line">&#x2F;&#x2F; &quot;one two three&quot;</span><br><span class="line"></span><br><span class="line">div.classList</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   0: &quot;one&quot;</span><br><span class="line">&#x2F;&#x2F;   1: &quot;two&quot;</span><br><span class="line">&#x2F;&#x2F;   2: &quot;three&quot;</span><br><span class="line">&#x2F;&#x2F;   length: 3</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>className</code>属性返回一个空格分隔的字符串，而<code>classList</code>属性指向一个类似数组的对象，该对象的<code>length</code>属性（只读）返回当前元素的<code>class</code>数量。</p>
<p><code>classList</code>对象有下列方法。</p>
<ul>
<li><code>add()</code>：增加一个 class。</li>
<li><code>remove()</code>：移除一个 class。</li>
<li><code>contains()</code>：检查当前元素是否包含某个 class。</li>
<li><code>toggle()</code>：将某个 class 移入或移出当前元素。</li>
<li><code>item()</code>：返回指定索引位置的 class。</li>
<li><code>toString()</code>：将 class 的列表转为字符串。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line"></span><br><span class="line">div.classList.add(&#39;myCssClass&#39;);</span><br><span class="line">div.classList.add(&#39;foo&#39;, &#39;bar&#39;);</span><br><span class="line">div.classList.remove(&#39;myCssClass&#39;);</span><br><span class="line">div.classList.toggle(&#39;myCssClass&#39;); &#x2F;&#x2F; 如果 myCssClass 不存在就加入，否则移除</span><br><span class="line">div.classList.contains(&#39;myCssClass&#39;); &#x2F;&#x2F; 返回 true 或者 false</span><br><span class="line">div.classList.item(0); &#x2F;&#x2F; 返回第一个 Class</span><br><span class="line">div.classList.toString();</span><br></pre></td></tr></table></figure>

<p>下面比较一下，<code>className</code>和<code>classList</code>在添加和删除某个 class 时的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; document.getElementById(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加class</span><br><span class="line">foo.className +&#x3D; &#39;bold&#39;;</span><br><span class="line">foo.classList.add(&#39;bold&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除class</span><br><span class="line">foo.classList.remove(&#39;bold&#39;);</span><br><span class="line">foo.className &#x3D; foo.className.replace(&#x2F;^bold$&#x2F;, &#39;&#39;);</span><br></pre></td></tr></table></figure>

<p><code>toggle</code>方法可以接受一个布尔值，作为第二个参数。如果为<code>true</code>，则添加该属性；如果为<code>false</code>，则去除该属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">el.classList.toggle(&#39;abc&#39;, boolValue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">if (boolValue) &#123;</span><br><span class="line">  el.classList.add(&#39;abc&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  el.classList.remove(&#39;abc&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Element-dataset"><a href="#Element-dataset" class="headerlink" title="Element.dataset"></a>Element.dataset</h4><p>网页元素可以自定义<code>data-</code>属性，用来添加数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-timestamp&#x3D;&quot;1522907809292&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，``元素有一个自定义的<code>data-timestamp</code>属性，用来为该元素添加一个时间戳。</p>
<p><code>Element.dataset</code>属性返回一个对象，可以从这个对象读写<code>data-</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &lt;article</span><br><span class="line">&#x2F;&#x2F;   id&#x3D;&quot;foo&quot;</span><br><span class="line">&#x2F;&#x2F;   data-columns&#x3D;&quot;3&quot;</span><br><span class="line">&#x2F;&#x2F;   data-index-number&#x3D;&quot;12314&quot;</span><br><span class="line">&#x2F;&#x2F;   data-parent&#x3D;&quot;cars&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   ...</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;article&gt;</span><br><span class="line">var article &#x3D; document.getElementById(&#39;foo&#39;);</span><br><span class="line">article.dataset.columns &#x2F;&#x2F; &quot;3&quot;</span><br><span class="line">article.dataset.indexNumber &#x2F;&#x2F; &quot;12314&quot;</span><br><span class="line">article.dataset.parent &#x2F;&#x2F; &quot;cars&quot;</span><br></pre></td></tr></table></figure>

<p>注意，<code>dataset</code>上面的各个属性返回都是字符串。</p>
<p>HTML 代码中，<code>data-</code>属性的属性名，只能包含英文字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>）。它们转成 JavaScript 对应的<code>dataset</code>属性名，规则如下。</p>
<ul>
<li>开头的<code>data-</code>会省略。</li>
<li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li>
<li>其他字符不变。</li>
</ul>
<p>因此，<code>data-abc-def</code>对应<code>dataset.abcDef</code>，<code>data-abc-1</code>对应<code>dataset[&quot;abc-1&quot;]</code>。</p>
<p>除了使用<code>dataset</code>读写<code>data-</code>属性，也可以使用<code>Element.getAttribute()</code>和<code>Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line"></span><br><span class="line">mydiv.dataset.foo &#x3D; &#39;bar&#39;;</span><br><span class="line">mydiv.getAttribute(&#39;data-foo&#39;) &#x2F;&#x2F; &quot;bar&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Element-innerHTML"><a href="#Element-innerHTML" class="headerlink" title="Element.innerHTML"></a>Element.innerHTML</h4><p><code>Element.innerHTML</code>属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<code>和</code>元素。</p>
<p>如果将<code>innerHTML</code>属性设为空，等于删除所有它包含的所有节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.innerHTML &#x3D; &#39;&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码等于将<code>el</code>节点变成了一个空节点，<code>el</code>原来包含的节点被全部删除。</p>
<p>注意，读取属性值的时候，如果文本节点包含<code>&amp;</code>、小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），<code>innerHTML</code>属性会将它们转为实体形式<code>&amp;</code>、<code>&lt;</code>、<code>&gt;</code>。如果想得到原文，建议使用<code>element.textContent</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML代码如下 &lt;p id&#x3D;&quot;para&quot;&gt; 5 &gt; 3 &lt;&#x2F;p&gt;</span><br><span class="line">document.getElementById(&#39;para&#39;).innerHTML</span><br><span class="line">&#x2F;&#x2F; 5 &gt; 3</span><br></pre></td></tr></table></figure>

<p>写入的时候，如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有``标签，虽然可以生成<code>script</code>节点，但是插入的代码不会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;&lt;script&gt;alert(&#39;haha&#39;)&lt;&#x2F;script&gt;&quot;;</span><br><span class="line">el.innerHTML &#x3D; name;</span><br></pre></td></tr></table></figure>

<p>上面代码将脚本插入内容，脚本并不会执行。但是，<code>innerHTML</code>还是有安全风险的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;&lt;img src&#x3D;x onerror&#x3D;alert(1)&gt;&quot;;</span><br><span class="line">el.innerHTML &#x3D; name;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>alert</code>方法是会执行的。因此为了安全考虑，如果插入的是文本，最好用<code>textContent</code>属性代替<code>innerHTML</code>。</p>
<h4 id="Element-outerHTML"><a href="#Element-outerHTML" class="headerlink" title="Element.outerHTML"></a>Element.outerHTML</h4><p><code>Element.outerHTML</code>属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;d&quot;&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var d &#x3D; document.getElementById(&#39;d&#39;);</span><br><span class="line">d.outerHTML</span><br><span class="line">&#x2F;&#x2F; &#39;&lt;div id&#x3D;&quot;d&quot;&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#39;</span><br></pre></td></tr></table></figure>

<p><code>outerHTML</code>属性是可读写的，对它进行赋值，等于替换掉当前元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;container&quot;&gt;&lt;div id&#x3D;&quot;d&quot;&gt;Hello&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var container &#x3D; document.getElementById(&#39;container&#39;);</span><br><span class="line">var d &#x3D; document.getElementById(&#39;d&#39;);</span><br><span class="line">container.firstChild.nodeName &#x2F;&#x2F; &quot;DIV&quot;</span><br><span class="line">d.nodeName &#x2F;&#x2F; &quot;DIV&quot;</span><br><span class="line"></span><br><span class="line">d.outerHTML &#x3D; &#39;&lt;p&gt;Hello&lt;&#x2F;p&gt;&#39;;</span><br><span class="line">container.firstChild.nodeName &#x2F;&#x2F; &quot;P&quot;</span><br><span class="line">d.nodeName &#x2F;&#x2F; &quot;DIV&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>d</code>代表子节点，它的<code>outerHTML</code>属性重新赋值以后，内层的<code>div</code>元素就不存在了，被<code>p</code>元素替换了。但是，变量<code>d</code>依然指向原来的<code>div</code>元素，这表示被替换的<code>DIV</code>元素还存在于内存中。</p>
<p>注意，如果一个节点没有父节点，设置<code>outerHTML</code>属性会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">div.outerHTML &#x3D; &#39;&lt;p&gt;test&lt;&#x2F;p&gt;&#39;;</span><br><span class="line">&#x2F;&#x2F; DOMException: This element has no parent node.</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>元素没有父节点，设置<code>outerHTML</code>属性会报错。</p>
<h4 id="Element-clientHeight-Element-clientWidth"><a href="#Element-clientHeight-Element-clientWidth" class="headerlink" title="Element.clientHeight,Element.clientWidth"></a>Element.clientHeight,Element.clientWidth</h4><p><code>Element.clientHeight</code>属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回<code>0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p>
<p>除了元素本身的高度，它还包括<code>padding</code>部分，但是不包括<code>border</code>、<code>margin</code>。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p>
<p><code>Element.clientWidth</code>属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和<code>padding</code>，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p>
<p><code>document.documentElement</code>的<code>clientHeight</code>属性，返回当前视口的高度（即浏览器窗口的高度），等同于<code>window.innerHeight</code>属性减去水平滚动条的高度（如果有的话）。<code>document.body</code>的高度则是网页的实际高度。一般来说，<code>document.body.clientHeight</code>大于<code>document.documentElement.clientHeight</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 视口高度</span><br><span class="line">document.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 网页总高度</span><br><span class="line">document.body.clientHeight</span><br></pre></td></tr></table></figure>

<h4 id="Element-clientLeft-Element-clientTop"><a href="#Element-clientLeft-Element-clientTop" class="headerlink" title="Element.clientLeft,Element.clientTop"></a>Element.clientLeft,Element.clientTop</h4><p><code>Element.clientLeft</code>属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的<code>padding</code>和<code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回<code>0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</p>
<p><code>Element.clientTop</code>属性等于网页元素顶部边框的宽度（单位像素），其他特点都与<code>clientLeft</code>相同。</p>
<h4 id="Element-scrollHeight-Element-scrollWidth"><a href="#Element-scrollHeight-Element-scrollWidth" class="headerlink" title="Element.scrollHeight,Element.scrollWidth"></a>Element.scrollHeight,Element.scrollWidth</h4><p><code>Element.scrollHeight</code>属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括<code>padding</code>，但是不包括<code>border</code>、<code>margin</code>以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code>或<code>::after</code>）的高度。</p>
<p><code>Element.scrollWidth</code>属性表示当前元素的总宽度（单位像素），其他地方都与<code>scrollHeight</code>属性类似。这两个属性只读。</p>
<p>整张网页的总高度可以从<code>document.documentElement</code>或<code>document.body</code>上读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回网页的总高度</span><br><span class="line">document.documentElement.scrollHeight</span><br><span class="line">document.body.scrollHeight</span><br></pre></td></tr></table></figure>

<p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，<code>scrollHeight</code>属性仍然返回元素的总高度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;height: 200px; overflow: hidden;&quot;&gt;...&lt;div&gt;</span><br><span class="line">document.getElementById(&#39;myDiv&#39;).scrollHeight &#x2F;&#x2F; 356</span><br></pre></td></tr></table></figure>

<p>上面代码中，即使<code>myDiv</code>元素的 CSS 高度只有200像素，且溢出部分不可见，但是<code>scrollHeight</code>仍然会返回该元素的原始高度。</p>
<h4 id="Element-scrollLeft-Element-scrollTop"><a href="#Element-scrollLeft-Element-scrollTop" class="headerlink" title="Element.scrollLeft,Element.scrollTop"></a>Element.scrollLeft,Element.scrollTop</h4><p><code>Element.scrollLeft</code>属性表示当前元素的水平滚动条向右侧滚动的像素数量，<code>Element.scrollTop</code>属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p>
<p>如果要查看整张网页的水平的和垂直的滚动距离，要从<code>document.documentElement</code>元素上读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.scrollLeft</span><br><span class="line">document.documentElement.scrollTop</span><br></pre></td></tr></table></figure>

<p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p>
<h4 id="Element-offsetParent"><a href="#Element-offsetParent" class="headerlink" title="Element.offsetParent"></a>Element.offsetParent</h4><p><code>Element.offsetParent</code>属性返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;position: absolute;&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;span&gt;Hello&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性就是<code>div</code>元素。</p>
<p>该属性主要用于确定子元素位置偏移的计算基准，<code>Element.offsetTop</code>和<code>Element.offsetLeft</code>就是<code>offsetParent</code>元素计算的。</p>
<p>如果该元素是不可见的（<code>display</code>属性为<code>none</code>），或者位置是固定的（<code>position</code>属性为<code>fixed</code>），则<code>offsetParent</code>属性返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;position: absolute;&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;span style&#x3D;&quot;display: none;&quot;&gt;Hello&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性是<code>null</code>。</p>
<p>如果某个元素的所有上层节点的<code>position</code>属性都是<code>static</code>，则<code>Element.offsetParent</code>属性指向``元素。</p>
<h4 id="Element-offsetHeight-Element-offsetWidth"><a href="#Element-offsetHeight-Element-offsetWidth" class="headerlink" title="Element.offsetHeight,Element.offsetWidth"></a>Element.offsetHeight,Element.offsetWidth</h4><p><code>Element.offsetHeight</code>属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。</p>
<p><code>Element.offsetWidth</code>属性表示元素的 CSS 水平宽度（单位像素），其他都与<code>Element.offsetHeight</code>一致。</p>
<p>这两个属性都是只读属性，只比<code>Element.clientHeight</code>和<code>Element.clientWidth</code>多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如<code>display: none;</code>），则返回<code>0</code>。</p>
<h4 id="Element-offsetLeft-Element-offsetTop"><a href="#Element-offsetLeft-Element-offsetTop" class="headerlink" title="Element.offsetLeft,Element.offsetTop"></a>Element.offsetLeft,Element.offsetTop</h4><p><code>Element.offsetLeft</code>返回当前元素左上角相对于<code>Element.offsetParent</code>节点的水平位移，<code>Element.offsetTop</code>返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。</p>
<p>下面的代码可以算出元素左上角相对于整张网页的坐标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getElementPosition(e) &#123;</span><br><span class="line">  var x &#x3D; 0;</span><br><span class="line">  var y &#x3D; 0;</span><br><span class="line">  while (e !&#x3D;&#x3D; null)  &#123;</span><br><span class="line">    x +&#x3D; e.offsetLeft;</span><br><span class="line">    y +&#x3D; e.offsetTop;</span><br><span class="line">    e &#x3D; e.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;x: x, y: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Element-style"><a href="#Element-style" class="headerlink" title="Element.style"></a>Element.style</h4><p>每个元素节点都有<code>style</code>用来读写该元素的行内样式信息，具体介绍参见《CSS 操作》一章。</p>
<h4 id="Element-children-Element-childElementCount"><a href="#Element-children-Element-childElementCount" class="headerlink" title="Element.children,Element.childElementCount"></a>Element.children,Element.childElementCount</h4><p><code>Element.children</code>属性返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (para.children.length) &#123;</span><br><span class="line">  var children &#x3D; para.children;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码遍历了<code>para</code>元素的所有子元素。</p>
<p>这个属性与<code>Node.childNodes</code>属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p>
<p><code>Element.childElementCount</code>属性返回当前元素节点包含的子元素节点的个数，与<code>Element.children.length</code>的值相同。</p>
<h4 id="Element-firstElementChild-Element-lastElementChild"><a href="#Element-firstElementChild-Element-lastElementChild" class="headerlink" title="Element.firstElementChild,Element.lastElementChild"></a>Element.firstElementChild,Element.lastElementChild</h4><p><code>Element.firstElementChild</code>属性返回当前元素的第一个元素子节点，<code>Element.lastElementChild</code>返回最后一个元素子节点。</p>
<p>如果没有元素子节点，这两个属性返回<code>null</code>。</p>
<h4 id="Element-nextElementSibling-Element-previousElementSibling"><a href="#Element-nextElementSibling-Element-previousElementSibling" class="headerlink" title="Element.nextElementSibling,Element.previousElementSibling"></a>Element.nextElementSibling,Element.previousElementSibling</h4><p><code>Element.nextElementSibling</code>属性返回当前元素节点的后一个同级元素节点，如果没有则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;div-01&quot;&gt;Here is div-01&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;div-02&quot;&gt;Here is div-02&lt;&#x2F;div&gt;</span><br><span class="line">var el &#x3D; document.getElementById(&#39;div-01&#39;);</span><br><span class="line">el.nextElementSibling</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;div-02&quot;&gt;Here is div-02&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p><code>Element.previousElementSibling</code>属性返回当前元素节点的前一个同级元素节点，如果没有则返回<code>null</code>。</p>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="属性相关方法"><a href="#属性相关方法" class="headerlink" title="属性相关方法"></a>属性相关方法</h4><p>元素节点提供六个方法，用来操作属性。</p>
<ul>
<li><code>getAttribute()</code>：读取某个属性的值</li>
<li><code>getAttributeNames()</code>：返回当前元素的所有属性名</li>
<li><code>setAttribute()</code>：写入属性值</li>
<li><code>hasAttribute()</code>：某个属性是否存在</li>
<li><code>hasAttributes()</code>：当前元素是否有属性</li>
<li><code>removeAttribute()</code>：删除属性</li>
</ul>
<p>这些方法的介绍请看《属性的操作》一章。</p>
<h4 id="Element-querySelector"><a href="#Element-querySelector" class="headerlink" title="Element.querySelector()"></a>Element.querySelector()</h4><p><code>Element.querySelector</code>方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var content &#x3D; document.getElementById(&#39;content&#39;);</span><br><span class="line">var el &#x3D; content.querySelector(&#39;p&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码返回<code>content</code>节点的第一个<code>p</code>元素。</p>
<p><code>Element.querySelector</code>方法可以接受任何复杂的 CSS 选择器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.querySelector(&quot;style[type&#x3D;&#39;text&#x2F;css&#39;], style:not([type])&quot;);</span><br></pre></td></tr></table></figure>

<p>注意，这个方法无法选中伪元素。</p>
<p>它可以接受多个选择器，它们之间使用逗号分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.querySelector(&#39;div, p&#39;)</span><br></pre></td></tr></table></figure>

<p>上面代码返回<code>element</code>的第一个<code>div</code>或<code>p</code>子元素。</p>
<p>需要注意的是，浏览器执行<code>querySelector</code>方法时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;blockquote id&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;inner&quot;&gt;</span><br><span class="line">    &lt;p&gt;World&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;blockquote&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>那么，像下面这样查询的话，实际上返回的是第一个<code>p</code>元素，而不是第二个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var outer &#x3D; document.getElementById(&#39;outer&#39;);</span><br><span class="line">outer.querySelector(&#39;div p&#39;)</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Element-querySelectorAll"><a href="#Element-querySelectorAll" class="headerlink" title="Element.querySelectorAll()"></a>Element.querySelectorAll()</h4><p><code>Element.querySelectorAll</code>方法接受 CSS 选择器作为参数，返回一个<code>NodeList</code>实例，包含所有匹配的子元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; document.querySelector(&#39;#test&#39;);</span><br><span class="line">var matches &#x3D; el.querySelectorAll(&#39;div.highlighted &gt; p&#39;);</span><br></pre></td></tr></table></figure>

<p>该方法的执行机制与<code>querySelector</code>方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p>
<p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的<code>NodeList</code>实例。</p>
<h4 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h4><p><code>Element.getElementsByClassName</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.getElementsByClassName(&#39;red test&#39;);</span><br></pre></td></tr></table></figure>

<p>注意，该方法的参数大小写敏感。</p>
<p>由于<code>HTMLCollection</code>实例是一个活的集合，<code>document</code>对象的任何变化会立刻反应到实例，下面的代码不会生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p class&#x3D;&quot;foo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p class&#x3D;&quot;foo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line">var element &#x3D; document.getElementById(&#39;example&#39;);</span><br><span class="line">var matches &#x3D; element.getElementsByClassName(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i&lt; matches.length; i++) &#123;</span><br><span class="line">  matches[i].classList.remove(&#39;foo&#39;);</span><br><span class="line">  matches.item(i).classList.add(&#39;bar&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 执行后，HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p class&#x3D;&quot;foo bar&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>matches</code>集合的第一个成员，一旦被拿掉 class 里面的<code>foo</code>，就会立刻从<code>matches</code>里面消失，导致出现上面的结果。</p>
<h4 id="Element-getElementsByTagName"><a href="#Element-getElementsByTagName" class="headerlink" title="Element.getElementsByTagName()"></a>Element.getElementsByTagName()</h4><p><code>Element.getElementsByTagName</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var table &#x3D; document.getElementById(&#39;forecast-table&#39;);</span><br><span class="line">var cells &#x3D; table.getElementsByTagName(&#39;td&#39;);</span><br></pre></td></tr></table></figure>

<p>注意，该方法的参数是大小写不敏感的。</p>
<h4 id="Element-closest"><a href="#Element-closest" class="headerlink" title="Element.closest()"></a>Element.closest()</h4><p><code>Element.closest</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;article&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;div id&#x3D;&quot;div-01&quot;&gt;Here is div-01</span><br><span class="line">&#x2F;&#x2F;     &lt;div id&#x3D;&quot;div-02&quot;&gt;Here is div-02</span><br><span class="line">&#x2F;&#x2F;       &lt;div id&#x3D;&quot;div-03&quot;&gt;Here is div-03&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F;     &lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">var div03 &#x3D; document.getElementById(&#39;div-03&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; div-03 最近的祖先节点</span><br><span class="line">div03.closest(&quot;#div-02&quot;) &#x2F;&#x2F; div-02</span><br><span class="line">div03.closest(&quot;div div&quot;) &#x2F;&#x2F; div-03</span><br><span class="line">div03.closest(&quot;article &gt; div&quot;) &#x2F;&#x2F;div-01</span><br><span class="line">div03.closest(&quot;:not(div)&quot;) &#x2F;&#x2F; article</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>closest</code>方法将当前节点也考虑在内，所以第二个<code>closest</code>方法返回<code>div-03</code>。</p>
<h4 id="Element-matches"><a href="#Element-matches" class="headerlink" title="Element.matches()"></a>Element.matches()</h4><p><code>Element.matches</code>方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (el.matches(&#39;.someClass&#39;)) &#123;</span><br><span class="line">  console.log(&#39;Match!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件相关方法"><a href="#事件相关方法" class="headerlink" title="事件相关方法"></a>事件相关方法</h4><p>以下三个方法与<code>Element</code>节点的事件相关。这些方法都继承自<code>EventTarget</code>接口，详见相关章节。</p>
<ul>
<li><code>Element.addEventListener()</code>：添加事件的回调函数</li>
<li><code>Element.removeEventListener()</code>：移除事件监听函数</li>
<li><code>Element.dispatchEvent()</code>：触发事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#39;click&#39;, listener, false);</span><br><span class="line">element.removeEventListener(&#39;click&#39;, listener, false);</span><br><span class="line"></span><br><span class="line">var event &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">element.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<h4 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="Element.scrollIntoView()"></a>Element.scrollIntoView()</h4><p><code>Element.scrollIntoView</code>方法滚动当前元素，进入浏览器的可见区域，类似于设置<code>window.location.hash</code>的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.scrollIntoView(); &#x2F;&#x2F; 等同于el.scrollIntoView(true)</span><br><span class="line">el.scrollIntoView(false);</span><br></pre></td></tr></table></figure>

<p>该方法可以接受一个布尔值作为参数。如果为<code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为<code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为<code>true</code>。</p>
<h4 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h4><p><code>Element.getBoundingClientRect</code>方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var rect &#x3D; obj.getBoundingClientRect();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getBoundingClientRect</code>方法返回的<code>rect</code>对象，具有以下属性（全部为只读）。</p>
<ul>
<li><code>x</code>：元素左上角相对于视口的横坐标</li>
<li><code>y</code>：元素左上角相对于视口的纵坐标</li>
<li><code>height</code>：元素高度</li>
<li><code>width</code>：元素宽度</li>
<li><code>left</code>：元素左上角相对于视口的横坐标，与<code>x</code>属性相等</li>
<li><code>right</code>：元素右边界相对于视口的横坐标（等于<code>x + width</code>）</li>
<li><code>top</code>：元素顶部相对于视口的纵坐标，与<code>y</code>属性相等</li>
<li><code>bottom</code>：元素底部相对于视口的纵坐标（等于<code>y + height</code>）</li>
</ul>
<p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将<code>left</code>属性加上<code>window.scrollX</code>，<code>top</code>属性加上<code>window.scrollY</code>。</p>
<p>注意，<code>getBoundingClientRect</code>方法的所有属性，都把边框（<code>border</code>属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code>width</code>和<code>height</code>包括了元素本身 + <code>padding</code> + <code>border</code>。</p>
<p>另外，上面的这些属性，都是继承自原型的属性，<code>Object.keys</code>会返回一个空数组，这一点也需要注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var rect &#x3D; document.body.getBoundingClientRect();</span><br><span class="line">Object.keys(rect) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>rect</code>对象没有自身属性，而<code>Object.keys</code>方法只返回对象自身的属性，所以返回了一个空数组。</p>
<h4 id="Element-getClientRects"><a href="#Element-getClientRects" class="headerlink" title="Element.getClientRects()"></a>Element.getClientRects()</h4><p><code>Element.getClientRects</code>方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的<code>Rect</code>用的是复数）。每个矩形都有<code>bottom</code>、<code>height</code>、<code>left</code>、<code>right</code>、<code>top</code>和<code>width</code>六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p>
<p>对于盒状元素（比如<code>和</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如<code>、</code>、``），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和<code>Element.getBoundingClientRect()</code>方法的主要区别，后者对于行内元素总是返回一个矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id&#x3D;&quot;inline&quot;&gt;Hello World Hello World Hello World&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码是一个行内元素``，如果它在页面上占据三行，<code>getClientRects</code>方法返回的对象就有三个成员，如果它在页面上占据一行，<code>getClientRects</code>方法返回的对象就只有一个成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; document.getElementById(&#39;inline&#39;);</span><br><span class="line">el.getClientRects().length &#x2F;&#x2F; 3</span><br><span class="line">el.getClientRects()[0].left &#x2F;&#x2F; 8</span><br><span class="line">el.getClientRects()[0].right &#x2F;&#x2F; 113.908203125</span><br><span class="line">el.getClientRects()[0].bottom &#x2F;&#x2F; 31.200000762939453</span><br><span class="line">el.getClientRects()[0].height &#x2F;&#x2F; 23.200000762939453</span><br><span class="line">el.getClientRects()[0].width &#x2F;&#x2F; 105.908203125</span><br></pre></td></tr></table></figure>

<p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p>
<p>注意，如果行内元素包括换行符，那么该方法会把换行符考虑在内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id&#x3D;&quot;inline&quot;&gt;</span><br><span class="line">  Hello World</span><br><span class="line">  Hello World</span><br><span class="line">  Hello World</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>节点内部有三个换行符，即使 HTML 语言忽略换行符，将它们显示为一行，`getClientRects()`方法依然会返回三个成员。如果行宽设置得特别窄，上面的</code>元素显示为6行，那么就会返回六个成员。</p>
<h4 id="Element-insertAdjacentElement"><a href="#Element-insertAdjacentElement" class="headerlink" title="Element.insertAdjacentElement()"></a>Element.insertAdjacentElement()</h4><p><code>Element.insertAdjacentElement</code>方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.insertAdjacentElement(position, element);</span><br></pre></td></tr></table></figure>

<p><code>Element.insertAdjacentElement</code>方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后</li>
</ul>
<p>注意，<code>beforebegin</code>和<code>afterend</code>这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; document.createElement(&#39;p&#39;)</span><br><span class="line">var p2 &#x3D; document.createElement(&#39;p&#39;)</span><br><span class="line">p1.insertAdjacentElement(&#39;afterend&#39;, p2) &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>没有父节点，所以插入<code>p2</code>到它后面就失败了。</p>
<p>如果插入的节点是一个文档里现有的节点，它会从原有位置删除，放置到新的位置。</p>
<h4 id="Element-insertAdjacentHTML-Element-insertAdjacentText"><a href="#Element-insertAdjacentHTML-Element-insertAdjacentText" class="headerlink" title="Element.insertAdjacentHTML(),Element.insertAdjacentText()"></a>Element.insertAdjacentHTML(),Element.insertAdjacentText()</h4><p><code>Element.insertAdjacentHTML</code>方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.insertAdjacentHTML(position, text);</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码：&lt;div id&#x3D;&quot;one&quot;&gt;one&lt;&#x2F;div&gt;</span><br><span class="line">var d1 &#x3D; document.getElementById(&#39;one&#39;);</span><br><span class="line">d1.insertAdjacentHTML(&#39;afterend&#39;, &#39;&lt;div id&#x3D;&quot;two&quot;&gt;two&lt;&#x2F;div&gt;&#39;);</span><br><span class="line">&#x2F;&#x2F; 执行后的 HTML 代码：</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;one&quot;&gt;one&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;two&quot;&gt;two&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比<code>innerHTML</code>方法快得多。</p>
<p>注意，该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p>
<p><code>Element.insertAdjacentText</code>方法在相对于当前节点的指定位置，插入一个文本节点，用法与<code>Element.insertAdjacentHTML</code>方法完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码：&lt;div id&#x3D;&quot;one&quot;&gt;one&lt;&#x2F;div&gt;</span><br><span class="line">var d1 &#x3D; document.getElementById(&#39;one&#39;);</span><br><span class="line">d1.insertAdjacentText(&#39;afterend&#39;, &#39;two&#39;);</span><br><span class="line">&#x2F;&#x2F; 执行后的 HTML 代码：</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;one&quot;&gt;one&lt;&#x2F;div&gt;two</span><br></pre></td></tr></table></figure>

<h4 id="Element-remove"><a href="#Element-remove" class="headerlink" title="Element.remove()"></a>Element.remove()</h4><p><code>Element.remove</code>方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">el.remove();</span><br></pre></td></tr></table></figure>

<p>上面代码将<code>el</code>节点从 DOM 树里面移除。</p>
<h4 id="Element-focus-Element-blur"><a href="#Element-focus-Element-blur" class="headerlink" title="Element.focus(),Element.blur()"></a>Element.focus(),Element.blur()</h4><p><code>Element.focus</code>方法用于将当前页面的焦点，转移到指定元素上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;my-span&#39;).focus();</span><br></pre></td></tr></table></figure>

<p>该方法可以接受一个对象作为参数。参数对象的<code>preventScroll</code>属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getFocus() &#123;</span><br><span class="line">  document.getElementById(&#39;btn&#39;).focus(&#123;preventScroll:false&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会让<code>btn</code>元素获得焦点，并滚动到可见区域。</p>
<p>最后，从<code>document.activeElement</code>属性可以得到当前获得焦点的元素。</p>
<p><code>Element.blur</code>方法用于将焦点从当前元素移除。</p>
<h4 id="Element-click"><a href="#Element-click" class="headerlink" title="Element.click()"></a>Element.click()</h4><p><code>Element.click</code>方法用于在当前元素上模拟一次鼠标点击，相当于触发了<code>click</code>事件。</p>
<h2 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h2><p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id&#x3D;&quot;test&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&quot;&gt;</span><br><span class="line">  链接</span><br><span class="line">&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>元素包括两个属性：<code>id</code>属性和<code>href</code>属性。</p>
<p>属性本身是一个对象（<code>Attr</code>对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（<code>HTMlElement</code>对象）来操作属性。本章介绍如何操作这些属性。</p>
<h3 id="Element-attributes属性"><a href="#Element-attributes属性" class="headerlink" title="Element.attributes属性"></a>Element.attributes属性</h3><p>元素对象有一个<code>attributes</code>属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有<code>attributes</code>属性，但返回的都是<code>null</code>，因此可以把这个属性视为元素对象独有的。</p>
<p>单个属性可以通过序号引用，也可以通过属性名引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;body bgcolor&#x3D;&quot;yellow&quot; onload&#x3D;&quot;&quot;&gt;</span><br><span class="line">document.body.attributes[0]</span><br><span class="line">document.body.attributes.bgcolor</span><br><span class="line">document.body.attributes[&#39;ONLOAD&#39;]</span><br></pre></td></tr></table></figure>

<p>注意，上面代码的三种方法，返回的都是属性节点对象，而不是属性值。</p>
<p>属性节点对象有<code>name</code>和<code>value</code>属性，对应该属性的属性名和属性值，等同于<code>nodeName</code>属性和<code>nodeValue</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;mydiv&quot;&gt;</span><br><span class="line">var n &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line"></span><br><span class="line">n.attributes[0].name &#x2F;&#x2F; &quot;id&quot;</span><br><span class="line">n.attributes[0].nodeName &#x2F;&#x2F; &quot;id&quot;</span><br><span class="line"></span><br><span class="line">n.attributes[0].value &#x2F;&#x2F; &quot;mydiv&quot;</span><br><span class="line">n.attributes[0].nodeValue &#x2F;&#x2F; &quot;mydiv&quot;</span><br></pre></td></tr></table></figure>

<p>下面代码可以遍历一个元素节点的所有属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var para &#x3D; document.getElementsByTagName(&#39;p&#39;)[0];</span><br><span class="line">var result &#x3D; document.getElementById(&#39;result&#39;);</span><br><span class="line"></span><br><span class="line">if (para.hasAttributes()) &#123;</span><br><span class="line">  var attrs &#x3D; para.attributes;</span><br><span class="line">  var output &#x3D; &#39;&#39;;</span><br><span class="line">  for(var i &#x3D; attrs.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    output +&#x3D; attrs[i].name + &#39;-&gt;&#39; + attrs[i].value;</span><br><span class="line">  &#125;</span><br><span class="line">  result.textContent &#x3D; output;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  result.textContent &#x3D; &#39;No attributes to show&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素的标准属性"><a href="#元素的标准属性" class="headerlink" title="元素的标准属性"></a>元素的标准属性</h3><p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; document.getElementById(&#39;test&#39;);</span><br><span class="line">a.id &#x2F;&#x2F; &quot;test&quot;</span><br><span class="line">a.href &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;www.example.com&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>元素标签的属性<code>id</code>和<code>href</code>，自动成为节点对象的属性。</p>
<p>这些属性都是可写的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var img &#x3D; document.getElementById(&#39;myImage&#39;);</span><br><span class="line">img.src &#x3D; &#39;http:&#x2F;&#x2F;www.example.com&#x2F;image.jpg&#39;;</span><br></pre></td></tr></table></figure>

<p>上面的写法，会立刻替换掉<code>img</code>对象的<code>src</code>属性，即会显示另外一张图片。</p>
<p>这种修改属性的方法，常常用于添加表单的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; document.forms[0];</span><br><span class="line">f.action &#x3D; &#39;submit.php&#39;;</span><br><span class="line">f.method &#x3D; &#39;POST&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码为表单添加提交网址和提交方法。</p>
<p>注意，这种用法虽然可以读写属性，但是无法删除属性，<code>delete</code>运算符在这里不会生效。</p>
<p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如<code>onClick</code>。</p>
<p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名。主要是以下两个。</p>
<ul>
<li><code>for</code>属性改为<code>htmlFor</code></li>
<li><code>class</code>属性改为<code>className</code></li>
</ul>
<p>另外，HTML 属性值一般都是字符串，但是 JavaScript 属性会自动转换类型。比如，将字符串<code>true</code>转为布尔值，将<code>onClick</code>的值转为一个函数，将<code>style</code>属性的值转为一个<code>CSSStyleDeclaration</code>对象。因此，可以对这些属性赋予各种类型的值。</p>
<h3 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="headerlink" title="属性操作的标准方法"></a>属性操作的标准方法</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>元素节点提供六个方法，用来操作属性。</p>
<ul>
<li><code>getAttribute()</code></li>
<li><code>getAttributeNames()</code></li>
<li><code>setAttribute()</code></li>
<li><code>hasAttribute()</code></li>
<li><code>hasAttributes()</code></li>
<li><code>removeAttribute()</code></li>
</ul>
<p>这有几点注意。</p>
<p>（1）适用性</p>
<p>这六个方法对所有属性（包括用户自定义的属性）都适用。</p>
<p>（2）返回值</p>
<p><code>getAttribute()</code>只返回字符串，不会返回其他类型的值。</p>
<p>（3）属性名</p>
<p>这些方法只接受属性的标准名称，不用改写保留字，比如<code>for</code>和<code>class</code>都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var image &#x3D; document.images[0];</span><br><span class="line">image.setAttribute(&#39;class&#39;, &#39;myImage&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setAttribute</code>方法直接使用<code>class</code>作为属性名，不用写成<code>className</code>。</p>
<h4 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h4><p><code>Element.getAttribute</code>方法返回当前元素节点的指定属性。如果指定属性不存在，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;div1&quot; align&#x3D;&quot;left&quot;&gt;</span><br><span class="line">var div &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line">div.getAttribute(&#39;align&#39;) &#x2F;&#x2F; &quot;left&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Element-getAttributeNames"><a href="#Element-getAttributeNames" class="headerlink" title="Element.getAttributeNames()"></a>Element.getAttributeNames()</h4><p><code>Element.getAttributeNames()</code>返回一个数组，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用<code>Element.attributes</code>属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mydiv &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line"></span><br><span class="line">mydiv.getAttributeNames().forEach(function (key) &#123;</span><br><span class="line">  var value &#x3D; mydiv.getAttribute(key);</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码用于遍历某个节点的所有属性。</p>
<h4 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h4><p><code>Element.setAttribute</code>方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;button&gt;Hello World&lt;&#x2F;button&gt;</span><br><span class="line">var b &#x3D; document.querySelector(&#39;button&#39;);</span><br><span class="line">b.setAttribute(&#39;name&#39;, &#39;myButton&#39;);</span><br><span class="line">b.setAttribute(&#39;disabled&#39;, true);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>button</code>元素的<code>name</code>属性被设成<code>myButton</code>，<code>disabled</code>属性被设成<code>true</code>。</p>
<p>这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值<code>true</code>就会变成字符串<code>true</code>；其次，上例的<code>disable</code>属性是一个布尔属性，对于``元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此<code>setAttribute</code>方法里面可以将<code>disabled</code>属性设成任意值。</p>
<h4 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h4><p><code>Element.hasAttribute</code>方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line"></span><br><span class="line">if (d.hasAttribute(&#39;align&#39;)) &#123;</span><br><span class="line">  d.setAttribute(&#39;align&#39;, &#39;center&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码检查<code>div</code>节点是否含有<code>align</code>属性。如果有，则设置为居中对齐。</p>
<h4 id="Element-hasAttributes"><a href="#Element-hasAttributes" class="headerlink" title="Element.hasAttributes()"></a>Element.hasAttributes()</h4><p><code>Element.hasAttributes</code>方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回<code>false</code>，否则返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; document.getElementById(&#39;foo&#39;);</span><br><span class="line">foo.hasAttributes() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h4><p><code>Element.removeAttribute</code>方法移除指定属性。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;div1&quot; align&#x3D;&quot;left&quot; width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">document.getElementById(&#39;div1&#39;).removeAttribute(&#39;align&#39;);</span><br><span class="line">&#x2F;&#x2F; 现在的HTML代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;div1&quot; width&#x3D;&quot;200px&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="dataset属性"><a href="#dataset属性" class="headerlink" title="dataset属性"></a>dataset属性</h3><p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;mydiv&quot; foo&#x3D;&quot;bar&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码为<code>div</code>元素自定义了<code>foo</code>属性，然后可以用<code>getAttribute()</code>和<code>setAttribute()</code>读写这个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">n.getAttribute(&#39;foo&#39;) &#x2F;&#x2F; bar</span><br><span class="line">n.setAttribute(&#39;foo&#39;, &#39;baz&#39;)</span><br></pre></td></tr></table></figure>

<p>这种方法虽然可以达到目的，但是会使得 HTML 元素的属性不符合标准，导致网页代码通不过校验。</p>
<p>更好的解决方法是，使用标准提供的<code>data-*</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;mydiv&quot; data-foo&#x3D;&quot;bar&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>然后，使用元素节点对象的<code>dataset</code>属性，它指向一个对象，可以用来操作 HTML 元素标签的<code>data-*</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; document.getElementById(&#39;mydiv&#39;);</span><br><span class="line">n.dataset.foo &#x2F;&#x2F; bar</span><br><span class="line">n.dataset.foo &#x3D; &#39;baz&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>dataset.foo</code>读写<code>data-foo</code>属性。</p>
<p>删除一个<code>data-*</code>属性，可以直接使用<code>delete</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete document.getElementById(&#39;myDiv&#39;).dataset.foo;</span><br></pre></td></tr></table></figure>

<p>除了<code>dataset</code>属性，也可以用<code>getAttribute(&#39;data-foo&#39;)</code>、<code>removeAttribute(&#39;data-foo&#39;)</code>、<code>setAttribute(&#39;data-foo&#39;)</code>、<code>hasAttribute(&#39;data-foo&#39;)</code>等方法操作<code>data-*</code>属性。</p>
<p>注意，<code>data-</code>后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名不应该使用<code>A</code>到<code>Z</code>的大写字母，比如不能有<code>data-helloWorld</code>这样的属性名，而要写成<code>data-hello-world</code>。</p>
<p>转成<code>dataset</code>的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，<code>dataset</code>的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，<code>dataset.helloWorld</code>会转成<code>data-hello-world</code>。</p>
<h2 id="Text节点和DocumentFragment节点"><a href="#Text节点和DocumentFragment节点" class="headerlink" title="Text节点和DocumentFragment节点"></a>Text节点和DocumentFragment节点</h2><h3 id="Text节点的概念"><a href="#Text节点的概念" class="headerlink" title="Text节点的概念"></a>Text节点的概念</h3><p>文本节点（<code>Text</code>）代表元素节点（<code>Element</code>）和属性节点（<code>Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p>
<p>通常我们使用父节点的<code>firstChild</code>、<code>nextSibling</code>等属性获取文本节点，或者使用<code>Document</code>节点的<code>createTextNode</code>方法创造一个文本节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取文本节点</span><br><span class="line">var textNode &#x3D; document.querySelector(&#39;p&#39;).firstChild;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创造文本节点</span><br><span class="line">var textNode &#x3D; document.createTextNode(&#39;Hi&#39;);</span><br><span class="line">document.querySelector(&#39;div&#39;).appendChild(textNode);</span><br></pre></td></tr></table></figure>

<p>浏览器原生提供一个<code>Text</code>构造函数。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 空字符串</span><br><span class="line">var text1 &#x3D; new Text();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非空字符串</span><br><span class="line">var text2 &#x3D; new Text(&#39;This is a text node&#39;);</span><br></pre></td></tr></table></figure>

<p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code></code>包含一个空格，它的子节点就是一个文本节点。</p>
<p>文本节点除了继承<code>Node</code>接口，还继承了<code>CharacterData</code>接口。<code>Node</code>接口的属性和方法请参考《Node 接口》一章，这里不再重复介绍了，以下的属性和方法大部分来自<code>CharacterData</code>接口。</p>
<h3 id="Text节点的属性"><a href="#Text节点的属性" class="headerlink" title="Text节点的属性"></a>Text节点的属性</h3><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><p><code>data</code>属性等同于<code>nodeValue</code>属性，用来设置或读取文本节点的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取文本内容</span><br><span class="line">document.querySelector(&#39;p&#39;).firstChild.data</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">document.querySelector(&#39;p&#39;).firstChild.nodeValue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置文本内容</span><br><span class="line">document.querySelector(&#39;p&#39;).firstChild.data &#x3D; &#39;Hello World&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="wholeText"><a href="#wholeText" class="headerlink" title="wholeText"></a>wholeText</h4><p><code>wholeText</code>属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code>wholeText</code>属性的返回值，与<code>data</code>属性和<code>textContent</code>属性相同。但是，某些特殊情况会有差异。</p>
<p>举例来说，HTML 代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;para&quot;&gt;A &lt;em&gt;B&lt;&#x2F;em&gt; C&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>这时，文本节点的<code>wholeText</code>属性和<code>data</code>属性，返回值相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var el &#x3D; document.getElementById(&#39;para&#39;);</span><br><span class="line">el.firstChild.wholeText &#x2F;&#x2F; &quot;A &quot;</span><br><span class="line">el.firstChild.data &#x2F;&#x2F; &quot;A &quot;</span><br></pre></td></tr></table></figure>

<p>但是，一旦移除<code>节点，`wholeText`属性与`data`属性就会有差异，因为这时其实</code>节点下面包含了两个毗邻的文本节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.removeChild(para.childNodes[1]);</span><br><span class="line">el.firstChild.wholeText &#x2F;&#x2F; &quot;A C&quot;</span><br><span class="line">el.firstChild.data &#x2F;&#x2F; &quot;A &quot;</span><br></pre></td></tr></table></figure>

<h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p><code>length</code>属性返回当前文本节点的文本长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Text(&#39;Hello&#39;)).length &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>

<h4 id="nextElementSibling，previousElementSibling"><a href="#nextElementSibling，previousElementSibling" class="headerlink" title="nextElementSibling，previousElementSibling"></a>nextElementSibling，previousElementSibling</h4><p><code>nextElementSibling</code>属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 为</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;Hello &lt;em&gt;World&lt;&#x2F;em&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var tn &#x3D; document.querySelector(&#39;div&#39;).firstChild;</span><br><span class="line">tn.nextElementSibling</span><br><span class="line">&#x2F;&#x2F; &lt;em&gt;World&lt;&#x2F;em&gt;</span><br></pre></td></tr></table></figure>

<p><code>previousElementSibling</code>属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回<code>null：</code>。</p>
<h3 id="Text节点的方法"><a href="#Text节点的方法" class="headerlink" title="Text节点的方法"></a>Text节点的方法</h3><h4 id="appendData-deleteData-insertData-replaceData-subStringData"><a href="#appendData-deleteData-insertData-replaceData-subStringData" class="headerlink" title="appendData(),deleteData(),insertData(),replaceData(),subStringData()"></a>appendData(),deleteData(),insertData(),replaceData(),subStringData()</h4><p>以下5个方法都是编辑<code>Text</code>节点文本内容的方法。</p>
<ul>
<li><code>appendData()</code>：在<code>Text</code>节点尾部追加字符串。</li>
<li><code>deleteData()</code>：删除<code>Text</code>节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li>
<li><code>insertData()</code>：在<code>Text</code>节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li>
<li><code>replaceData()</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li>
<li><code>subStringData()</code>：用于获取子字符串，第一个参数为子字符串在<code>Text</code>节点中的开始位置，第二个参数为子字符串长度。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;Hello World&lt;&#x2F;p&gt;</span><br><span class="line">var pElementText &#x3D; document.querySelector(&#39;p&#39;).firstChild;</span><br><span class="line"></span><br><span class="line">pElementText.appendData(&#39;!&#39;);</span><br><span class="line">&#x2F;&#x2F; 页面显示 Hello World!</span><br><span class="line">pElementText.deleteData(7, 5);</span><br><span class="line">&#x2F;&#x2F; 页面显示 Hello W</span><br><span class="line">pElementText.insertData(7, &#39;Hello &#39;);</span><br><span class="line">&#x2F;&#x2F; 页面显示 Hello WHello</span><br><span class="line">pElementText.replaceData(7, 5, &#39;World&#39;);</span><br><span class="line">&#x2F;&#x2F; 页面显示 Hello WWorld</span><br><span class="line">pElementText.substringData(7, 10);</span><br><span class="line">&#x2F;&#x2F; 页面显示不变，返回&quot;World &quot;</span><br></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p><code>remove</code>方法用于移除当前<code>Text</code>节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;Hello World&lt;&#x2F;p&gt;</span><br><span class="line">document.querySelector(&#39;p&#39;).firstChild.remove()</span><br><span class="line">&#x2F;&#x2F; 现在 HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="splitText"><a href="#splitText" class="headerlink" title="splitText()"></a>splitText()</h4><p><code>splitText</code>方法将<code>Text</code>节点一分为二，变成两个毗邻的<code>Text</code>节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p>
<p>分割后，该方法返回分割位置后方的字符串，而原<code>Text</code>节点变成只包含分割位置前方的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; html 代码为 &lt;p id&#x3D;&quot;p&quot;&gt;foobar&lt;&#x2F;p&gt;</span><br><span class="line">var p &#x3D; document.getElementById(&#39;p&#39;);</span><br><span class="line">var textnode &#x3D; p.firstChild;</span><br><span class="line"></span><br><span class="line">var newText &#x3D; textnode.splitText(3);</span><br><span class="line">newText &#x2F;&#x2F; &quot;bar&quot;</span><br><span class="line">textnode &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>

<p>父元素节点的<code>normalize</code>方法可以将毗邻的两个<code>Text</code>节点合并。</p>
<p>接上面的例子，文本节点的<code>splitText</code>方法将一个<code>Text</code>节点分割成两个，父元素的<code>normalize</code>方法可以实现逆操作，将它们合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.childNodes.length &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将毗邻的两个 Text 节点合并</span><br><span class="line">p.normalize();</span><br><span class="line">p.childNodes.length &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<h3 id="DocumentFragment节点"><a href="#DocumentFragment节点" class="headerlink" title="DocumentFragment节点"></a>DocumentFragment节点</h3><p><code>DocumentFragment</code>节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code>parentNode</code>返回<code>null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作<code>DocumentFragment</code>节点，要比直接操作 DOM 树快得多。</p>
<p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code>document.createDocumentFragment</code>方法，以及浏览器原生的<code>DocumentFragment</code>构造函数，可以创建一个空的<code>DocumentFragment</code>节点。然后再使用其他 DOM 方法，向其添加子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var docFrag &#x3D; document.createDocumentFragment();</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">var docFrag &#x3D; new DocumentFragment();</span><br><span class="line"></span><br><span class="line">var li &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">li.textContent &#x3D; &#39;Hello World&#39;;</span><br><span class="line">docFrag.appendChild(li);</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;ul&#39;).appendChild(docFrag);</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个<code>DocumentFragment</code>节点，然后将一个<code>li</code>节点添加在它里面，最后将<code>DocumentFragment</code>节点移动到原文档。</p>
<p>注意，<code>DocumentFragment</code>节点本身不能被插入当前文档。当它作为<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code>等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦<code>DocumentFragment</code>节点被添加进当前文档，它自身就变成了空节点（<code>textContent</code>属性为空字符串），可以被再次使用。如果想要保存<code>DocumentFragment</code>节点的内容，可以使用<code>cloneNode</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document</span><br><span class="line">  .querySelector(&#39;ul&#39;)</span><br><span class="line">  .appendChild(docFrag.cloneNode(true));</span><br></pre></td></tr></table></figure>

<p>上面这样添加<code>DocumentFragment</code>节点进入当前文档，不会清空<code>DocumentFragment</code>节点。</p>
<p>下面是一个例子，使用<code>DocumentFragment</code>反转一个指定节点的所有子节点的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function reverse(n) &#123;</span><br><span class="line">  var f &#x3D; document.createDocumentFragment();</span><br><span class="line">  while(n.lastChild) f.appendChild(n.lastChild);</span><br><span class="line">  n.appendChild(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DocumentFragment</code>节点对象没有自己的属性和方法，全部继承自<code>Node</code>节点和<code>ParentNode</code>接口。也就是说，<code>DocumentFragment</code>节点比<code>Node</code>节点多出以下四个属性。</p>
<ul>
<li><code>children</code>：返回一个动态的<code>HTMLCollection</code>集合对象，包括当前<code>DocumentFragment</code>对象的所有子元素节点。</li>
<li><code>firstElementChild</code>：返回当前<code>DocumentFragment</code>对象的第一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>lastElementChild</code>：返回当前<code>DocumentFragment</code>对象的最后一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>childElementCount</code>：返回当前<code>DocumentFragment</code>对象的所有子元素数量。</li>
</ul>
<h2 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h2><p>CSS 与 JavaScript 是两个有着明确分工的领域，前者负责页面的视觉效果，后者负责与用户的行为互动。但是，它们毕竟同属网页开发的前端，因此不可避免有着交叉和互相配合。本章介绍如何通过 JavaScript 操作 CSS。</p>
<h3 id="HTML元素的style属性"><a href="#HTML元素的style属性" class="headerlink" title="HTML元素的style属性"></a>HTML元素的style属性</h3><p>操作 CSS 样式最简单的方法，就是使用网页元素节点的<code>getAttribute()</code>方法、<code>setAttribute()</code>方法和<code>removeAttribute()</code>方法，直接读写或删除网页元素的<code>style</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.setAttribute(</span><br><span class="line">  &#39;style&#39;,</span><br><span class="line">  &#39;background-color:red;&#39; + &#39;border:1px solid black;&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 HTML 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;background-color:red; border:1px solid black;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><code>style</code>不仅可以使用字符串读写，它本身还是一个对象，部署了 CSSStyleDeclaration 接口（详见下面的介绍），可以直接读写个别属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.style.fontSize &#x3D; &#39;18px&#39;;</span><br><span class="line">e.style.color &#x3D; &#39;black&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="CSSStyleDeclaration接口"><a href="#CSSStyleDeclaration接口" class="headerlink" title="CSSStyleDeclaration接口"></a>CSSStyleDeclaration接口</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>CSSStyleDeclaration 接口用来操作元素的样式。三个地方部署了这个接口。</p>
<ul>
<li>元素节点的<code>style</code>属性（<code>Element.style</code>）</li>
<li><code>CSSStyle</code>实例的<code>style</code>属性</li>
<li><code>window.getComputedStyle()</code>的返回值</li>
</ul>
<p>CSSStyleDeclaration 接口可以直接读写 CSS 的样式属性，不过，连词号需要变成骆驼拼写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var divStyle &#x3D; document.querySelector(&#39;div&#39;).style;</span><br><span class="line"></span><br><span class="line">divStyle.backgroundColor &#x3D; &#39;red&#39;;</span><br><span class="line">divStyle.border &#x3D; &#39;1px solid black&#39;;</span><br><span class="line">divStyle.width &#x3D; &#39;100px&#39;;</span><br><span class="line">divStyle.height &#x3D; &#39;100px&#39;;</span><br><span class="line">divStyle.fontSize &#x3D; &#39;10em&#39;;</span><br><span class="line"></span><br><span class="line">divStyle.backgroundColor &#x2F;&#x2F; red</span><br><span class="line">divStyle.border &#x2F;&#x2F; 1px solid black</span><br><span class="line">divStyle.height &#x2F;&#x2F; 100px</span><br><span class="line">divStyle.width &#x2F;&#x2F; 100px</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>style</code>属性的值是一个 CSSStyleDeclaration 实例。这个对象所包含的属性与 CSS 规则一一对应，但是名字需要改写，比如<code>background-color</code>写成<code>backgroundColor</code>。改写的规则是将横杠从 CSS 属性名中去除，然后将横杠后的第一个字母大写。如果 CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串<code>css</code>，比如<code>float</code>写成<code>cssFloat</code>。</p>
<p>注意，该对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号。比如，<code>divStyle.width</code>不能写为<code>100</code>，而要写为<code>100px</code>。</p>
<p>另外，<code>Element.style</code>返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过<code>window.getComputedStyle()</code>得到。</p>
<h4 id="CSSStyleDeclaration实例属性"><a href="#CSSStyleDeclaration实例属性" class="headerlink" title="CSSStyleDeclaration实例属性"></a>CSSStyleDeclaration实例属性</h4><p><strong>（1）CSSStyleDeclaration.cssText</strong></p>
<p><code>CSSStyleDeclaration.cssText</code>属性用来读写当前规则的所有样式声明文本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var divStyle &#x3D; document.querySelector(&#39;div&#39;).style;</span><br><span class="line"></span><br><span class="line">divStyle.cssText &#x3D; &#39;background-color: red;&#39;</span><br><span class="line">  + &#39;border: 1px solid black;&#39;</span><br><span class="line">  + &#39;height: 100px;&#39;</span><br><span class="line">  + &#39;width: 100px;&#39;;</span><br></pre></td></tr></table></figure>

<p>注意，<code>cssText</code>的属性值不用改写 CSS 属性名。</p>
<p>删除一个元素的所有行内样式，最简便的方法就是设置<code>cssText</code>为空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">divStyle.cssText &#x3D; &#39;&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）CSSStyleDeclaration.length</strong></p>
<p><code>CSSStyleDeclaration.length</code>属性返回一个整数值，表示当前规则包含多少条样式声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot;</span><br><span class="line">&#x2F;&#x2F;   style&#x3D;&quot;height: 1px;width: 100%;background-color: #CA1;&quot;</span><br><span class="line">&#x2F;&#x2F; &gt;&lt;&#x2F;div&gt;</span><br><span class="line">var myDiv &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">var divStyle &#x3D; myDiv.style;</span><br><span class="line">divStyle.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>myDiv</code>元素的行内样式共包含3条样式规则。</p>
<p><strong>（3）CSSStyleDeclaration.parentRule</strong></p>
<p><code>CSSStyleDeclaration.parentRule</code>属性返回当前规则所属的那个样式块（CSSRule 实例）。如果不存在所属的样式块，该属性返回<code>null</code>。</p>
<p>该属性只读，且只在使用 CSSRule 接口时有意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var declaration &#x3D; document.styleSheets[0].rules[0].style;</span><br><span class="line">declaration.parentRule &#x3D;&#x3D;&#x3D; document.styleSheets[0].rules[0]</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="CSSStyleDeclaration实例方法"><a href="#CSSStyleDeclaration实例方法" class="headerlink" title="CSSStyleDeclaration实例方法"></a>CSSStyleDeclaration实例方法</h4><p><strong>（1）CSSStyleDeclaration.getPropertyPriority()</strong></p>
<p><code>CSSStyleDeclaration.getPropertyPriority</code>方法接受 CSS 样式的属性名作为参数，返回一个字符串，表示有没有设置<code>important</code>优先级。如果有就返回<code>important</code>，否则返回空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;margin: 10px!important; color: red;&quot;&#x2F;&gt;</span><br><span class="line">var style &#x3D; document.getElementById(&#39;myDiv&#39;).style;</span><br><span class="line">style.margin &#x2F;&#x2F; &quot;10px&quot;</span><br><span class="line">style.getPropertyPriority(&#39;margin&#39;) &#x2F;&#x2F; &quot;important&quot;</span><br><span class="line">style.getPropertyPriority(&#39;color&#39;) &#x2F;&#x2F; &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>margin</code>属性有<code>important</code>优先级，<code>color</code>属性没有。</p>
<p><strong>（2）CSSStyleDeclaration.getPropertyValue()</strong></p>
<p><code>CSSStyleDeclaration.getPropertyValue</code>方法接受 CSS 样式属性名作为参数，返回一个字符串，表示该属性的属性值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;margin: 10px!important; color: red;&quot;&#x2F;&gt;</span><br><span class="line">var style &#x3D; document.getElementById(&#39;myDiv&#39;).style;</span><br><span class="line">style.margin &#x2F;&#x2F; &quot;10px&quot;</span><br><span class="line">style.getPropertyValue(&quot;margin&quot;) &#x2F;&#x2F; &quot;10px&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（3）CSSStyleDeclaration.item()</strong></p>
<p><code>CSSStyleDeclaration.item</code>方法接受一个整数值作为参数，返回该位置的 CSS 属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;color: red; background-color: white;&quot;&#x2F;&gt;</span><br><span class="line">var style &#x3D; document.getElementById(&#39;myDiv&#39;).style;</span><br><span class="line">style.item(0) &#x2F;&#x2F; &quot;color&quot;</span><br><span class="line">style.item(1) &#x2F;&#x2F; &quot;background-color&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>0</code>号位置的 CSS 属性名是<code>color</code>，<code>1</code>号位置的 CSS 属性名是<code>background-color</code>。</p>
<p>如果没有提供参数，这个方法会报错。如果参数值超过实际的属性数目，这个方法返回一个空字符值。</p>
<p><strong>（4）CSSStyleDeclaration.removeProperty()</strong></p>
<p><code>CSSStyleDeclaration.removeProperty</code>方法接受一个属性名作为参数，在 CSS 规则里面移除这个属性，返回这个属性原来的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;color: red; background-color: white;&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   111</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line">var style &#x3D; document.getElementById(&#39;myDiv&#39;).style;</span><br><span class="line">style.removeProperty(&#39;color&#39;) &#x2F;&#x2F; &#39;red&#39;</span><br><span class="line">&#x2F;&#x2F; HTML 代码变为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;background-color: white;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，删除<code>color</code>属性以后，字体颜色从红色变成默认颜色。</p>
<p><strong>（5）CSSStyleDeclaration.setProperty()</strong></p>
<p><code>CSSStyleDeclaration.setProperty</code>方法用来设置新的 CSS 属性。该方法没有返回值。</p>
<p>该方法可以接受三个参数。</p>
<ul>
<li>第一个参数：属性名，该参数是必需的。</li>
<li>第二个参数：属性值，该参数可选。如果省略，则参数值默认为空字符串。</li>
<li>第三个参数：优先级，该参数可选。如果设置，唯一的合法值是<code>important</code>，表示 CSS 规则里面的<code>!important</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;color: red; background-color: white;&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   111</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line">var style &#x3D; document.getElementById(&#39;myDiv&#39;).style;</span><br><span class="line">style.setProperty(&#39;border&#39;, &#39;1px solid blue&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码执行后，<code>myDiv</code>元素就会出现蓝色的边框。</p>
<h3 id="CSS模块的侦测"><a href="#CSS模块的侦测" class="headerlink" title="CSS模块的侦测"></a>CSS模块的侦测</h3><p>CSS 的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对 CSS 模块的支持情况都不一样。有时候，需要知道当前浏览器是否支持某个模块，这就叫做“CSS模块的侦测”。</p>
<p>一个比较普遍适用的方法是，判断元素的<code>style</code>对象的某个属性值是否为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof element.style.animationName &#x3D;&#x3D;&#x3D; &#39;string&#39;;</span><br><span class="line">typeof element.style.transform &#x3D;&#x3D;&#x3D; &#39;string&#39;;</span><br></pre></td></tr></table></figure>

<p>如果该 CSS 属性确实存在，会返回一个字符串。即使该属性实际上并未设置，也会返回一个空字符串。如果该属性不存在，则会返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.body.style[&#39;maxWidth&#39;] &#x2F;&#x2F; &quot;&quot;</span><br><span class="line">document.body.style[&#39;maximumWidth&#39;] &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>上面代码说明，这个浏览器支持<code>max-width</code>属性，但是不支持<code>maximum-width</code>属性。</p>
<p>注意，不管 CSS 属性名的写法带不带连词线，<code>style</code>属性上都能反映出该属性是否存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.body.style[&#39;backgroundColor&#39;] &#x2F;&#x2F; &quot;&quot;</span><br><span class="line">document.body.style[&#39;background-color&#39;] &#x2F;&#x2F; &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>另外，使用的时候，需要把不同浏览器的 CSS 前缀也考虑进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var content &#x3D; document.getElementById(&#39;content&#39;);</span><br><span class="line">typeof content.style[&#39;webkitAnimation&#39;] &#x3D;&#x3D;&#x3D; &#39;string&#39;</span><br></pre></td></tr></table></figure>

<p>这种侦测方法可以写成一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function isPropertySupported(property) &#123;</span><br><span class="line">  if (property in document.body.style) return true;</span><br><span class="line">  var prefixes &#x3D; [&#39;Moz&#39;, &#39;Webkit&#39;, &#39;O&#39;, &#39;ms&#39;, &#39;Khtml&#39;];</span><br><span class="line">  var prefProperty &#x3D; property.charAt(0).toUpperCase() + property.substr(1);</span><br><span class="line"></span><br><span class="line">  for(var i &#x3D; 0; i &lt; prefixes.length; i++)&#123;</span><br><span class="line">    if((prefixes[i] + prefProperty) in document.body.style) return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPropertySupported(&#39;background-clip&#39;)</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="CSS对象"><a href="#CSS对象" class="headerlink" title="CSS对象"></a>CSS对象</h3><p>浏览器原生提供 CSS 对象，为 JavaScript 操作 CSS 提供一些工具方法。</p>
<p>这个对象目前有两个静态方法。</p>
<h4 id="CSS-escape"><a href="#CSS-escape" class="headerlink" title="CSS.escape()"></a>CSS.escape()</h4><p><code>CSS.escape</code>方法用于转义 CSS 选择器里面的特殊字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;foo#bar&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，该元素的<code>id</code>属性包含一个<code>#</code>号，该字符在 CSS 选择器里面有特殊含义。不能直接写成<code>document.querySelector(&#39;#foo#bar&#39;)</code>，只能写成<code>document.querySelector(&#39;#foo\\#bar&#39;)</code>。这里必须使用双斜杠的原因是，单引号字符串本身会转义一次斜杠。</p>
<p><code>CSS.escape</code>方法就用来转义那些特殊字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#39;#&#39; + CSS.escape(&#39;foo#bar&#39;))</span><br></pre></td></tr></table></figure>

<h4 id="CSS-supports"><a href="#CSS-supports" class="headerlink" title="CSS.supports()"></a>CSS.supports()</h4><p><code>CSS.supports</code>方法返回一个布尔值，表示当前环境是否支持某一句 CSS 规则。</p>
<p>它的参数有两种写法，一种是第一个参数是属性名，第二个参数是属性值；另一种是整个参数就是一行完整的 CSS 语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种写法</span><br><span class="line">CSS.supports(&#39;transform-origin&#39;, &#39;5px&#39;) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种写法</span><br><span class="line">CSS.supports(&#39;display: table-cell&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>注意，第二种写法的参数结尾不能带有分号，否则结果不准确。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS.supports(&#39;display: table-cell;&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h3 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle()"></a>window.getComputedStyle()</h3><p>行内样式（inline style）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素实际的样式，只读取行内样式是不够的，需要得到浏览器最终计算出来的样式规则。</p>
<p><code>window.getComputedStyle</code>方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var styleObj &#x3D; window.getComputedStyle(div);</span><br><span class="line">styleObj.backgroundColor</span><br></pre></td></tr></table></figure>

<p>上面代码中，得到的背景色就是<code>div</code>元素真正的背景色。</p>
<p>注意，CSSStyleDeclaration 实例是一个活的对象，任何对于样式的修改，会实时反映到这个实例上面。另外，这个实例是只读的。</p>
<p><code>getComputedStyle</code>方法还可以接受第二个参数，表示当前元素的伪元素（比如<code>:before</code>、<code>:after</code>、<code>:first-line</code>、<code>:first-letter</code>等）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; window.getComputedStyle(div, &#39;:before&#39;);</span><br></pre></td></tr></table></figure>

<p>下面的例子是如何获取元素的高度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var elem &#x3D; document.getElementById(&#39;elem-container&#39;);</span><br><span class="line">var styleObj &#x3D; window.getComputedStyle(elem, null)</span><br><span class="line">var height &#x3D; styleObj.height;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">var height &#x3D; styleObj[&#39;height&#39;];</span><br><span class="line">var height &#x3D; styleObj.getPropertyValue(&#39;height&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码得到的<code>height</code>属性，是浏览器最终渲染出来的高度，比其他方法得到的高度更可靠。由于<code>styleObj</code>是 CSSStyleDeclaration 实例，所以可以使用各种 CSSStyleDeclaration 的实例属性和方法。</p>
<p>有几点需要注意。</p>
<ul>
<li>CSSStyleDeclaration 实例返回的 CSS 值都是绝对单位。比如，长度都是像素单位（返回值包括<code>px</code>后缀），颜色是<code>rgb(#, #, #)</code>或<code>rgba(#, #, #, #)</code>格式。</li>
<li>CSS 规则的简写形式无效。比如，想读取<code>margin</code>属性的值，不能直接读，只能读<code>marginLeft</code>、<code>marginTop</code>等属性；再比如，<code>font</code>属性也是不能直接读的，只能读<code>font-size</code>等单个属性。</li>
<li>如果读取 CSS 原始的属性名，要用方括号运算符，比如<code>styleObj[&#39;z-index&#39;]</code>；如果读取骆驼拼写法的 CSS 属性名，可以直接读取<code>styleObj.zIndex</code>。</li>
<li>该方法返回的 CSSStyleDeclaration 实例的<code>cssText</code>属性无效，返回<code>undefined</code>。</li>
</ul>
<h3 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h3><p>CSS 伪元素是通过 CSS 向 DOM 添加的元素，主要是通过<code>:before</code>和<code>:after</code>选择器生成，然后用<code>content</code>属性指定伪元素的内容。</p>
<p>下面是一段 HTML 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;test&quot;&gt;Test content&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>CSS 添加伪元素<code>:before</code>的写法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#test:before &#123;</span><br><span class="line">  content: &#39;Before &#39;;</span><br><span class="line">  color: #FF0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点元素的<code>style</code>对象无法读写伪元素的样式，这时就要用到<code>window.getComputedStyle()</code>。JavaScript 获取伪元素，可以使用下面的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; document.querySelector(&#39;#test&#39;);</span><br><span class="line"></span><br><span class="line">var result &#x3D; window.getComputedStyle(test, &#39;:before&#39;).content;</span><br><span class="line">var color &#x3D; window.getComputedStyle(test, &#39;:before&#39;).color;</span><br></pre></td></tr></table></figure>

<p>此外，也可以使用 CSSStyleDeclaration 实例的<code>getPropertyValue</code>方法，获取伪元素的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; window.getComputedStyle(test, &#39;:before&#39;)</span><br><span class="line">  .getPropertyValue(&#39;content&#39;);</span><br><span class="line">var color &#x3D; window.getComputedStyle(test, &#39;:before&#39;)</span><br><span class="line">  .getPropertyValue(&#39;color&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="StyleSheet接口"><a href="#StyleSheet接口" class="headerlink" title="StyleSheet接口"></a>StyleSheet接口</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p><code>StyleSheet</code>接口代表网页的一张样式表，包括<code>元素加载的样式表和</code>元素内嵌的样式表。</p>
<p><code>document</code>对象的<code>styleSheets</code>属性，可以返回当前页面的所有<code>StyleSheet</code>实例（即所有样式表）。它是一个类似数组的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sheets &#x3D; document.styleSheets;</span><br><span class="line">var sheet &#x3D; document.styleSheets[0];</span><br><span class="line">sheet instanceof StyleSheet &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>如果是``元素嵌入的样式表，还有另一种获取<code>StyleSheet</code>实例的方法，就是这个节点元素的<code>sheet</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为 &lt;style id&#x3D;&quot;myStyle&quot;&gt;&lt;&#x2F;style&gt;</span><br><span class="line">var myStyleSheet &#x3D; document.getElementById(&#39;myStyle&#39;).sheet;</span><br><span class="line">myStyleSheet instanceof StyleSheet &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>严格地说，<code>StyleSheet</code>接口不仅包括网页样式表，还包括 XML 文档的样式表。所以，它有一个子类<code>CSSStyleSheet</code>表示网页的 CSS 样式表。我们在网页里面拿到的样式表实例，实际上是<code>CSSStyleSheet</code>的实例。这个子接口继承了<code>StyleSheet</code>的所有属性和方法，并且定义了几个自己的属性，下面把这两个接口放在一起介绍。</p>
<h4 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h4><p><code>StyleSheet</code>实例有以下属性。</p>
<p><strong>（1）StyleSheet.disabled</strong></p>
<p><code>StyleSheet.disabled</code>返回一个布尔值，表示该样式表是否处于禁用状态。手动设置<code>disabled</code>属性为<code>true</code>，等同于在``元素里面，将这张样式表设为<code>alternate stylesheet</code>，即该样式表将不会生效。</p>
<p>注意，<code>disabled</code>属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。</p>
<p><strong>（2）Stylesheet.href</strong></p>
<p><code>Stylesheet.href</code>返回样式表的网址。对于内嵌样式表，该属性返回<code>null</code>。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets[0].href</span><br></pre></td></tr></table></figure>

<p><strong>（3）StyleSheet.media</strong></p>
<p><code>StyleSheet.media</code>属性返回一个类似数组的对象（<code>MediaList</code>实例），成员是表示适用媒介的字符串。表示当前样式表是用于屏幕（screen），还是用于打印（print）或手持设备（handheld），或各种媒介都适用（all）。该属性只读，默认值是<code>screen</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets[0].media.mediaText</span><br><span class="line">&#x2F;&#x2F; &quot;all&quot;</span><br></pre></td></tr></table></figure>

<p><code>MediaList</code>实例的<code>appendMedium</code>方法，用于增加媒介；<code>deleteMedium</code>方法用于删除媒介。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets[0].media.appendMedium(&#39;handheld&#39;);</span><br><span class="line">document.styleSheets[0].media.deleteMedium(&#39;print&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>（4）StyleSheet.title</strong></p>
<p><code>StyleSheet.title</code>属性返回样式表的<code>title</code>属性。</p>
<p><strong>（5）StyleSheet.type</strong></p>
<p><code>StyleSheet.type</code>属性返回样式表的<code>type</code>属性，通常是<code>text/css</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets[0].type  &#x2F;&#x2F; &quot;text&#x2F;css&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（6）StyleSheet.parentStyleSheet</strong></p>
<p>CSS 的<code>@import</code>命令允许在样式表中加载其他样式表。<code>StyleSheet.parentStyleSheet</code>属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (stylesheet.parentStyleSheet) &#123;</span><br><span class="line">  sheet &#x3D; stylesheet.parentStyleSheet;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  sheet &#x3D; stylesheet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（7）StyleSheet.ownerNode</strong></p>
<p><code>StyleSheet.ownerNode</code>属性返回<code>StyleSheet</code>对象所在的 DOM 节点，通常是<code>或</code>。对于那些由其他样式表引用的样式表，该属性为<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML代码为</span><br><span class="line">&#x2F;&#x2F; &lt;link rel&#x3D;&quot;StyleSheet&quot; href&#x3D;&quot;example.css&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;&gt;</span><br><span class="line">document.styleSheets[0].ownerNode &#x2F;&#x2F; [object HTMLLinkElement]</span><br></pre></td></tr></table></figure>

<p><strong>（8）CSSStyleSheet.cssRules</strong></p>
<p><code>CSSStyleSheet.cssRules</code>属性指向一个类似数组的对象（<code>CSSRuleList</code>实例），里面每一个成员就是当前样式表的一条 CSS 规则。使用该规则的<code>cssText</code>属性，可以得到 CSS 规则对应的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var sheet &#x3D; document.querySelector(&#39;#styleElement&#39;).sheet;</span><br><span class="line"></span><br><span class="line">sheet.cssRules[0].cssText</span><br><span class="line">&#x2F;&#x2F; &quot;body &#123; background-color: red; margin: 20px; &#125;&quot;</span><br><span class="line"></span><br><span class="line">sheet.cssRules[1].cssText</span><br><span class="line">&#x2F;&#x2F; &quot;p &#123; line-height: 1.4em; color: blue; &#125;&quot;</span><br></pre></td></tr></table></figure>

<p>每条 CSS 规则还有一个<code>style</code>属性，指向一个对象，用来读写具体的 CSS 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssStyleSheet.cssRules[0].style.color &#x3D; &#39;red&#39;;</span><br><span class="line">cssStyleSheet.cssRules[1].style.color &#x3D; &#39;purple&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>（9）CSSStyleSheet.ownerRule</strong></p>
<p>有些样式表是通过<code>@import</code>规则输入的，它的<code>ownerRule</code>属性会返回一个<code>CSSRule</code>实例，代表那行<code>@import</code>规则。如果当前样式表不是通过<code>@import</code>引入的，<code>ownerRule</code>属性返回<code>null</code>。</p>
<h4 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h4><p><strong>（1）CSSStyleSheet.insertRule()</strong></p>
<p><code>CSSStyleSheet.insertRule</code>方法用于在当前样式表的插入一个新的 CSS 规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sheet &#x3D; document.querySelector(&#39;#styleElement&#39;).sheet;</span><br><span class="line">sheet.insertRule(&#39;#block &#123; color: white &#125;&#39;, 0);</span><br><span class="line">sheet.insertRule(&#39;p &#123; color: red &#125;&#39;, 1);</span><br></pre></td></tr></table></figure>

<p>该方法可以接受两个参数，第一个参数是表示 CSS 规则的字符串，这里只能有一条规则，否则会报错。第二个参数是该规则在样式表的插入位置（从0开始），该参数可选，默认为0（即默认插在样式表的头部）。注意，如果插入位置大于现有规则的数目，会报错。</p>
<p>该方法的返回值是新插入规则的位置序号。</p>
<p>注意，浏览器对脚本在样式表里面插入规则有很多<a href="https://drafts.csswg.org/cssom/#insert-a-css-rule" target="_blank" rel="noopener">限制</a>。所以，这个方法最好放在<code>try...catch</code>里使用。</p>
<p><strong>（2）CSSStyleSheet.deleteRule()</strong></p>
<p><code>CSSStyleSheet.deleteRule</code>方法用来在样式表里面移除一条规则，它的参数是该条规则在<code>cssRules</code>对象中的位置。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets[0].deleteRule(1);</span><br></pre></td></tr></table></figure>

<h3 id="实例：添加样式表"><a href="#实例：添加样式表" class="headerlink" title="实例：添加样式表"></a>实例：添加样式表</h3><p>网页添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个``节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">var style &#x3D; document.createElement(&#39;style&#39;);</span><br><span class="line">style.setAttribute(&#39;media&#39;, &#39;screen&#39;);</span><br><span class="line">style.innerHTML &#x3D; &#39;body&#123;color:red&#125;&#39;;</span><br><span class="line">document.head.appendChild(style);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">var style &#x3D; (function () &#123;</span><br><span class="line">  var style &#x3D; document.createElement(&#39;style&#39;);</span><br><span class="line">  document.head.appendChild(style);</span><br><span class="line">  return style;</span><br><span class="line">&#125;)();</span><br><span class="line">style.sheet.insertRule(&#39;.foo&#123;color:red;&#125;&#39;, 0);</span><br></pre></td></tr></table></figure>

<p>另一种是添加外部样式表，即在文档中添加一个``节点，然后将<code>href</code>属性指向外部样式表的 URL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var linkElm &#x3D; document.createElement(&#39;link&#39;);</span><br><span class="line">linkElm.setAttribute(&#39;rel&#39;, &#39;stylesheet&#39;);</span><br><span class="line">linkElm.setAttribute(&#39;type&#39;, &#39;text&#x2F;css&#39;);</span><br><span class="line">linkElm.setAttribute(&#39;href&#39;, &#39;reset-min.css&#39;);</span><br><span class="line"></span><br><span class="line">document.head.appendChild(linkElm);</span><br></pre></td></tr></table></figure>

<h3 id="CSSRuleList接口"><a href="#CSSRuleList接口" class="headerlink" title="CSSRuleList接口"></a>CSSRuleList接口</h3><p>CSSRuleList 接口是一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例。</p>
<p>获取 CSSRuleList 实例，一般是通过<code>StyleSheet.cssRules</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;style id&#x3D;&quot;myStyle&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   h1 &#123; color: red; &#125;</span><br><span class="line">&#x2F;&#x2F;   p &#123; color: blue; &#125;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;style&gt;</span><br><span class="line">var myStyleSheet &#x3D; document.getElementById(&#39;myStyle&#39;).sheet;</span><br><span class="line">var crl &#x3D; myStyleSheet.cssRules;</span><br><span class="line">crl instanceof CSSRuleList &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>CSSRuleList 实例里面，每一条规则（CSSRule 实例）可以通过<code>rules.item(index)</code>或者<code>rules[index]</code>拿到。CSS 规则的条数通过<code>rules.length</code>拿到。还是用上面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crl[0] instanceof CSSRule &#x2F;&#x2F; true</span><br><span class="line">crl.length &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>注意，添加规则和删除规则不能在 CSSRuleList 实例操作，而要在它的父元素 StyleSheet 实例上，通过<code>StyleSheet.insertRule()</code>和<code>StyleSheet.deleteRule()</code>操作。</p>
<h3 id="CSSRule接口"><a href="#CSSRule接口" class="headerlink" title="CSSRule接口"></a>CSSRule接口</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>一条 CSS 规则包括两个部分：CSS 选择器和样式声明。下面就是一条典型的 CSS 规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.myClass &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 通过 CSSRule 接口操作 CSS 规则。一般通过 CSSRuleList 接口（<code>StyleSheet.cssRules</code>）获取 CSSRule 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;style id&#x3D;&quot;myStyle&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   .myClass &#123;</span><br><span class="line">&#x2F;&#x2F;     color: red;</span><br><span class="line">&#x2F;&#x2F;     background-color: yellow;</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;style&gt;</span><br><span class="line">var myStyleSheet &#x3D; document.getElementById(&#39;myStyle&#39;).sheet;</span><br><span class="line">var ruleList &#x3D; myStyleSheet.cssRules;</span><br><span class="line">var rule &#x3D; ruleList[0];</span><br><span class="line">rule instanceof CSSRule &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="CSSRule实例的属性"><a href="#CSSRule实例的属性" class="headerlink" title="CSSRule实例的属性"></a>CSSRule实例的属性</h4><p><strong>（1）CSSRule.cssText</strong></p>
<p><code>CSSRule.cssText</code>属性返回当前规则的文本，还是使用上面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule.cssText</span><br><span class="line">&#x2F;&#x2F; &quot;.myClass &#123; color: red; background-color: yellow; &#125;&quot;</span><br></pre></td></tr></table></figure>

<p>如果规则是加载（<code>@import</code>）其他样式表，<code>cssText</code>属性返回<code>@import &#39;url&#39;</code>。</p>
<p><strong>（2）CSSRule.parentStyleSheet</strong></p>
<p><code>CSSRule.parentStyleSheet</code>属性返回当前规则所在的样式表对象（StyleSheet 实例），还是使用上面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule.parentStyleSheet &#x3D;&#x3D;&#x3D; myStyleSheet &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><strong>（3）CSSRule.parentRule</strong></p>
<p><code>CSSRule.parentRule</code>属性返回包含当前规则的父规则，如果不存在父规则（即当前规则是顶层规则），则返回<code>null</code>。</p>
<p>父规则最常见的情况是，当前规则包含在<code>@media</code>规则代码块之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;style id&#x3D;&quot;myStyle&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   @supports (display: flex) &#123;</span><br><span class="line">&#x2F;&#x2F;     @media screen and (min-width: 900px) &#123;</span><br><span class="line">&#x2F;&#x2F;       article &#123;</span><br><span class="line">&#x2F;&#x2F;         display: flex;</span><br><span class="line">&#x2F;&#x2F;       &#125;</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F;  &#125;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;style&gt;</span><br><span class="line">var myStyleSheet &#x3D; document.getElementById(&#39;myStyle&#39;).sheet;</span><br><span class="line">var ruleList &#x3D; myStyleSheet.cssRules;</span><br><span class="line"></span><br><span class="line">var rule0 &#x3D; ruleList[0];</span><br><span class="line">rule0.cssText</span><br><span class="line">&#x2F;&#x2F; &quot;@supports (display: flex) &#123;</span><br><span class="line">&#x2F;&#x2F;    @media screen and (min-width: 900px) &#123;</span><br><span class="line">&#x2F;&#x2F;      article &#123; display: flex; &#125;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于这条规则内嵌其他规则，</span><br><span class="line">&#x2F;&#x2F; 所以它有 cssRules 属性，且该属性是 CSSRuleList 实例</span><br><span class="line">rule0.cssRules instanceof CSSRuleList &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">var rule1 &#x3D; rule0.cssRules[0];</span><br><span class="line">rule1.cssText</span><br><span class="line">&#x2F;&#x2F; &quot;@media screen and (min-width: 900px) &#123;</span><br><span class="line">&#x2F;&#x2F;   article &#123; display: flex; &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;&quot;</span><br><span class="line"></span><br><span class="line">var rule2 &#x3D; rule1.cssRules[0];</span><br><span class="line">rule2.cssText</span><br><span class="line">&#x2F;&#x2F; &quot;article &#123; display: flex; &#125;&quot;</span><br><span class="line"></span><br><span class="line">rule1.parentRule &#x3D;&#x3D;&#x3D; rule0 &#x2F;&#x2F; true</span><br><span class="line">rule2.parentRule &#x3D;&#x3D;&#x3D; rule1 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><strong>（4）CSSRule.type</strong></p>
<p><code>CSSRule.type</code>属性返回一个整数值，表示当前规则的类型。</p>
<p>最常见的类型有以下几种。</p>
<ul>
<li>1：普通样式规则（CSSStyleRule 实例）</li>
<li>3：<code>@import</code>规则</li>
<li>4：<code>@media</code>规则（CSSMediaRule 实例）</li>
<li>5：<code>@font-face</code>规则</li>
</ul>
<h4 id="CSSStyleRule接口"><a href="#CSSStyleRule接口" class="headerlink" title="CSSStyleRule接口"></a>CSSStyleRule接口</h4><p>如果一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令），那么除了 CSSRule 接口，它还部署了 CSSStyleRule 接口。</p>
<p>CSSStyleRule 接口有以下两个属性。</p>
<p><strong>（1）CSSStyleRule.selectorText</strong></p>
<p><code>CSSStyleRule.selectorText</code>属性返回当前规则的选择器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stylesheet &#x3D; document.styleSheets[0];</span><br><span class="line">stylesheet.cssRules[0].selectorText &#x2F;&#x2F; &quot;.myClass&quot;</span><br></pre></td></tr></table></figure>

<p>注意，这个属性是可写的。</p>
<p><strong>（2）CSSStyleRule.style</strong></p>
<p><code>CSSStyleRule.style</code>属性返回一个对象（CSSStyleDeclaration 实例），代表当前规则的样式声明，也就是选择器后面的大括号里面的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;style id&#x3D;&quot;myStyle&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   p &#123; color: red; &#125;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;style&gt;</span><br><span class="line">var styleSheet &#x3D; document.getElementById(&#39;myStyle&#39;).sheet;</span><br><span class="line">styleSheet.cssRules[0].style instanceof CSSStyleDeclaration</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>CSSStyleDeclaration 实例的<code>cssText</code>属性，可以返回所有样式声明，格式为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">styleSheet.cssRules[0].style.cssText</span><br><span class="line">&#x2F;&#x2F; &quot;color: red;&quot;</span><br><span class="line">styleSheet.cssRules[0].selectorText</span><br><span class="line">&#x2F;&#x2F; &quot;p&quot;</span><br></pre></td></tr></table></figure>

<h4 id="CSSMediaRule接口"><a href="#CSSMediaRule接口" class="headerlink" title="CSSMediaRule接口"></a>CSSMediaRule接口</h4><p>如果一条 CSS 规则是<code>@media</code>代码块，那么它除了 CSSRule 接口，还部署了 CSSMediaRule 接口。</p>
<p>该接口主要提供<code>media</code>属性和<code>conditionText</code>属性。前者返回代表<code>@media</code>规则的一个对象（MediaList 实例），后者返回<code>@media</code>规则的生效条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;style id&#x3D;&quot;myStyle&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;   @media screen and (min-width: 900px) &#123;</span><br><span class="line">&#x2F;&#x2F;     article &#123; display: flex; &#125;</span><br><span class="line">&#x2F;&#x2F;   &#125;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;style&gt;</span><br><span class="line">var styleSheet &#x3D; document.getElementById(&#39;myStyle&#39;).sheet;</span><br><span class="line">styleSheet.cssRules[0] instanceof CSSMediaRule</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">styleSheet.cssRules[0].media</span><br><span class="line">&#x2F;&#x2F;  &#123;</span><br><span class="line">&#x2F;&#x2F;    0: &quot;screen and (min-width: 900px)&quot;,</span><br><span class="line">&#x2F;&#x2F;    appendMedium: function,</span><br><span class="line">&#x2F;&#x2F;    deleteMedium: function,</span><br><span class="line">&#x2F;&#x2F;    item: function,</span><br><span class="line">&#x2F;&#x2F;    length: 1,</span><br><span class="line">&#x2F;&#x2F;    mediaText: &quot;screen and (min-width: 900px)&quot;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">styleSheet.cssRules[0].conditionText</span><br><span class="line">&#x2F;&#x2F; &quot;screen and (min-width: 900px)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="window-matchMedia"><a href="#window-matchMedia" class="headerlink" title="window.matchMedia()"></a>window.matchMedia()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>window.matchMedia</code>方法用来将 CSS 的<a href="https://developer.mozilla.org/en-US/docs/DOM/Using_media_queries_from_code" target="_blank" rel="noopener"><code>MediaQuery</code></a>条件语句，转换成一个 MediaQueryList 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mdl &#x3D; window.matchMedia(&#39;(min-width: 400px)&#39;);</span><br><span class="line">mdl instanceof MediaQueryList &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>mdl</code>就是 mediaQueryList 的实例。</p>
<p>注意，如果参数不是有效的<code>MediaQuery</code>条件语句，<code>window.matchMedia</code>不会报错，依然返回一个 MediaQueryList 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.matchMedia(&#39;bad string&#39;) instanceof MediaQueryList &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="MediaQueryList接口的实例属性"><a href="#MediaQueryList接口的实例属性" class="headerlink" title="MediaQueryList接口的实例属性"></a>MediaQueryList接口的实例属性</h4><p>MediaQueryList 实例有三个属性。</p>
<p><strong>（1）MediaQueryList.media</strong></p>
<p><code>MediaQueryList.media</code>属性返回一个字符串，表示对应的 MediaQuery 条件语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mql &#x3D; window.matchMedia(&#39;(min-width: 400px)&#39;);</span><br><span class="line">mql.media &#x2F;&#x2F; &quot;(min-width: 400px)&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（2）MediaQueryList.matches</strong></p>
<p><code>MediaQueryList.matches</code>属性返回一个布尔值，表示当前页面是否符合指定的 MediaQuery 条件语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (window.matchMedia(&#39;(min-width: 400px)&#39;).matches) &#123;</span><br><span class="line">  &#x2F;* 当前视口不小于 400 像素 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;* 当前视口小于 400 像素 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子根据<code>mediaQuery</code>是否匹配当前环境，加载相应的 CSS 样式表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; window.matchMedia(&quot;(max-width: 700px)&quot;);</span><br><span class="line"></span><br><span class="line">if (result.matches)&#123;</span><br><span class="line">  var linkElm &#x3D; document.createElement(&#39;link&#39;);</span><br><span class="line">  linkElm.setAttribute(&#39;rel&#39;, &#39;stylesheet&#39;);</span><br><span class="line">  linkElm.setAttribute(&#39;type&#39;, &#39;text&#x2F;css&#39;);</span><br><span class="line">  linkElm.setAttribute(&#39;href&#39;, &#39;small.css&#39;);</span><br><span class="line"></span><br><span class="line">  document.head.appendChild(linkElm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）MediaQueryList.onchange</strong></p>
<p>如果 MediaQuery 条件语句的适配环境发生变化，会触发<code>change</code>事件。<code>MediaQueryList.onchange</code>属性用来指定<code>change</code>事件的监听函数。该函数的参数是<code>change</code>事件对象（MediaQueryListEvent 实例），该对象与 MediaQueryList 实例类似，也有<code>media</code>和<code>matches</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var mql &#x3D; window.matchMedia(&#39;(max-width: 600px)&#39;);</span><br><span class="line"></span><br><span class="line">mql.onchange &#x3D; function(e) &#123;</span><br><span class="line">  if (e.matches) &#123;</span><br><span class="line">    &#x2F;* 视口不超过 600 像素 *&#x2F;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;* 视口超过 600 像素 *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>change</code>事件发生后，存在两种可能。一种是显示宽度从600像素以上变为以下，另一种是从600像素以下变为以上，所以在监听函数内部要判断一下当前是哪一种情况。</p>
<h4 id="MediaQueryList接口的实例方法"><a href="#MediaQueryList接口的实例方法" class="headerlink" title="MediaQueryList接口的实例方法"></a>MediaQueryList接口的实例方法</h4><p>MediaQueryList 实例有两个方法<code>MediaQueryList.addListener()</code>和<code>MediaQueryList.removeListener()</code>，用来为<code>change</code>事件添加或撤销监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mql &#x3D; window.matchMedia(&#39;(max-width: 600px)&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定监听函数</span><br><span class="line">mql.addListener(mqCallback);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 撤销监听函数</span><br><span class="line">mql.removeListener(mqCallback);</span><br><span class="line"></span><br><span class="line">function mqCallback(e) &#123;</span><br><span class="line">  if (e.matches) &#123;</span><br><span class="line">    &#x2F;* 视口不超过 600 像素 *&#x2F;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;* 视口超过 600 像素 *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>MediaQueryList.removeListener()</code>方法不能撤销<code>MediaQueryList.onchange</code>属性指定的监听函数。</p>
<h2 id="Mutation-Observer-API"><a href="#Mutation-Observer-API" class="headerlink" title="Mutation Observer API"></a>Mutation Observer API</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p>
<p>概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p>
<p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个``元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。</p>
<p>Mutation Observer 有以下特点。</p>
<ul>
<li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li>
<li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li>
<li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li>
</ul>
<h3 id="MutationObserver构造函数"><a href="#MutationObserver构造函数" class="headerlink" title="MutationObserver构造函数"></a>MutationObserver构造函数</h3><p>使用时，首先使用<code>MutationObserver</code>构造函数，新建一个观察器实例，同时指定这个实例的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var observer &#x3D; new MutationObserver(callback);</span><br></pre></td></tr></table></figure>

<p>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var observer &#x3D; new MutationObserver(function (mutations, observer) &#123;</span><br><span class="line">  mutations.forEach(function(mutation) &#123;</span><br><span class="line">    console.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="MutationObserver的实例方法"><a href="#MutationObserver的实例方法" class="headerlink" title="MutationObserver的实例方法"></a>MutationObserver的实例方法</h3><h4 id="observe"><a href="#observe" class="headerlink" title="observe()"></a>observe()</h4><p><code>observe()</code>方法用来启动监听，它接受两个参数。</p>
<ul>
<li>第一个参数：所要观察的 DOM 节点</li>
<li>第二个参数：一个配置对象，指定所要观察的特定变动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var article &#x3D; document.querySelector(&#39;article&#39;);</span><br><span class="line"></span><br><span class="line">var  options &#x3D; &#123;</span><br><span class="line">  &#39;childList&#39;: true,</span><br><span class="line">  &#39;attributes&#39;:true</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">observer.observe(article, options);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>observe()</code>方法接受两个参数，第一个是所要观察的DOM元素是<code>article</code>，第二个是所要观察的变动类型（子节点变动和属性变动）。</p>
<p>观察器所能观察的 DOM 变动类型（即上面代码的<code>options</code>对象），有以下几种。</p>
<ul>
<li><strong>childList</strong>：子节点的变动（指新增，删除或者更改）。</li>
<li><strong>attributes</strong>：属性的变动。</li>
<li><strong>characterData</strong>：节点内容或节点文本的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在<code>option</code>对象中指定它的值为<code>true</code>。需要注意的是，至少必须同时指定这三种观察的一种，若均未指定将报错。</p>
<p>除了变动类型，<code>options</code>对象还可以设定以下属性：</p>
<ul>
<li><code>subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li>
<li><code>attributeOldValue</code>：布尔值，表示观察<code>attributes</code>变动时，是否需要记录变动前的属性值。</li>
<li><code>characterDataOldValue</code>：布尔值，表示观察<code>characterData</code>变动时，是否需要记录变动前的值。</li>
<li><code>attributeFilter</code>：数组，表示需要观察的特定属性（比如<code>[&#39;class&#39;,&#39;src&#39;]</code>）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 开始监听文档根节点（即&lt;html&gt;标签）的变动</span><br><span class="line">mutationObserver.observe(document.documentElement, &#123;</span><br><span class="line">  attributes: true,</span><br><span class="line">  characterData: true,</span><br><span class="line">  childList: true,</span><br><span class="line">  subtree: true,</span><br><span class="line">  attributeOldValue: true,</span><br><span class="line">  characterDataOldValue: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对一个节点添加观察器，就像使用<code>addEventListener()</code>方法一样，多次添加同一个观察器是无效的，回调函数依然只会触发一次。如果指定不同的<code>options</code>对象，以后面添加的那个为准，类似覆盖。</p>
<p>下面的例子是观察新增的子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var insertedNodes &#x3D; [];</span><br><span class="line">var observer &#x3D; new MutationObserver(function(mutations) &#123;</span><br><span class="line">  mutations.forEach(function(mutation) &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; mutation.addedNodes.length; i++) &#123;</span><br><span class="line">      insertedNodes.push(mutation.addedNodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(insertedNodes);</span><br><span class="line">&#125;);</span><br><span class="line">observer.observe(document, &#123; childList: true, subtree: true &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="disconnect-takeRecords"><a href="#disconnect-takeRecords" class="headerlink" title="disconnect(),takeRecords()"></a>disconnect(),takeRecords()</h4><p><code>disconnect()</code>方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>

<p><code>takeRecords()</code>方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.takeRecords();</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 保存所有没有被观察器处理的变动</span><br><span class="line">var changes &#x3D; mutationObserver.takeRecords();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 停止观察</span><br><span class="line">mutationObserver.disconnect();</span><br></pre></td></tr></table></figure>

<h3 id="MutationRecord对象"><a href="#MutationRecord对象" class="headerlink" title="MutationRecord对象"></a>MutationRecord对象</h3><p>DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个<code>MutationRecord</code>实例所组成的数组。</p>
<p><code>MutationRecord</code>对象包含了DOM的相关信息，有如下属性：</p>
<ul>
<li><code>type</code>：观察的变动类型（<code>attributes</code>、<code>characterData</code>或者<code>childList</code>）。</li>
<li><code>target</code>：发生变动的DOM节点。</li>
<li><code>addedNodes</code>：新增的DOM节点。</li>
<li><code>removedNodes</code>：删除的DOM节点。</li>
<li><code>previousSibling</code>：前一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>nextSibling</code>：下一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>attributeName</code>：发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性。</li>
<li><code>oldValue</code>：变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回<code>null</code>。</li>
</ul>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="子元素的变动"><a href="#子元素的变动" class="headerlink" title="子元素的变动"></a>子元素的变动</h4><p>下面的例子说明如何读取变动记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var callback &#x3D; function (records)&#123;</span><br><span class="line">  records.map(function(record)&#123;</span><br><span class="line">    console.log(&#39;Mutation type: &#39; + record.type);</span><br><span class="line">    console.log(&#39;Mutation target: &#39; + record.target);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var mo &#x3D; new MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">var option &#x3D; &#123;</span><br><span class="line">  &#39;childList&#39;: true,</span><br><span class="line">  &#39;subtree&#39;: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mo.observe(document.body, option);</span><br></pre></td></tr></table></figure>

<p>上面代码的观察器，观察``的所有下级节点（<code>childList</code>表示观察子节点，<code>subtree</code>表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。</p>
<h4 id="属性的变动"><a href="#属性的变动" class="headerlink" title="属性的变动"></a>属性的变动</h4><p>下面的例子说明如何追踪属性的变动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var callback &#x3D; function (records) &#123;</span><br><span class="line">  records.map(function (record) &#123;</span><br><span class="line">    console.log(&#39;Previous attribute value: &#39; + record.oldValue);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var mo &#x3D; new MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">var element &#x3D; document.getElementById(&#39;#my_element&#39;);</span><br><span class="line"></span><br><span class="line">var options &#x3D; &#123;</span><br><span class="line">  &#39;attributes&#39;: true,</span><br><span class="line">  &#39;attributeOldValue&#39;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mo.observe(element, options);</span><br></pre></td></tr></table></figure>

<p>上面代码先设定追踪属性变动（<code>&#39;attributes&#39;: true</code>），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。</p>
<h4 id="取代DOMContentLoaded事件"><a href="#取代DOMContentLoaded事件" class="headerlink" title="取代DOMContentLoaded事件"></a>取代DOMContentLoaded事件</h4><p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var observer &#x3D; new MutationObserver(callback);</span><br><span class="line">observer.observe(document.documentElement, &#123;</span><br><span class="line">  childList: true,</span><br><span class="line">  subtree: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，监听<code>document.documentElement</code>（即网页的``HTML 节点）的子节点的变动，<code>subtree</code>属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p>
<p>下面的代码，使用<code>MutationObserver</code>对象封装一个监听 DOM 生成的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> listeners = [];</span><br><span class="line">  <span class="keyword">var</span> doc = win.document;</span><br><span class="line">  <span class="keyword">var</span> MutationObserver = win.MutationObserver || win.WebKitMutationObserver;</span><br><span class="line">  <span class="keyword">var</span> observer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">selector, fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 储存选择器和回调函数</span></span><br><span class="line">    listeners.push(&#123;</span><br><span class="line">      selector: selector,</span><br><span class="line">      fn: fn</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(!observer)&#123;</span><br><span class="line">      <span class="comment">// 监听document变化</span></span><br><span class="line">      observer = <span class="keyword">new</span> MutationObserver(check);</span><br><span class="line">      observer.observe(doc.documentElement, &#123;</span><br><span class="line">        childList: <span class="literal">true</span>,</span><br><span class="line">        subtree: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查该节点是否已经在DOM中</span></span><br><span class="line">    check();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否匹配已储存的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> listener = listeners[i];</span><br><span class="line">      <span class="comment">// 检查指定节点是否有匹配</span></span><br><span class="line">      <span class="keyword">var</span> elements = doc.querySelectorAll(listener.selector);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; elements.length; j++)&#123;</span><br><span class="line">        <span class="keyword">var</span> element = elements[j];</span><br><span class="line">        <span class="comment">// 确保回调函数只会对该元素调用一次</span></span><br><span class="line">        <span class="keyword">if</span>(!element.ready)&#123;</span><br><span class="line">          element.ready = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 对该节点调用回调函数</span></span><br><span class="line">          listener.fn.call(element, element);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对外暴露ready</span></span><br><span class="line">  win.ready = ready;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">ready(<span class="string">'.foo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Cheers</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xiaoxin1993.gitee.io/2020/04/23/js-DOM%E6%A8%A1%E5%9E%8B/">https://xiaoxin1993.gitee.io/2020/04/23/js-DOM%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/xiaoxin1993/imgs/raw/master/blog/posts/cover/helloworld.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/23/js-BOM%E6%A8%A1%E5%9E%8B/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">js-BOM模型</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/23/js-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">js-异步操作</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/23/js-导论/" title="js-导论"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-23</div><div class="relatedPosts_title">js-导论</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/23/js-异步操作/" title="js-异步操作"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-23</div><div class="relatedPosts_title">js-异步操作</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/js-附录：网页元素接口/" title="js-附录：网页元素接口"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">js-附录：网页元素接口</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/24/js-语法专题/" title="js-语法专题"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-24</div><div class="relatedPosts_title">js-语法专题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/js-事件/" title="js-事件"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">js-事件</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/11/js-基本语法+数据类型+运算符/" title="js-基本语法+数据类型+运算符"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-11</div><div class="relatedPosts_title">js-基本语法+数据类型+运算符</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Cheers</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>